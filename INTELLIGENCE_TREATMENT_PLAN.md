# RAGLOX v3.0 - Ø®Ø·Ø© Ø§Ù„Ø¹Ù„Ø§Ø¬ Ø§Ù„Ø°ÙƒÙŠ Ø§Ù„Ø´Ø§Ù…Ù„Ø©
# Intelligence Treatment Plan - Ù…Ù† Ø£Ø¯Ø§Ø© Ø£ØªÙ…ØªØ© Ø¥Ù„Ù‰ Ø´Ø±ÙŠÙƒ Ø°ÙƒÙŠ

> **Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø­Ø§Ù„ÙŠ**: 6.5/10 (Ù…ØªÙˆØ³Ø·-Ù…ØªÙ‚Ø¯Ù…) - Ø£Ø¯Ø§Ø© Ø£ØªÙ…ØªØ© Ø°ÙƒÙŠØ© Ù…Ø­Ø¯ÙˆØ¯Ø©
> **Ø§Ù„Ù‡Ø¯Ù**: 9/10 - Ø´Ø±ÙŠÙƒ ØªÙÙƒÙŠØ± Ø°ÙƒÙŠ (Thought Partner) Ù„ÙØ±Ù‚ Red Team Ø§Ù„Ù…Ø­ØªØ±ÙØ©
> **ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡**: 2026-01-02

---

## ğŸ“‹ Ø§Ù„Ù…Ù„Ø®Øµ Ø§Ù„ØªÙ†ÙÙŠØ°ÙŠ

### Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø±Ø§Ù‡Ù†Ø©
RAGLOX v3.0 ÙŠØ¹Ù…Ù„ Ø­Ø§Ù„ÙŠØ§Ù‹ ÙƒØ£Ø¯Ø§Ø© **Limited Intelligent Automation** ÙˆÙ„ÙŠØ³ ÙƒÙ€ **Thought Partner**:
- **80% Scripted Automation** Ù…Ù‚Ø§Ø¨Ù„ **20% Agentic Reasoning**
- Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ LLM ÙÙŠ ~10-15% Ù…Ù† Ø§Ù„Ø­Ø§Ù„Ø§Øª ÙÙ‚Ø·
- Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ø«Ø§Ø¨ØªØ© (Hardcoded) ÙˆØºÙŠØ± ØªÙƒÙŠÙÙŠØ©
- Ø§Ù„Ù†Ø¸Ø§Ù… **Reactive** ÙÙ‚Ø· ÙˆÙ„Ø§ ÙŠÙÙƒØ± Ù…Ø³Ø¨Ù‚Ø§Ù‹ (No Proactive Planning)

### Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø®Ø·Ø© Ø§Ù„Ø¹Ù„Ø§Ø¬ÙŠØ©
1. **Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ù…Ø²Ø§ÙŠØ§ LLM** - Ù„Ø§ Ù†ÙÙ‚Ø¯ Ù‚Ø¯Ø±Ø§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ø­Ø§Ù„ÙŠØ©
2. **Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¹Ø±ÙØ© Ø§Ù„Ù…Ø¶Ù…Ù†Ø©** - Ù…Ø³Ø§Ø±Ø§Øª Knowledge Base ØªØ¨Ù‚Ù‰ ÙØ¹Ø§Ù„Ø©
3. **ØªØ¹Ø²ÙŠØ² Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„ØªÙƒÙŠÙÙŠ** - ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù… Ù…Ù† Reactive Ø¥Ù„Ù‰ Adaptive
4. **Ø±Ø¨Ø· Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø°ÙƒÙŠØ§Ù‹** - Cross-Workspace Intelligence

---

## ğŸ—ï¸ Ø§Ù„Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠ Ø§Ù„Ù…Ù‚ØªØ±Ø­ - Hybrid Intelligence Architecture

### Ø§Ù„Ù…Ø¨Ø¯Ø£ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ: "LLM as Advisor, Knowledge as Foundation"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     RAGLOX v3.0 Hybrid Intelligence Layer                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚   Operational   â”‚â—„â”€â”€â–ºâ”‚  Intelligence   â”‚â—„â”€â”€â–ºâ”‚    Strategic    â”‚         â”‚
â”‚  â”‚     Memory      â”‚    â”‚   Coordinator   â”‚    â”‚     Scorer      â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚           â”‚                      â”‚                      â”‚                   â”‚
â”‚           â–¼                      â–¼                      â–¼                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚                     Shared Decision Context                      â”‚       â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚       â”‚
â”‚  â”‚  â”‚  Historical â”‚  â”‚   Current   â”‚  â”‚  Predictive â”‚              â”‚       â”‚
â”‚  â”‚  â”‚   Patterns  â”‚  â”‚   Context   â”‚  â”‚   Scoring   â”‚              â”‚       â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                          EXISTING COMPONENTS (Enhanced)                     â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚  Recon         â”‚    â”‚   Analysis      â”‚    â”‚    Attack       â”‚         â”‚
â”‚  â”‚  Specialist    â”‚â—„â”€â”€â–ºâ”‚   Specialist    â”‚â—„â”€â”€â–ºâ”‚   Specialist    â”‚         â”‚
â”‚  â”‚  (Enhanced)    â”‚    â”‚   (Enhanced)    â”‚    â”‚   (Enhanced)    â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚           â”‚                      â”‚                      â”‚                   â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                                  â–¼                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚                        Blackboard (Enhanced)                     â”‚       â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚       â”‚
â”‚  â”‚  â”‚   Targets   â”‚  â”‚    Vulns    â”‚  â”‚   Sessions  â”‚              â”‚       â”‚
â”‚  â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚              â”‚       â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚       â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚       â”‚
â”‚  â”‚  â”‚        NEW: Operational Memory Store            â”‚            â”‚       â”‚
â”‚  â”‚  â”‚   (Decision History, Success Patterns, Failures)â”‚            â”‚       â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                           KNOWLEDGE LAYER (Preserved)                       â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚    Embedded     â”‚    â”‚     Nuclei      â”‚    â”‚      LLM        â”‚         â”‚
â”‚  â”‚   Knowledge     â”‚â—„â”€â”€â–ºâ”‚   Templates     â”‚â—„â”€â”€â–ºâ”‚    Service      â”‚         â”‚
â”‚  â”‚   (RX Modules)  â”‚    â”‚   (CVE DB)      â”‚    â”‚   (Advisor)     â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ§  Ø§Ù„Ù…ÙƒÙˆÙ† 1: Operational Memory (Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ©)

### Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
```python
# analysis.py - Ø§Ù„Ø³Ø·Ø± 183
self._analysis_history: List[Dict[str, Any]] = []

# Ø§Ù„Ù…Ø´ÙƒÙ„Ø©: ÙŠÙÙƒØªØ¨ Ø¥Ù„ÙŠÙ‡ ÙˆÙ„Ø§ ÙŠÙÙ‚Ø±Ø£ Ø£Ø¨Ø¯Ø§Ù‹ ÙÙŠ Ø§ØªØ®Ø§Ø° Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª!
```

### Ø§Ù„Ø­Ù„ Ø§Ù„Ù…Ù‚ØªØ±Ø­

**Ù…Ù„Ù Ø¬Ø¯ÙŠØ¯: `/src/core/operational_memory.py`**

```python
"""
RAGLOX v3.0 - Operational Memory
Ø°Ø§ÙƒØ±Ø© ØªØ´ØºÙŠÙ„ÙŠØ© Ù…Ø´ØªØ±ÙƒØ© Ù„Ù„ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„ØªØ¬Ø§Ø±Ø¨ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©

Ø§Ù„Ù…Ø¨Ø¯Ø£: ÙƒÙ„ Ù‚Ø±Ø§Ø± ÙŠÙØ³Ø¬ÙÙ‘Ù„ØŒ ÙƒÙ„ ÙØ´Ù„ ÙŠÙØ­Ù„ÙÙ‘Ù„ØŒ ÙƒÙ„ Ù†Ø¬Ø§Ø­ ÙŠÙØ³ØªÙØ§Ø¯ Ù…Ù†Ù‡
"""

import asyncio
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple
from uuid import UUID, uuid4

import json
from collections import defaultdict


class DecisionOutcome(Enum):
    """Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª"""
    SUCCESS = "success"
    FAILURE = "failure"
    PARTIAL = "partial"
    TIMEOUT = "timeout"
    BLOCKED = "blocked"


class OperationalContext(Enum):
    """Ø³ÙŠØ§Ù‚ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©"""
    EXPLOIT = "exploit"
    RECON = "recon"
    PRIVESC = "privesc"
    LATERAL = "lateral"
    CRED_HARVEST = "cred_harvest"


@dataclass
class DecisionRecord:
    """Ø³Ø¬Ù„ Ù‚Ø±Ø§Ø± ÙˆØ§Ø­Ø¯"""
    id: UUID = field(default_factory=uuid4)
    mission_id: UUID = None
    timestamp: datetime = field(default_factory=datetime.utcnow)
    
    # Ø§Ù„Ø³ÙŠØ§Ù‚
    context: OperationalContext = OperationalContext.EXPLOIT
    target_id: Optional[str] = None
    vuln_type: Optional[str] = None
    target_os: Optional[str] = None
    target_services: List[str] = field(default_factory=list)
    
    # Ø§Ù„Ù‚Ø±Ø§Ø±
    decision_type: str = ""  # retry, modify, skip, escalate
    decision_source: str = ""  # llm, rules, memory
    parameters_used: Dict[str, Any] = field(default_factory=dict)
    
    # Ø§Ù„Ù†ØªÙŠØ¬Ø©
    outcome: DecisionOutcome = DecisionOutcome.FAILURE
    outcome_details: Dict[str, Any] = field(default_factory=dict)
    duration_ms: int = 0
    
    # Ù„Ù„ØªØ¹Ù„Ù…
    success_factors: List[str] = field(default_factory=list)
    failure_factors: List[str] = field(default_factory=list)
    lessons_learned: List[str] = field(default_factory=list)


class OperationalMemory:
    """
    Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ© Ù„Ù„Ù†Ø¸Ø§Ù… - Ù…Ø±ÙƒØ² Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„ØªÙƒÙŠÙÙŠ
    
    Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ§Øª:
    1. ØªØ³Ø¬ÙŠÙ„ ÙƒÙ„ Ù‚Ø±Ø§Ø± ÙˆÙ†ØªÙŠØ¬ØªÙ‡
    2. Ø§Ø³ØªØ®Ù„Ø§Øµ Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù†Ø¬Ø§Ø­ ÙˆØ§Ù„ÙØ´Ù„
    3. ØªÙˆÙÙŠØ± ØªÙˆØµÙŠØ§Øª Ù…Ø¨Ù†ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„ØªØ¬Ø§Ø±Ø¨ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
    4. ØªØ­Ø¯ÙŠØ« Ø§Ø­ØªÙ…Ø§Ù„Ø§Øª Ø§Ù„Ù†Ø¬Ø§Ø­ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Ù‹
    """
    
    # TTL Ù„Ù„Ø°Ø§ÙƒØ±Ø© Ù‚ØµÙŠØ±Ø© Ø§Ù„Ù…Ø¯Ù‰ (Ø³Ø§Ø¹Ø© ÙˆØ§Ø­Ø¯Ø©)
    SHORT_TERM_TTL = timedelta(hours=1)
    
    # TTL Ù„Ù„Ø°Ø§ÙƒØ±Ø© Ø·ÙˆÙŠÙ„Ø© Ø§Ù„Ù…Ø¯Ù‰ (30 ÙŠÙˆÙ…)
    LONG_TERM_TTL = timedelta(days=30)
    
    def __init__(self, blackboard=None, redis_client=None):
        """
        Args:
            blackboard: Blackboard instance Ù„Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø´ØªØ±Ùƒ
            redis_client: Redis client Ù„Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø³ØªÙ…Ø±
        """
        self._blackboard = blackboard
        self._redis = redis_client
        
        # Ø°Ø§ÙƒØ±Ø© Ù…Ø­Ù„ÙŠØ© (ÙÙŠ Ø§Ù„Ù€ process)
        self._short_term: Dict[str, DecisionRecord] = {}
        self._pattern_cache: Dict[str, Dict] = {}
        
        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…Ø­Ø³ÙˆØ¨Ø©
        self._success_rates: Dict[str, float] = defaultdict(lambda: 0.5)
        self._technique_effectiveness: Dict[str, Dict] = {}
        
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ø§Ù„ØªØ³Ø¬ÙŠÙ„ - ÙƒÙ„ Ù‚Ø±Ø§Ø± ÙŠÙØ³Ø¬ÙÙ‘Ù„
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async def record_decision(
        self,
        mission_id: UUID,
        context: OperationalContext,
        decision_type: str,
        decision_source: str,
        parameters: Dict[str, Any],
        target_info: Optional[Dict] = None,
        vuln_info: Optional[Dict] = None
    ) -> UUID:
        """
        ØªØ³Ø¬ÙŠÙ„ Ù‚Ø±Ø§Ø± Ø¬Ø¯ÙŠØ¯ Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†ÙÙŠØ°.
        
        Returns:
            UUID Ù„Ù„Ù‚Ø±Ø§Ø± Ù„Ù„ØªØ­Ø¯ÙŠØ« Ù„Ø§Ø­Ù‚Ø§Ù‹
        """
        record = DecisionRecord(
            mission_id=mission_id,
            context=context,
            decision_type=decision_type,
            decision_source=decision_source,
            parameters_used=parameters,
            target_id=target_info.get("id") if target_info else None,
            target_os=target_info.get("os") if target_info else None,
            target_services=target_info.get("services", []) if target_info else [],
            vuln_type=vuln_info.get("type") if vuln_info else None
        )
        
        # ØªØ®Ø²ÙŠÙ† ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù‚ØµÙŠØ±Ø©
        self._short_term[str(record.id)] = record
        
        # ØªØ®Ø²ÙŠÙ† ÙÙŠ Redis Ø¥Ø°Ø§ Ù…ØªØ§Ø­
        if self._redis:
            await self._persist_record(record)
        
        return record.id
    
    async def update_outcome(
        self,
        decision_id: UUID,
        outcome: DecisionOutcome,
        details: Dict[str, Any],
        duration_ms: int = 0,
        lessons: Optional[List[str]] = None
    ) -> None:
        """
        ØªØ­Ø¯ÙŠØ« Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù‚Ø±Ø§Ø± Ø¨Ø¹Ø¯ Ø§Ù„ØªÙ†ÙÙŠØ°.
        
        Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø·ÙˆØ© Ø­Ø§Ø³Ù…Ø© - Ø¨Ø¯ÙˆÙ†Ù‡Ø§ Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªØ¹Ù„Ù…!
        """
        record_key = str(decision_id)
        
        if record_key not in self._short_term:
            # Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ù…Ù† Redis
            record = await self._fetch_record(decision_id)
            if not record:
                return
            self._short_term[record_key] = record
        
        record = self._short_term[record_key]
        record.outcome = outcome
        record.outcome_details = details
        record.duration_ms = duration_ms
        
        if lessons:
            record.lessons_learned = lessons
        
        # Ø§Ø³ØªØ®Ù„Ø§Øµ Ø¹ÙˆØ§Ù…Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­/Ø§Ù„ÙØ´Ù„
        self._extract_factors(record)
        
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
        await self._update_statistics(record)
        
        # ØªØ®Ø²ÙŠÙ† Ø§Ù„ØªØ­Ø¯ÙŠØ«
        if self._redis:
            await self._persist_record(record)
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… - Ø§Ù„ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„ØªØ¬Ø§Ø±Ø¨
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async def get_similar_experiences(
        self,
        context: OperationalContext,
        target_os: Optional[str] = None,
        vuln_type: Optional[str] = None,
        limit: int = 10
    ) -> List[DecisionRecord]:
        """
        Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ØªØ¬Ø§Ø±Ø¨ Ù…Ø´Ø§Ø¨Ù‡Ø© Ù„Ù„Ø³ÙŠØ§Ù‚ Ø§Ù„Ø­Ø§Ù„ÙŠ.
        
        Ù‡Ø°Ø§ Ù‡Ùˆ Ù‚Ù„Ø¨ Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„ØªÙƒÙŠÙÙŠ - Ù†ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ù…Ø§Ø¶ÙŠ!
        
        Args:
            context: Ù†ÙˆØ¹ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©
            target_os: Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù
            vuln_type: Ù†ÙˆØ¹ Ø§Ù„Ø«ØºØ±Ø©
            limit: Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ù†ØªØ§Ø¦Ø¬
            
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø§Ù„ØªØ¬Ø§Ø±Ø¨ Ø§Ù„Ù…Ø´Ø§Ø¨Ù‡Ø© Ù…Ø±ØªØ¨Ø© Ø¨Ø§Ù„Ø£Ø­Ø¯Ø«
        """
        matches = []
        
        # Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø­Ù„ÙŠØ©
        for record in self._short_term.values():
            score = self._calculate_similarity(record, context, target_os, vuln_type)
            if score > 0.5:  # Ø¹ØªØ¨Ø© Ø§Ù„ØªØ´Ø§Ø¨Ù‡
                matches.append((score, record))
        
        # Ø¨Ø­Ø« ÙÙŠ Redis Ø¥Ø°Ø§ Ù„Ù… Ù†Ø¬Ø¯ ÙƒÙØ§ÙŠØ©
        if len(matches) < limit and self._redis:
            redis_matches = await self._search_redis(context, target_os, vuln_type, limit)
            for record in redis_matches:
                score = self._calculate_similarity(record, context, target_os, vuln_type)
                matches.append((score, record))
        
        # ØªØ±ØªÙŠØ¨ Ø¨Ø§Ù„ØªØ´Ø§Ø¨Ù‡ Ø«Ù… Ø¨Ø§Ù„ÙˆÙ‚Øª
        matches.sort(key=lambda x: (x[0], x[1].timestamp), reverse=True)
        
        return [m[1] for m in matches[:limit]]
    
    async def get_success_rate_for_context(
        self,
        context: OperationalContext,
        target_os: Optional[str] = None,
        vuln_type: Optional[str] = None
    ) -> Tuple[float, int]:
        """
        Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­ Ù„Ø³ÙŠØ§Ù‚ Ù…Ø¹ÙŠÙ† Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØªØ¬Ø§Ø±Ø¨.
        
        Returns:
            (success_rate, sample_count)
        """
        cache_key = f"{context.value}:{target_os or 'any'}:{vuln_type or 'any'}"
        
        if cache_key in self._success_rates:
            experiences = await self.get_similar_experiences(context, target_os, vuln_type, limit=50)
            if experiences:
                successes = sum(1 for e in experiences if e.outcome == DecisionOutcome.SUCCESS)
                rate = successes / len(experiences)
                self._success_rates[cache_key] = rate
                return rate, len(experiences)
        
        return self._success_rates[cache_key], 0
    
    async def get_best_approach_for_context(
        self,
        context: OperationalContext,
        target_os: Optional[str] = None,
        vuln_type: Optional[str] = None,
        available_modules: Optional[List[str]] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Ø§Ø³ØªÙ†ØªØ§Ø¬ Ø£ÙØ¶Ù„ Ù†Ù‡Ø¬ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØªØ¬Ø§Ø±Ø¨ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©.
        
        Ù‡Ø°Ø§ Ù‡Ùˆ "Ø§Ù„ØªÙÙƒÙŠØ±" Ø§Ù„Ù…Ø¨Ù†ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø°Ø§ÙƒØ±Ø©!
        
        Returns:
            Dict Ù…Ø¹ Ø§Ù„ØªÙˆØµÙŠØ§Øª Ø£Ùˆ None Ø¥Ø°Ø§ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª ÙƒØ§ÙÙŠØ©
        """
        experiences = await self.get_similar_experiences(context, target_os, vuln_type, limit=20)
        
        if len(experiences) < 3:
            # Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ÙƒØ§ÙÙŠØ© Ù„Ù„ØªÙˆØµÙŠØ©
            return None
        
        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù†Ø§Ø¬Ø­Ø©
        successful = [e for e in experiences if e.outcome == DecisionOutcome.SUCCESS]
        failed = [e for e in experiences if e.outcome == DecisionOutcome.FAILURE]
        
        if not successful:
            return {
                "confidence": "low",
                "recommendation": "no_success_pattern",
                "common_failure_factors": self._extract_common_factors(failed),
                "suggested_action": "escalate_to_llm"
            }
        
        # Ø§Ø³ØªØ®Ù„Ø§Øµ Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù†Ø¬Ø§Ø­
        success_patterns = self._extract_success_patterns(successful)
        
        # ÙÙ„ØªØ±Ø© Ø¨Ø§Ù„Ù…ÙˆØ¯ÙŠÙˆÙ„Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©
        if available_modules:
            relevant_patterns = [
                p for p in success_patterns 
                if p.get("module") in available_modules
            ]
            if relevant_patterns:
                success_patterns = relevant_patterns
        
        return {
            "confidence": "high" if len(successful) >= 5 else "medium",
            "success_rate": len(successful) / len(experiences),
            "recommended_approach": success_patterns[0] if success_patterns else None,
            "alternative_approaches": success_patterns[1:3] if len(success_patterns) > 1 else [],
            "avoid_factors": self._extract_common_factors(failed)[:3],
            "sample_size": len(experiences)
        }
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ø§Ù„ØªØ­Ù„ÙŠÙ„ - Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ø£Ù†Ù…Ø§Ø·
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _calculate_similarity(
        self,
        record: DecisionRecord,
        context: OperationalContext,
        target_os: Optional[str],
        vuln_type: Optional[str]
    ) -> float:
        """Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© Ø§Ù„ØªØ´Ø§Ø¨Ù‡ Ø¨ÙŠÙ† Ø³Ø¬Ù„ ÙˆØ§Ù„Ø³ÙŠØ§Ù‚ Ø§Ù„Ø­Ø§Ù„ÙŠ."""
        score = 0.0
        
        # ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ø³ÙŠØ§Ù‚ (Ø£Ù‡Ù… Ø¹Ø§Ù…Ù„)
        if record.context == context:
            score += 0.4
        
        # ØªØ·Ø§Ø¨Ù‚ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ØºÙŠÙ„
        if target_os and record.target_os:
            if target_os.lower() in record.target_os.lower():
                score += 0.3
            elif ("windows" in target_os.lower()) == ("windows" in record.target_os.lower()):
                score += 0.15
        
        # ØªØ·Ø§Ø¨Ù‚ Ù†ÙˆØ¹ Ø§Ù„Ø«ØºØ±Ø©
        if vuln_type and record.vuln_type:
            if vuln_type == record.vuln_type:
                score += 0.3
            elif vuln_type.split("-")[0] == record.vuln_type.split("-")[0]:
                score += 0.15
        
        return score
    
    def _extract_factors(self, record: DecisionRecord) -> None:
        """Ø§Ø³ØªØ®Ù„Ø§Øµ Ø¹ÙˆØ§Ù…Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­/Ø§Ù„ÙØ´Ù„ Ù…Ù† Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù‚Ø±Ø§Ø±."""
        details = record.outcome_details
        
        if record.outcome == DecisionOutcome.SUCCESS:
            # Ø¹ÙˆØ§Ù…Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­
            if details.get("evasion_used"):
                record.success_factors.append("evasion_technique")
            if details.get("encoded_payload"):
                record.success_factors.append("payload_encoding")
            if details.get("timing_optimized"):
                record.success_factors.append("timing_optimization")
            if record.parameters_used.get("module"):
                record.success_factors.append(f"module:{record.parameters_used['module']}")
                
        elif record.outcome == DecisionOutcome.FAILURE:
            # Ø¹ÙˆØ§Ù…Ù„ Ø§Ù„ÙØ´Ù„
            error_type = details.get("error_type", "unknown")
            record.failure_factors.append(f"error:{error_type}")
            
            if details.get("detected_defenses"):
                for defense in details["detected_defenses"]:
                    record.failure_factors.append(f"defense:{defense}")
            
            if details.get("timeout"):
                record.failure_factors.append("timeout")
    
    def _extract_success_patterns(self, successful: List[DecisionRecord]) -> List[Dict]:
        """Ø§Ø³ØªØ®Ù„Ø§Øµ Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù†Ø¬Ø§Ø­ Ù…Ù† Ø§Ù„ØªØ¬Ø§Ø±Ø¨ Ø§Ù„Ù†Ø§Ø¬Ø­Ø©."""
        patterns = defaultdict(lambda: {"count": 0, "factors": [], "parameters": {}})
        
        for record in successful:
            # ØªØ¬Ù…ÙŠØ¹ Ø¨Ø§Ù„Ù…ÙˆØ¯ÙŠÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            module = record.parameters_used.get("module", "default")
            pattern = patterns[module]
            pattern["count"] += 1
            pattern["module"] = module
            pattern["factors"].extend(record.success_factors)
            
            # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¨Ø§Ø±Ø§Ù…ØªØ±Ø§Øª Ø§Ù„Ù†Ø§Ø¬Ø­Ø©
            for key, value in record.parameters_used.items():
                if key not in pattern["parameters"]:
                    pattern["parameters"][key] = []
                pattern["parameters"][key].append(value)
        
        # ØªØ±ØªÙŠØ¨ Ø¨Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø¬Ø§Ø­Ø§Øª
        sorted_patterns = sorted(
            patterns.values(), 
            key=lambda x: x["count"], 
            reverse=True
        )
        
        # ØªÙ†Ø¸ÙŠÙ ÙˆØ¥Ø±Ø¬Ø§Ø¹
        result = []
        for p in sorted_patterns:
            result.append({
                "module": p["module"],
                "success_count": p["count"],
                "common_factors": list(set(p["factors"]))[:5],
                "recommended_parameters": {
                    k: max(set(v), key=v.count) 
                    for k, v in p["parameters"].items()
                }
            })
        
        return result
    
    def _extract_common_factors(self, records: List[DecisionRecord]) -> List[str]:
        """Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ø¹ÙˆØ§Ù…Ù„ Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© Ù…Ù† Ù…Ø¬Ù…ÙˆØ¹Ø© Ø³Ø¬Ù„Ø§Øª."""
        all_factors = []
        for record in records:
            all_factors.extend(record.failure_factors or record.success_factors)
        
        if not all_factors:
            return []
        
        # Ø¹Ø¯ Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª
        factor_counts = defaultdict(int)
        for factor in all_factors:
            factor_counts[factor] += 1
        
        # ØªØ±ØªÙŠØ¨ Ø¨Ø§Ù„ØªÙƒØ±Ø§Ø±
        sorted_factors = sorted(
            factor_counts.items(), 
            key=lambda x: x[1], 
            reverse=True
        )
        
        return [f[0] for f in sorted_factors[:5]]
    
    async def _update_statistics(self, record: DecisionRecord) -> None:
        """ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø¨Ø¹Ø¯ ÙƒÙ„ Ù‚Ø±Ø§Ø±."""
        context_key = f"{record.context.value}:{record.target_os or 'any'}"
        
        # Ù‡Ø°Ø§ ÙŠÙÙØ¹ÙÙ‘Ù„ Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­
        if context_key in self._success_rates:
            del self._success_rates[context_key]
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø³ØªÙ…Ø± (Redis)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async def _persist_record(self, record: DecisionRecord) -> None:
        """ØªØ®Ø²ÙŠÙ† Ø³Ø¬Ù„ ÙÙŠ Redis."""
        if not self._redis:
            return
        
        key = f"opmem:record:{record.id}"
        data = {
            "id": str(record.id),
            "mission_id": str(record.mission_id) if record.mission_id else None,
            "timestamp": record.timestamp.isoformat(),
            "context": record.context.value,
            "target_id": record.target_id,
            "vuln_type": record.vuln_type,
            "target_os": record.target_os,
            "decision_type": record.decision_type,
            "decision_source": record.decision_source,
            "parameters_used": json.dumps(record.parameters_used),
            "outcome": record.outcome.value,
            "outcome_details": json.dumps(record.outcome_details),
            "duration_ms": record.duration_ms,
            "success_factors": json.dumps(record.success_factors),
            "failure_factors": json.dumps(record.failure_factors),
            "lessons_learned": json.dumps(record.lessons_learned)
        }
        
        await self._redis.hset(key, mapping=data)
        await self._redis.expire(key, int(self.LONG_TERM_TTL.total_seconds()))
        
        # Ø¥Ø¶Ø§ÙØ© Ù„Ù„ÙÙ‡Ø±Ø³
        index_key = f"opmem:index:{record.context.value}"
        await self._redis.zadd(index_key, {str(record.id): record.timestamp.timestamp()})
    
    async def _fetch_record(self, record_id: UUID) -> Optional[DecisionRecord]:
        """Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø³Ø¬Ù„ Ù…Ù† Redis."""
        if not self._redis:
            return None
        
        key = f"opmem:record:{record_id}"
        data = await self._redis.hgetall(key)
        
        if not data:
            return None
        
        return DecisionRecord(
            id=UUID(data["id"]),
            mission_id=UUID(data["mission_id"]) if data.get("mission_id") else None,
            timestamp=datetime.fromisoformat(data["timestamp"]),
            context=OperationalContext(data["context"]),
            target_id=data.get("target_id"),
            vuln_type=data.get("vuln_type"),
            target_os=data.get("target_os"),
            decision_type=data.get("decision_type", ""),
            decision_source=data.get("decision_source", ""),
            parameters_used=json.loads(data.get("parameters_used", "{}")),
            outcome=DecisionOutcome(data.get("outcome", "failure")),
            outcome_details=json.loads(data.get("outcome_details", "{}")),
            duration_ms=int(data.get("duration_ms", 0)),
            success_factors=json.loads(data.get("success_factors", "[]")),
            failure_factors=json.loads(data.get("failure_factors", "[]")),
            lessons_learned=json.loads(data.get("lessons_learned", "[]"))
        )
    
    async def _search_redis(
        self,
        context: OperationalContext,
        target_os: Optional[str],
        vuln_type: Optional[str],
        limit: int
    ) -> List[DecisionRecord]:
        """Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Redis Ø¹Ù† Ø³Ø¬Ù„Ø§Øª Ù…Ø´Ø§Ø¨Ù‡Ø©."""
        if not self._redis:
            return []
        
        # Ø§Ù„Ø¨Ø­Ø« ÙÙŠ ÙÙ‡Ø±Ø³ Ø§Ù„Ø³ÙŠØ§Ù‚
        index_key = f"opmem:index:{context.value}"
        record_ids = await self._redis.zrevrange(index_key, 0, limit * 2)
        
        records = []
        for rid in record_ids:
            record = await self._fetch_record(UUID(rid))
            if record:
                records.append(record)
        
        return records[:limit]
```

### ÙƒÙŠÙÙŠØ© Ø§Ù„Ø¯Ù…Ø¬ Ù…Ø¹ AnalysisSpecialist

```python
# ÙÙŠ analysis.py - ØªØ¹Ø¯ÙŠÙ„ _make_decision

async def _make_decision(self, ...):
    # 1. Ø§Ø³ØªØ´Ø§Ø±Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹
    memory_recommendation = await self.operational_memory.get_best_approach_for_context(
        context=OperationalContext.EXPLOIT,
        target_os=self._get_target_platform(context["target_info"]),
        vuln_type=context.get("vuln_info", {}).get("type")
    )
    
    if memory_recommendation and memory_recommendation["confidence"] == "high":
        # Ù„Ø¯ÙŠÙ†Ø§ ØªÙˆØµÙŠØ© ÙˆØ§Ø«Ù‚Ø© Ù…Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø©
        self.logger.info(f"[MEMORY] Using learned pattern: {memory_recommendation['recommended_approach']}")
        return self._apply_memory_recommendation(memory_recommendation)
    
    # 2. Ø¥Ø°Ø§ Ø§Ù„Ø°Ø§ÙƒØ±Ø© ØºÙŠØ± ÙˆØ§Ø«Ù‚Ø©ØŒ Ø§Ø³ØªØ´Ø± LLM
    if self.llm_enabled and memory_recommendation and memory_recommendation["confidence"] == "medium":
        # Ù†Ù…Ø±Ø± ØªÙˆØµÙŠØ© Ø§Ù„Ø°Ø§ÙƒØ±Ø© ÙƒÙ€ context Ù„Ù€ LLM
        return await self._llm_decision_with_memory_context(
            ...,
            memory_hint=memory_recommendation
        )
    
    # 3. Ø§Ù„Ù€ fallback Ø§Ù„Ø­Ø§Ù„ÙŠ (rule-based)
    return await self._rule_based_fallback(...)
```

---

## ğŸ”— Ø§Ù„Ù…ÙƒÙˆÙ† 2: Intelligence Coordinator (Ù…Ù†Ø³Ù‚ Ø§Ù„Ø°ÙƒØ§Ø¡)

### Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±Ø¨Ø· Ø°ÙƒÙŠ Ø¨ÙŠÙ† Ø§ÙƒØªØ´Ø§ÙØ§Øª ReconSpecialist ÙˆÙ‚Ø±Ø§Ø±Ø§Øª AttackSpecialist:
- ReconSpecialist ÙŠÙƒØªØ´Ù Ø®Ø¯Ù…Ø§Øª ÙˆÙŠÙØ®Ø²Ù‘Ù†Ù‡Ø§
- AttackSpecialist ÙŠÙ‚Ø±Ø£Ù‡Ø§ Ø¨Ø´ÙƒÙ„ Ù…Ù†ÙØµÙ„
- Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±Ø¨Ø· Ø¨ÙŠÙ† "Ù…Ø§Ø°Ø§ Ø§ÙƒØªØ´ÙÙ†Ø§" Ùˆ "ÙƒÙŠÙ Ù†Ù‡Ø§Ø¬Ù…"

### Ø§Ù„Ø­Ù„ Ø§Ù„Ù…Ù‚ØªØ±Ø­

**Ù…Ù„Ù Ø¬Ø¯ÙŠØ¯: `/src/core/intelligence_coordinator.py`**

```python
"""
RAGLOX v3.0 - Intelligence Coordinator
Ù…Ù†Ø³Ù‚ Ø§Ù„Ø°ÙƒØ§Ø¡ Ù„Ù„Ø±Ø¨Ø· Ø§Ù„Ø°ÙƒÙŠ Ø¨ÙŠÙ† Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª

Ø§Ù„Ù…Ø¨Ø¯Ø£: ÙƒÙ„ Ø§ÙƒØªØ´Ø§Ù ÙŠÙØ­Ù„ÙÙ‘Ù„ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Ù‹ØŒ ÙƒÙ„ Ù‡Ø¬ÙˆÙ… ÙŠÙØ®Ø·ÙÙ‘Ø· Ù„Ù‡ Ù…Ø³Ø¨Ù‚Ø§Ù‹
"""

import asyncio
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Set, Tuple
from uuid import UUID, uuid4

from collections import defaultdict


class AttackPathType(Enum):
    """Ø£Ù†ÙˆØ§Ø¹ Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù‡Ø¬ÙˆÙ…"""
    DIRECT_EXPLOIT = "direct_exploit"       # Ø«ØºØ±Ø© Ù…Ø¨Ø§Ø´Ø±Ø©
    CREDENTIAL_BASED = "credential_based"   # Ø¹Ø¨Ø± Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ø¹ØªÙ…Ø§Ø¯
    CHAIN_EXPLOIT = "chain_exploit"         # Ø³Ù„Ø³Ù„Ø© Ø«ØºØ±Ø§Øª
    LATERAL_PIVOT = "lateral_pivot"         # Ù…Ø­ÙˆØ± Ø¬Ø§Ù†Ø¨ÙŠ
    PRIVILEGE_CHAIN = "privilege_chain"     # Ø³Ù„Ø³Ù„Ø© ØªØµØ¹ÙŠØ¯


@dataclass
class AttackPath:
    """Ù…Ø³Ø§Ø± Ù‡Ø¬ÙˆÙ… Ù…Ù‚ØªØ±Ø­"""
    id: UUID = field(default_factory=uuid4)
    path_type: AttackPathType = AttackPathType.DIRECT_EXPLOIT
    
    # Ø§Ù„Ø£Ù‡Ø¯Ø§Ù
    source_target: Optional[str] = None  # Ù…Ù† Ø£ÙŠÙ† Ù†Ø¨Ø¯Ø£
    destination_target: str = ""          # Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
    
    # Ø§Ù„Ø®Ø·ÙˆØ§Øª
    steps: List[Dict[str, Any]] = field(default_factory=list)
    
    # Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
    success_probability: float = 0.5
    stealth_score: float = 0.5          # 1.0 = ØµØ§Ù…Øª ØªÙ…Ø§Ù…Ø§Ù‹
    time_estimate_minutes: int = 30
    risk_level: str = "medium"
    
    # Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª
    prerequisites: List[str] = field(default_factory=list)
    required_credentials: List[str] = field(default_factory=list)
    required_sessions: List[str] = field(default_factory=list)
    
    # Ø§Ù„Ø£Ø³Ø¨Ø§Ø¨
    reasoning: str = ""
    alternative_paths: List[UUID] = field(default_factory=list)


class IntelligenceCoordinator:
    """
    Ù…Ù†Ø³Ù‚ Ø§Ù„Ø°ÙƒØ§Ø¡ - Ø§Ù„Ø¯Ù…Ø§Øº Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ Ù„Ù„Ù†Ø¸Ø§Ù…
    
    Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ§Øª:
    1. Ø±Ø¨Ø· Ø§Ù„Ø§ÙƒØªØ´Ø§ÙØ§Øª Ù…Ù† ReconSpecialist Ø¨Ø®Ø·Ø· Ø§Ù„Ù‡Ø¬ÙˆÙ…
    2. ØªÙˆÙ„ÙŠØ¯ Ù…Ø³Ø§Ø±Ø§Øª Ù‡Ø¬ÙˆÙ… Ø°ÙƒÙŠØ© Ù…ØªØ¹Ø¯Ø¯Ø©
    3. ØªÙ‚ÙŠÙŠÙ… ÙƒÙ„ Ù…Ø³Ø§Ø± Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Ù‹
    4. ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨ÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª
    """
    
    def __init__(
        self,
        blackboard=None,
        operational_memory=None,
        knowledge_base=None,
        llm_service=None
    ):
        """
        Args:
            blackboard: Blackboard Ù„Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©
            operational_memory: Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ¬Ø§Ø±Ø¨ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
            knowledge_base: Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ù…Ø¹Ø±ÙØ© (RX Modules, Nuclei)
            llm_service: Ø®Ø¯Ù…Ø© LLM Ù„Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
        """
        self._blackboard = blackboard
        self._memory = operational_memory
        self._knowledge = knowledge_base
        self._llm = llm_service
        
        # ÙƒØ§Ø´ Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ù…Ø­Ø³ÙˆØ¨Ø©
        self._path_cache: Dict[str, List[AttackPath]] = {}
        
        # Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ø£Ù‡Ø¯Ø§Ù
        self._target_graph: Dict[str, Set[str]] = defaultdict(set)
        
        # Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ø§Ù„Ø£Ù‡Ø¯Ø§Ù
        self._credential_map: Dict[str, List[str]] = defaultdict(list)
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§ÙƒØªØ´Ø§ÙØ§Øª
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async def process_recon_results(
        self,
        mission_id: str,
        target_id: str,
        services: List[Dict],
        vulnerabilities: List[Dict],
        credentials: Optional[List[Dict]] = None
    ) -> Dict[str, Any]:
        """
        Ù…Ø¹Ø§Ù„Ø¬Ø© Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø§Ø³ØªØ·Ù„Ø§Ø¹ ÙˆØªÙˆÙ„ÙŠØ¯ Ø±Ø¤Ù‰ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©.
        
        Ù‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„Ø¬Ø³Ø± Ø¨ÙŠÙ† Recon Ùˆ Attack!
        
        Args:
            mission_id: Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ù‡Ù…Ø©
            target_id: Ù…Ø¹Ø±Ù Ø§Ù„Ù‡Ø¯Ù
            services: Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù…ÙƒØªØ´ÙØ©
            vulnerabilities: Ø§Ù„Ø«ØºØ±Ø§Øª Ø§Ù„Ù…ÙƒØªØ´ÙØ©
            credentials: Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ (Ø¥Ù† ÙˆØ¬Ø¯Øª)
            
        Returns:
            Dict Ù…Ø¹ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ ÙˆØ§Ù„ØªÙˆØµÙŠØ§Øª
        """
        analysis = {
            "target_id": target_id,
            "timestamp": datetime.utcnow().isoformat(),
            "strategic_value": "unknown",
            "attack_surface": [],
            "recommended_paths": [],
            "immediate_actions": [],
            "deferred_actions": [],
            "coordination_notes": []
        }
        
        # 1. ØªÙ‚ÙŠÙŠÙ… Ø³Ø·Ø­ Ø§Ù„Ù‡Ø¬ÙˆÙ…
        attack_surface = await self._analyze_attack_surface(services, vulnerabilities)
        analysis["attack_surface"] = attack_surface
        
        # 2. Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©
        strategic_value = self._calculate_strategic_value(
            services, vulnerabilities, credentials
        )
        analysis["strategic_value"] = strategic_value
        
        # 3. ØªÙˆÙ„ÙŠØ¯ Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù‡Ø¬ÙˆÙ…
        paths = await self.generate_attack_paths(
            target_id=target_id,
            services=services,
            vulnerabilities=vulnerabilities,
            credentials=credentials
        )
        analysis["recommended_paths"] = [
            self._path_to_dict(p) for p in paths[:5]  # Ø£ÙØ¶Ù„ 5 Ù…Ø³Ø§Ø±Ø§Øª
        ]
        
        # 4. ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„ÙÙˆØ±ÙŠØ© ÙˆØ§Ù„Ù…Ø¤Ø¬Ù„Ø©
        immediate, deferred = self._categorize_actions(paths, strategic_value)
        analysis["immediate_actions"] = immediate
        analysis["deferred_actions"] = deferred
        
        # 5. Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„ØªÙ†Ø³ÙŠÙ‚
        analysis["coordination_notes"] = self._generate_coordination_notes(
            target_id, paths, attack_surface
        )
        
        # ØªØ®Ø²ÙŠÙ† Ø§Ù„ØªØ­Ù„ÙŠÙ„
        if self._blackboard:
            await self._store_analysis(mission_id, target_id, analysis)
        
        return analysis
    
    async def _analyze_attack_surface(
        self,
        services: List[Dict],
        vulnerabilities: List[Dict]
    ) -> List[Dict]:
        """ØªØ­Ù„ÙŠÙ„ Ø³Ø·Ø­ Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ù…ØªØ§Ø­."""
        surface = []
        
        for service in services:
            entry = {
                "service": service.get("name"),
                "port": service.get("port"),
                "exposure_level": "high" if service.get("port") in [22, 80, 443, 445, 3389] else "medium",
                "related_vulns": [],
                "attack_vectors": []
            }
            
            # Ø±Ø¨Ø· Ø§Ù„Ø«ØºØ±Ø§Øª Ø¨Ø§Ù„Ø®Ø¯Ù…Ø§Øª
            for vuln in vulnerabilities:
                if self._vuln_matches_service(vuln, service):
                    entry["related_vulns"].append({
                        "id": vuln.get("id"),
                        "type": vuln.get("type"),
                        "severity": vuln.get("severity")
                    })
            
            # ØªØ­Ø¯ÙŠØ¯ Ù†Ø§Ù‚Ù„Ø§Øª Ø§Ù„Ù‡Ø¬ÙˆÙ…
            entry["attack_vectors"] = self._determine_attack_vectors(service, entry["related_vulns"])
            
            surface.append(entry)
        
        return surface
    
    def _calculate_strategic_value(
        self,
        services: List[Dict],
        vulnerabilities: List[Dict],
        credentials: Optional[List[Dict]]
    ) -> str:
        """Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ù„Ù„Ù‡Ø¯Ù."""
        score = 0
        
        # Ù‚ÙŠÙ…Ø© Ø§Ù„Ø®Ø¯Ù…Ø§Øª
        high_value_services = {"ldap", "kerberos", "smb", "rdp", "winrm", "ssh"}
        for service in services:
            if service.get("name", "").lower() in high_value_services:
                score += 20
            else:
                score += 5
        
        # Ù‚ÙŠÙ…Ø© Ø§Ù„Ø«ØºØ±Ø§Øª
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "").lower()
            if severity == "critical":
                score += 30
            elif severity == "high":
                score += 20
            elif severity == "medium":
                score += 10
        
        # Ù‚ÙŠÙ…Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯
        if credentials:
            for cred in credentials:
                priv = cred.get("privilege_level", "user")
                if priv in ("domain_admin", "admin"):
                    score += 50
                elif priv == "user":
                    score += 15
        
        # ØªØµÙ†ÙŠÙ
        if score >= 100:
            return "critical"
        elif score >= 60:
            return "high"
        elif score >= 30:
            return "medium"
        return "low"
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ØªÙˆÙ„ÙŠØ¯ Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù‡Ø¬ÙˆÙ…
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async def generate_attack_paths(
        self,
        target_id: str,
        services: List[Dict],
        vulnerabilities: List[Dict],
        credentials: Optional[List[Dict]] = None,
        from_target: Optional[str] = None
    ) -> List[AttackPath]:
        """
        ØªÙˆÙ„ÙŠØ¯ Ù…Ø³Ø§Ø±Ø§Øª Ù‡Ø¬ÙˆÙ… Ø°ÙƒÙŠØ© Ù…ØªØ¹Ø¯Ø¯Ø©.
        
        Ù‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„ØªÙÙƒÙŠØ± Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ!
        
        Args:
            target_id: Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ù…Ø±Ø§Ø¯ Ù…Ù‡Ø§Ø¬Ù…ØªÙ‡
            services: Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©
            vulnerabilities: Ø§Ù„Ø«ØºØ±Ø§Øª Ø§Ù„Ù…ÙƒØªØ´ÙØ©
            credentials: Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ø¹ØªÙ…Ø§Ø¯ Ù…ØªØ§Ø­Ø©
            from_target: Ù‡Ø¯Ù Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© (Ù„Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©)
            
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ù…Ø³Ø§Ø±Ø§Øª Ù…Ø±ØªØ¨Ø© Ø¨Ø§Ù„Ø£ÙØ¶Ù„ÙŠØ©
        """
        paths = []
        
        # 1. Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªØºÙ„Ø§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
        for vuln in vulnerabilities:
            if vuln.get("severity") in ("critical", "high") and vuln.get("exploit_available"):
                path = await self._create_direct_exploit_path(target_id, vuln, services)
                if path:
                    paths.append(path)
        
        # 2. Ù…Ø³Ø§Ø±Ø§Øª Ø¹Ø¨Ø± Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯
        if credentials:
            for cred in credentials:
                path = await self._create_credential_path(target_id, cred, services)
                if path:
                    paths.append(path)
        
        # 3. Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø³Ù„Ø³Ù„Ø© (Chain)
        chain_paths = await self._create_chain_paths(target_id, vulnerabilities, services)
        paths.extend(chain_paths)
        
        # 4. Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©
        if from_target:
            lateral_path = await self._create_lateral_path(from_target, target_id, credentials)
            if lateral_path:
                paths.append(lateral_path)
        
        # Ø§Ø³ØªØ´Ø§Ø±Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„Ø§Øª
        paths = await self._enhance_paths_with_memory(paths)
        
        # ØªØ±ØªÙŠØ¨ Ø¨Ø§Ù„Ø£ÙØ¶Ù„ÙŠØ©
        paths.sort(key=lambda p: (
            p.success_probability * 0.4 +
            p.stealth_score * 0.3 +
            (1 - p.time_estimate_minutes / 120) * 0.3
        ), reverse=True)
        
        return paths
    
    async def _create_direct_exploit_path(
        self,
        target_id: str,
        vuln: Dict,
        services: List[Dict]
    ) -> Optional[AttackPath]:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø± Ø§Ø³ØªØºÙ„Ø§Ù„ Ù…Ø¨Ø§Ø´Ø±."""
        # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…ÙˆØ¯ÙŠÙˆÙ„ Ù…Ù†Ø§Ø³Ø¨
        module = None
        if self._knowledge:
            modules = self._knowledge.search_modules(vuln.get("type", ""), limit=1)
            if modules:
                module = modules[0]
        
        steps = [
            {
                "action": "exploit",
                "target": target_id,
                "vuln_id": vuln.get("id"),
                "module": module.get("rx_module_id") if module else None,
                "description": f"Exploit {vuln.get('type')} vulnerability"
            }
        ]
        
        # Ø¥Ø¶Ø§ÙØ© Ø®Ø·ÙˆØ© ØªØµØ¹ÙŠØ¯ Ø¥Ø°Ø§ Ù„Ø²Ù…
        if vuln.get("initial_privilege", "user") not in ("admin", "system", "root"):
            steps.append({
                "action": "privesc",
                "target": target_id,
                "description": "Privilege escalation required"
            })
        
        return AttackPath(
            path_type=AttackPathType.DIRECT_EXPLOIT,
            destination_target=target_id,
            steps=steps,
            success_probability=self._estimate_exploit_probability(vuln, module),
            stealth_score=self._estimate_stealth_score(vuln, "direct"),
            time_estimate_minutes=15 if module else 30,
            risk_level=vuln.get("severity", "medium"),
            reasoning=f"Direct exploitation of {vuln.get('type')} - {vuln.get('severity')} severity"
        )
    
    async def _create_credential_path(
        self,
        target_id: str,
        cred: Dict,
        services: List[Dict]
    ) -> Optional[AttackPath]:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø± Ø¹Ø¨Ø± Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯."""
        # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø®Ø¯Ù…Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø©
        suitable_service = None
        for service in services:
            svc_name = service.get("name", "").lower()
            if svc_name in ("ssh", "smb", "rdp", "winrm"):
                suitable_service = service
                break
        
        if not suitable_service:
            return None
        
        steps = [
            {
                "action": "authenticate",
                "target": target_id,
                "service": suitable_service.get("name"),
                "port": suitable_service.get("port"),
                "cred_id": cred.get("id"),
                "description": f"Authenticate via {suitable_service.get('name')}"
            }
        ]
        
        # ØªØµØ¹ÙŠØ¯ Ø¥Ø°Ø§ Ù„Ø²Ù…
        if cred.get("privilege_level") not in ("admin", "domain_admin"):
            steps.append({
                "action": "privesc",
                "target": target_id,
                "description": "Privilege escalation after authentication"
            })
        
        return AttackPath(
            path_type=AttackPathType.CREDENTIAL_BASED,
            destination_target=target_id,
            steps=steps,
            success_probability=0.7 if cred.get("verified") else 0.5,
            stealth_score=0.8,  # Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ø£Ù‚Ù„ Ø¶Ø¬ÙŠØ¬Ø§Ù‹
            time_estimate_minutes=10,
            risk_level="low",
            required_credentials=[cred.get("id")],
            reasoning=f"Credential-based access via {suitable_service.get('name')}"
        )
    
    async def _create_chain_paths(
        self,
        target_id: str,
        vulnerabilities: List[Dict],
        services: List[Dict]
    ) -> List[AttackPath]:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø±Ø§Øª Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ø«ØºØ±Ø§Øª."""
        chains = []
        
        # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø«ØºØ±Ø§Øª ÙŠÙ…ÙƒÙ† ØªØ³Ù„Ø³Ù„Ù‡Ø§
        info_vulns = [v for v in vulnerabilities if v.get("severity") in ("info", "low")]
        exploit_vulns = [v for v in vulnerabilities if v.get("severity") in ("high", "critical")]
        
        for info_vuln in info_vulns[:2]:  # Ø£ÙˆÙ„ Ø«ØºØ±ØªÙŠÙ† Ù„Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
            for exploit_vuln in exploit_vulns[:2]:  # Ø£ÙˆÙ„ Ø«ØºØ±ØªÙŠÙ† Ù„Ù„Ø§Ø³ØªØºÙ„Ø§Ù„
                chain = AttackPath(
                    path_type=AttackPathType.CHAIN_EXPLOIT,
                    destination_target=target_id,
                    steps=[
                        {
                            "action": "recon",
                            "vuln_id": info_vuln.get("id"),
                            "description": f"Gather info via {info_vuln.get('type')}"
                        },
                        {
                            "action": "exploit",
                            "vuln_id": exploit_vuln.get("id"),
                            "description": f"Exploit {exploit_vuln.get('type')}"
                        }
                    ],
                    success_probability=0.4,  # Ø³Ù„Ø§Ø³Ù„ Ø£ØµØ¹Ø¨
                    stealth_score=0.6,
                    time_estimate_minutes=45,
                    risk_level="medium",
                    reasoning=f"Chain: {info_vuln.get('type')} â†’ {exploit_vuln.get('type')}"
                )
                chains.append(chain)
        
        return chains
    
    async def _create_lateral_path(
        self,
        from_target: str,
        to_target: str,
        credentials: Optional[List[Dict]]
    ) -> Optional[AttackPath]:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø± Ø­Ø±ÙƒØ© Ø¬Ø§Ù†Ø¨ÙŠØ©."""
        if not credentials:
            return None
        
        # Ø§Ø®ØªÙŠØ§Ø± Ø£ÙØ¶Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ø¹ØªÙ…Ø§Ø¯ Ù„Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©
        best_cred = max(
            credentials,
            key=lambda c: 1 if c.get("privilege_level") == "domain_admin" else 
                         0.7 if c.get("privilege_level") == "admin" else 0.3
        )
        
        return AttackPath(
            path_type=AttackPathType.LATERAL_PIVOT,
            source_target=from_target,
            destination_target=to_target,
            steps=[
                {
                    "action": "lateral_move",
                    "from": from_target,
                    "to": to_target,
                    "cred_id": best_cred.get("id"),
                    "method": "pass_the_hash" if best_cred.get("type") == "hash" else "ssh",
                    "description": f"Lateral movement from {from_target} to {to_target}"
                }
            ],
            success_probability=0.6,
            stealth_score=0.5,  # Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© Ù…Ù„Ø­ÙˆØ¸Ø© Ù†Ø³Ø¨ÙŠØ§Ù‹
            time_estimate_minutes=20,
            risk_level="medium",
            required_credentials=[best_cred.get("id")],
            required_sessions=[from_target],
            reasoning=f"Pivot from compromised {from_target} to {to_target}"
        )
    
    async def _enhance_paths_with_memory(
        self,
        paths: List[AttackPath]
    ) -> List[AttackPath]:
        """ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ©."""
        if not self._memory:
            return paths
        
        for path in paths:
            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ØªØ¬Ø§Ø±Ø¨ Ù…Ø´Ø§Ø¨Ù‡Ø©
            context = self._path_type_to_context(path.path_type)
            experiences = await self._memory.get_similar_experiences(
                context=context,
                limit=5
            )
            
            if experiences:
                # ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØªØ¬Ø§Ø±Ø¨
                successes = sum(1 for e in experiences 
                              if e.outcome.value == "success")
                if len(experiences) >= 3:
                    historical_rate = successes / len(experiences)
                    # Ù…Ø²Ø¬ Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ø§Ù„ØªÙ‚Ø¯ÙŠØ±ÙŠØ© Ù…Ø¹ Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ©
                    path.success_probability = (
                        path.success_probability * 0.4 +
                        historical_rate * 0.6
                    )
        
        return paths
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø§Øª
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _vuln_matches_service(self, vuln: Dict, service: Dict) -> bool:
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ø«ØºØ±Ø© Ù…Ø¹ Ø§Ù„Ø®Ø¯Ù…Ø©."""
        vuln_type = vuln.get("type", "").lower()
        service_name = service.get("name", "").lower()
        port = service.get("port")
        
        # ØªØ·Ø§Ø¨Ù‚Ø§Øª Ù…Ø¹Ø±ÙˆÙØ©
        matches = {
            "ssh": ["ssh", "openssh", "cve-2018-15473"],
            "smb": ["smb", "ms17-010", "eternalblue", "cve-2017-0144"],
            "rdp": ["rdp", "bluekeep", "cve-2019-0708"],
            "http": ["http", "web", "log4j", "cve-2021-44228"]
        }
        
        for svc, patterns in matches.items():
            if service_name == svc or (port and str(port) in ["22", "445", "3389", "80", "443"]):
                for pattern in patterns:
                    if pattern in vuln_type:
                        return True
        
        return False
    
    def _determine_attack_vectors(
        self,
        service: Dict,
        vulns: List[Dict]
    ) -> List[str]:
        """ØªØ­Ø¯ÙŠØ¯ Ù†Ø§Ù‚Ù„Ø§Øª Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ù…ØªØ§Ø­Ø©."""
        vectors = []
        service_name = service.get("name", "").lower()
        
        # Ù†Ø§Ù‚Ù„Ø§Øª Ù…Ø¨Ù†ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø¯Ù…Ø©
        service_vectors = {
            "ssh": ["brute_force", "key_auth", "exploit"],
            "smb": ["pass_the_hash", "exploit", "share_enum"],
            "rdp": ["brute_force", "exploit", "rdp_relay"],
            "http": ["web_exploit", "injection", "auth_bypass"],
            "https": ["web_exploit", "injection", "ssl_stripping"]
        }
        
        if service_name in service_vectors:
            vectors.extend(service_vectors[service_name])
        
        # Ù†Ø§Ù‚Ù„Ø§Øª Ù…Ø¨Ù†ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø«ØºØ±Ø§Øª
        for vuln in vulns:
            severity = vuln.get("severity", "").lower()
            if severity in ("critical", "high"):
                if "rce" in vuln.get("type", "").lower():
                    vectors.append("remote_code_execution")
                elif "auth" in vuln.get("type", "").lower():
                    vectors.append("auth_bypass")
        
        return list(set(vectors))
    
    def _estimate_exploit_probability(
        self,
        vuln: Dict,
        module: Optional[Dict]
    ) -> float:
        """ØªÙ‚Ø¯ÙŠØ± Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ù†Ø¬Ø§Ø­ Ø§Ù„Ø§Ø³ØªØºÙ„Ø§Ù„."""
        base = 0.4
        
        # ØªØ¹Ø¯ÙŠÙ„ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø·ÙˆØ±Ø©
        severity = vuln.get("severity", "medium").lower()
        severity_boost = {"critical": 0.2, "high": 0.15, "medium": 0.1, "low": 0.05}
        base += severity_boost.get(severity, 0)
        
        # ØªØ¹Ø¯ÙŠÙ„ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆØ¯ÙŠÙˆÙ„
        if module:
            reliability = module.get("reliability", "medium")
            if reliability == "high":
                base += 0.2
            elif reliability == "medium":
                base += 0.1
        
        return min(base, 0.95)
    
    def _estimate_stealth_score(self, vuln: Dict, method: str) -> float:
        """ØªÙ‚Ø¯ÙŠØ± Ø¯Ø±Ø¬Ø© Ø§Ù„ØªØ®ÙÙŠ."""
        scores = {
            "credential": 0.9,
            "direct": 0.5,
            "chain": 0.6,
            "lateral": 0.4
        }
        return scores.get(method, 0.5)
    
    def _categorize_actions(
        self,
        paths: List[AttackPath],
        strategic_value: str
    ) -> Tuple[List[Dict], List[Dict]]:
        """ØªØµÙ†ÙŠÙ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø¥Ù„Ù‰ ÙÙˆØ±ÙŠØ© ÙˆÙ…Ø¤Ø¬Ù„Ø©."""
        immediate = []
        deferred = []
        
        for path in paths[:5]:  # Ø£ÙØ¶Ù„ 5 Ù…Ø³Ø§Ø±Ø§Øª
            action = {
                "path_id": str(path.id),
                "type": path.path_type.value,
                "probability": path.success_probability,
                "first_step": path.steps[0] if path.steps else None
            }
            
            # ÙÙˆØ±ÙŠØ©: Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ø¹Ø§Ù„ÙŠØ© Ø£Ùˆ Ù‚ÙŠÙ…Ø© Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø­Ø±Ø¬Ø©
            if path.success_probability > 0.6 or strategic_value == "critical":
                immediate.append(action)
            else:
                deferred.append(action)
        
        return immediate, deferred
    
    def _generate_coordination_notes(
        self,
        target_id: str,
        paths: List[AttackPath],
        attack_surface: List[Dict]
    ) -> List[str]:
        """ØªÙˆÙ„ÙŠØ¯ Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„ØªÙ†Ø³ÙŠÙ‚."""
        notes = []
        
        # Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø­ÙˆÙ„ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ§Øª
        if paths:
            best_path = paths[0]
            notes.append(
                f"Priority: {best_path.path_type.value} with "
                f"{best_path.success_probability:.0%} success probability"
            )
        
        # Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø­ÙˆÙ„ Ø³Ø·Ø­ Ø§Ù„Ù‡Ø¬ÙˆÙ…
        critical_services = [
            s for s in attack_surface 
            if s.get("exposure_level") == "high" and s.get("related_vulns")
        ]
        if critical_services:
            notes.append(
                f"Critical exposure: {len(critical_services)} high-exposure "
                f"services with known vulnerabilities"
            )
        
        return notes
    
    def _path_to_dict(self, path: AttackPath) -> Dict:
        """ØªØ­ÙˆÙŠÙ„ Ù…Ø³Ø§Ø± Ø¥Ù„Ù‰ Ù‚Ø§Ù…ÙˆØ³."""
        return {
            "id": str(path.id),
            "type": path.path_type.value,
            "source": path.source_target,
            "destination": path.destination_target,
            "steps": path.steps,
            "success_probability": path.success_probability,
            "stealth_score": path.stealth_score,
            "time_estimate_minutes": path.time_estimate_minutes,
            "risk_level": path.risk_level,
            "reasoning": path.reasoning
        }
    
    def _path_type_to_context(self, path_type: AttackPathType):
        """ØªØ­ÙˆÙŠÙ„ Ù†ÙˆØ¹ Ø§Ù„Ù…Ø³Ø§Ø± Ø¥Ù„Ù‰ Ø³ÙŠØ§Ù‚ Ù„Ù„Ø°Ø§ÙƒØ±Ø©."""
        from .operational_memory import OperationalContext
        
        mapping = {
            AttackPathType.DIRECT_EXPLOIT: OperationalContext.EXPLOIT,
            AttackPathType.CREDENTIAL_BASED: OperationalContext.EXPLOIT,
            AttackPathType.CHAIN_EXPLOIT: OperationalContext.EXPLOIT,
            AttackPathType.LATERAL_PIVOT: OperationalContext.LATERAL,
            AttackPathType.PRIVILEGE_CHAIN: OperationalContext.PRIVESC
        }
        return mapping.get(path_type, OperationalContext.EXPLOIT)
    
    async def _store_analysis(
        self,
        mission_id: str,
        target_id: str,
        analysis: Dict
    ) -> None:
        """ØªØ®Ø²ÙŠÙ† Ø§Ù„ØªØ­Ù„ÙŠÙ„ ÙÙŠ Blackboard."""
        if self._blackboard:
            await self._blackboard.log_result(
                mission_id,
                "strategic_analysis",
                {
                    "target_id": target_id,
                    "analysis": analysis
                }
            )
```

---

## ğŸ“Š Ø§Ù„Ù…ÙƒÙˆÙ† 3: Strategic Vulnerability Scorer (Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ)

### Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø­Ø§Ù„ÙŠ ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ CVSS ÙÙ‚Ø·ØŒ ÙˆÙ‡Ø°Ø§ ØºÙŠØ± ÙƒØ§ÙÙ:
- CVSS Ù„Ø§ ÙŠØ£Ø®Ø° Ø£Ù‡Ù…ÙŠØ© Ø§Ù„Ø£ØµÙ„ ÙÙŠ Ø§Ù„Ø§Ø¹ØªØ¨Ø§Ø±
- Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±Ø¨Ø· Ø¨Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ù‡Ø¬ÙˆÙ…
- Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªÙ‚ÙŠÙŠÙ… Ù„Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ø§Ù„Ø§Ø®ØªØ±Ø§Ù‚ Ø§Ù„ÙØ¹Ù„ÙŠ

### Ø§Ù„Ø­Ù„ Ø§Ù„Ù…Ù‚ØªØ±Ø­

**Ù…Ù„Ù Ø¬Ø¯ÙŠØ¯: `/src/core/strategic_scorer.py`**

```python
"""
RAGLOX v3.0 - Strategic Vulnerability Scorer
Ù†Ø¸Ø§Ù… ØªÙ‚ÙŠÙŠÙ… Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ Ù„Ù„Ø«ØºØ±Ø§Øª ÙŠØªØ¬Ø§ÙˆØ² CVSS

Ø§Ù„Ù…Ø¨Ø¯Ø£: Ø§Ù„Ø«ØºØ±Ø© Ø§Ù„Ø£Ø®Ø·Ø± Ù„ÙŠØ³Øª Ø¨Ø§Ù„Ø¶Ø±ÙˆØ±Ø© Ø§Ù„Ø£Ø¹Ù„Ù‰ CVSS
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple
from datetime import datetime


class AssetCriticality(Enum):
    """Ø£Ù‡Ù…ÙŠØ© Ø§Ù„Ø£ØµÙ„"""
    CROWN_JEWEL = "crown_jewel"      # Domain Controller, Database Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    HIGH = "high"                     # Ø®ÙˆØ§Ø¯Ù… Ø§Ù„Ø¥Ù†ØªØ§Ø¬
    MEDIUM = "medium"                 # Ø®ÙˆØ§Ø¯Ù… Ø§Ù„ØªØ·ÙˆÙŠØ±
    LOW = "low"                       # Ø£Ø¬Ù‡Ø²Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
    UNKNOWN = "unknown"


class ChainPosition(Enum):
    """Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø«ØºØ±Ø© ÙÙŠ Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ù‡Ø¬ÙˆÙ…"""
    INITIAL_ACCESS = "initial_access"    # Ù†Ù‚Ø·Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„
    PIVOT_POINT = "pivot_point"          # Ù†Ù‚Ø·Ø© Ù…Ø­ÙˆØ±ÙŠØ©
    PRIVILEGE_GATE = "privilege_gate"    # Ø¨ÙˆØ§Ø¨Ø© ØªØµØ¹ÙŠØ¯
    DATA_ACCESS = "data_access"          # ÙˆØµÙˆÙ„ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    LATERAL_ENABLER = "lateral_enabler"  # ØªÙ…ÙƒÙŠÙ† Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©


@dataclass
class StrategicScore:
    """Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ù„Ù„Ø«ØºØ±Ø©"""
    vuln_id: str
    
    # Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ÙØ±Ø¹ÙŠØ© (0-10)
    cvss_score: float = 5.0
    asset_criticality_score: float = 5.0
    chain_position_score: float = 5.0
    exploit_probability_score: float = 5.0
    stealth_factor_score: float = 5.0
    
    # Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ø§Ù„Ù…Ø±Ø¬Ø­Ø©
    strategic_score: float = 5.0
    
    # Ø§Ù„ØªÙØ§ØµÙŠÙ„
    reasoning: List[str] = field(default_factory=list)
    recommended_priority: int = 5  # 1-10, 10 = Ø§Ù„Ø£Ø¹Ù„Ù‰
    
    # Ø§Ù„Ø³ÙŠØ§Ù‚
    asset_criticality: AssetCriticality = AssetCriticality.UNKNOWN
    chain_position: Optional[ChainPosition] = None
    
    # Ø§Ù„Ø£ÙˆØ²Ø§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø© (Ù„Ù„Ø´ÙØ§ÙÙŠØ©)
    weights_used: Dict[str, float] = field(default_factory=dict)


class StrategicScorer:
    """
    Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ Ù„Ù„Ø«ØºØ±Ø§Øª
    
    ÙŠØ­Ø³Ø¨ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰:
    1. CVSS (Ø§Ù„Ø®Ø·ÙˆØ±Ø© Ø§Ù„ØªÙ‚Ù†ÙŠØ©)
    2. Ø£Ù‡Ù…ÙŠØ© Ø§Ù„Ø£ØµÙ„ (Asset Criticality)
    3. Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø³Ù„Ø³Ù„Ø© (Chain Position)
    4. Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ø§Ù„Ø§Ø³ØªØºÙ„Ø§Ù„ Ø§Ù„ÙØ¹Ù„ÙŠ
    5. Ø¹Ø§Ù…Ù„ Ø§Ù„ØªØ®ÙÙŠ (Ù„Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©)
    """
    
    # Ø§Ù„Ø£ÙˆØ²Ø§Ù† Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
    DEFAULT_WEIGHTS = {
        "cvss": 0.25,
        "asset_criticality": 0.25,
        "chain_position": 0.20,
        "exploit_probability": 0.20,
        "stealth_factor": 0.10
    }
    
    # Ø£ÙˆØ²Ø§Ù† Ù„Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù‡Ø¬ÙˆÙ…ÙŠ (Aggressive)
    AGGRESSIVE_WEIGHTS = {
        "cvss": 0.30,
        "asset_criticality": 0.30,
        "chain_position": 0.20,
        "exploit_probability": 0.15,
        "stealth_factor": 0.05
    }
    
    # Ø£ÙˆØ²Ø§Ù† Ù„Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø®ÙÙŠ (Stealth)
    STEALTH_WEIGHTS = {
        "cvss": 0.15,
        "asset_criticality": 0.20,
        "chain_position": 0.20,
        "exploit_probability": 0.20,
        "stealth_factor": 0.25
    }
    
    def __init__(
        self,
        knowledge_base=None,
        operational_memory=None,
        weights: Optional[Dict[str, float]] = None
    ):
        """
        Args:
            knowledge_base: Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ù…Ø¹Ø±ÙØ© Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ù…ÙˆØ¯ÙŠÙˆÙ„Ø§Øª
            operational_memory: Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ø§Ù„Ù†Ø¬Ø§Ø­
            weights: Ø£ÙˆØ²Ø§Ù† Ù…Ø®ØµØµØ© Ø£Ùˆ None Ù„Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ
        """
        self._knowledge = knowledge_base
        self._memory = operational_memory
        self._weights = weights or self.DEFAULT_WEIGHTS
        
        # ÙƒØ§Ø´ Ù„Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª
        self._score_cache: Dict[str, StrategicScore] = {}
    
    def set_mode(self, mode: str) -> None:
        """ØªØºÙŠÙŠØ± ÙˆØ¶Ø¹ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…."""
        if mode == "aggressive":
            self._weights = self.AGGRESSIVE_WEIGHTS
        elif mode == "stealth":
            self._weights = self.STEALTH_WEIGHTS
        else:
            self._weights = self.DEFAULT_WEIGHTS
    
    async def score_vulnerability(
        self,
        vuln: Dict[str, Any],
        target: Dict[str, Any],
        mission_context: Optional[Dict] = None
    ) -> StrategicScore:
        """
        Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ù„Ø«ØºØ±Ø©.
        
        Args:
            vuln: Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø«ØºØ±Ø©
            target: Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‡Ø¯Ù
            mission_context: Ø³ÙŠØ§Ù‚ Ø§Ù„Ù…Ù‡Ù…Ø© (Ø£Ù‡Ø¯Ø§ÙØŒ Ù‚ÙŠÙˆØ¯)
            
        Returns:
            StrategicScore Ù…Ø¹ ÙƒÙ„ Ø§Ù„ØªÙØ§ØµÙŠÙ„
        """
        vuln_id = vuln.get("id", "unknown")
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙƒØ§Ø´
        cache_key = f"{vuln_id}:{target.get('id', '')}"
        if cache_key in self._score_cache:
            return self._score_cache[cache_key]
        
        result = StrategicScore(vuln_id=vuln_id)
        reasoning = []
        
        # 1. Ù†ØªÙŠØ¬Ø© CVSS
        cvss = self._calculate_cvss_score(vuln)
        result.cvss_score = cvss
        reasoning.append(f"CVSS: {cvss:.1f}/10")
        
        # 2. Ø£Ù‡Ù…ÙŠØ© Ø§Ù„Ø£ØµÙ„
        asset_score, criticality = self._calculate_asset_criticality(target)
        result.asset_criticality_score = asset_score
        result.asset_criticality = criticality
        reasoning.append(f"Asset Criticality: {criticality.value} ({asset_score:.1f}/10)")
        
        # 3. Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø³Ù„Ø³Ù„Ø©
        chain_score, position = await self._calculate_chain_position(vuln, target, mission_context)
        result.chain_position_score = chain_score
        result.chain_position = position
        if position:
            reasoning.append(f"Chain Position: {position.value} ({chain_score:.1f}/10)")
        
        # 4. Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ø§Ù„Ø§Ø³ØªØºÙ„Ø§Ù„
        exploit_score = await self._calculate_exploit_probability(vuln, target)
        result.exploit_probability_score = exploit_score
        reasoning.append(f"Exploit Probability: {exploit_score:.1f}/10")
        
        # 5. Ø¹Ø§Ù…Ù„ Ø§Ù„ØªØ®ÙÙŠ
        stealth_score = self._calculate_stealth_factor(vuln)
        result.stealth_factor_score = stealth_score
        reasoning.append(f"Stealth Factor: {stealth_score:.1f}/10")
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
        strategic_score = (
            cvss * self._weights["cvss"] +
            asset_score * self._weights["asset_criticality"] +
            chain_score * self._weights["chain_position"] +
            exploit_score * self._weights["exploit_probability"] +
            stealth_score * self._weights["stealth_factor"]
        )
        
        result.strategic_score = round(strategic_score, 2)
        result.reasoning = reasoning
        result.recommended_priority = self._calculate_priority(strategic_score)
        result.weights_used = self._weights.copy()
        
        # Ø­ÙØ¸ ÙÙŠ Ø§Ù„ÙƒØ§Ø´
        self._score_cache[cache_key] = result
        
        return result
    
    async def rank_vulnerabilities(
        self,
        vulnerabilities: List[Dict],
        target: Dict[str, Any],
        mission_context: Optional[Dict] = None,
        limit: int = 10
    ) -> List[Tuple[Dict, StrategicScore]]:
        """
        ØªØ±ØªÙŠØ¨ Ù‚Ø§Ø¦Ù…Ø© Ø«ØºØ±Ø§Øª Ø¨Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©.
        
        Args:
            vulnerabilities: Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø«ØºØ±Ø§Øª
            target: Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‡Ø¯Ù
            mission_context: Ø³ÙŠØ§Ù‚ Ø§Ù„Ù…Ù‡Ù…Ø©
            limit: Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ù†ØªØ§Ø¦Ø¬
            
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ù…Ù† (Ø«ØºØ±Ø©, Ù†ØªÙŠØ¬Ø©) Ù…Ø±ØªØ¨Ø© Ø¨Ø§Ù„Ø£ÙØ¶Ù„ÙŠØ©
        """
        scored = []
        
        for vuln in vulnerabilities:
            score = await self.score_vulnerability(vuln, target, mission_context)
            scored.append((vuln, score))
        
        # ØªØ±ØªÙŠØ¨ Ø¨Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©
        scored.sort(key=lambda x: x[1].strategic_score, reverse=True)
        
        return scored[:limit]
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ÙØ±Ø¹ÙŠØ©
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _calculate_cvss_score(self, vuln: Dict) -> float:
        """Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø£Ùˆ Ø­Ø³Ø§Ø¨ Ù†ØªÙŠØ¬Ø© CVSS."""
        # Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø±Ø§Ø¬ CVSS Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯
        cvss = vuln.get("cvss", vuln.get("cvss_score"))
        if cvss is not None:
            return float(cvss)
        
        # ØªÙ‚Ø¯ÙŠØ± Ù…Ù† Ø§Ù„Ø®Ø·ÙˆØ±Ø©
        severity = vuln.get("severity", "medium").lower()
        severity_map = {
            "critical": 9.5,
            "high": 7.5,
            "medium": 5.5,
            "low": 3.5,
            "info": 1.0
        }
        return severity_map.get(severity, 5.0)
    
    def _calculate_asset_criticality(
        self,
        target: Dict
    ) -> Tuple[float, AssetCriticality]:
        """Ø­Ø³Ø§Ø¨ Ø£Ù‡Ù…ÙŠØ© Ø§Ù„Ø£ØµÙ„."""
        # Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø£Ù‡Ù…ÙŠØ©
        indicators = {
            "crown_jewel": [
                "domain controller", "dc", "ad", "active directory",
                "database", "sql", "oracle", "mongodb",
                "backup", "pki", "ca", "certificate"
            ],
            "high": [
                "server", "production", "prod", "web", "api",
                "mail", "exchange", "file server"
            ],
            "medium": [
                "dev", "development", "staging", "test", "qa"
            ],
            "low": [
                "workstation", "desktop", "laptop", "endpoint"
            ]
        }
        
        # Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‡Ø¯Ù
        target_str = " ".join([
            str(target.get("hostname", "")),
            str(target.get("os", "")),
            str(target.get("services", "")),
            str(target.get("tags", ""))
        ]).lower()
        
        for level, keywords in indicators.items():
            for keyword in keywords:
                if keyword in target_str:
                    criticality = AssetCriticality(level)
                    score = {
                        "crown_jewel": 10.0,
                        "high": 8.0,
                        "medium": 5.0,
                        "low": 3.0
                    }[level]
                    return score, criticality
        
        return 5.0, AssetCriticality.UNKNOWN
    
    async def _calculate_chain_position(
        self,
        vuln: Dict,
        target: Dict,
        mission_context: Optional[Dict]
    ) -> Tuple[float, Optional[ChainPosition]]:
        """Ø­Ø³Ø§Ø¨ Ù‚ÙŠÙ…Ø© Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø«ØºØ±Ø© ÙÙŠ Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ù‡Ø¬ÙˆÙ…."""
        vuln_type = vuln.get("type", "").lower()
        services = target.get("services", [])
        
        # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹
        position = None
        score = 5.0
        
        # Ù†Ù‚Ø·Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„
        if any(s in vuln_type for s in ["rce", "remote", "initial", "external"]):
            position = ChainPosition.INITIAL_ACCESS
            score = 9.0
        
        # Ø¨ÙˆØ§Ø¨Ø© Ø§Ù„ØªØµØ¹ÙŠØ¯
        elif any(s in vuln_type for s in ["privesc", "elevation", "root", "admin", "system"]):
            position = ChainPosition.PRIVILEGE_GATE
            score = 8.5
        
        # Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        elif any(s in vuln_type for s in ["sql", "database", "exfil", "data", "leak"]):
            position = ChainPosition.DATA_ACCESS
            score = 8.0
        
        # ØªÙ…ÙƒÙŠÙ† Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©
        elif any(s in vuln_type for s in ["smb", "rdp", "ssh", "psexec", "wmi"]):
            position = ChainPosition.LATERAL_ENABLER
            score = 7.5
        
        # Ù†Ù‚Ø·Ø© Ù…Ø­ÙˆØ±ÙŠØ©
        elif any(s in str(services) for s in ["ldap", "kerberos", "ad"]):
            position = ChainPosition.PIVOT_POINT
            score = 8.0
        
        # ØªØ¹Ø¯ÙŠÙ„ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ù…Ù‡Ù…Ø©
        if mission_context:
            goals = mission_context.get("goals", [])
            if "domain_admin" in goals and position == ChainPosition.PRIVILEGE_GATE:
                score += 1.0
            elif "data_exfil" in goals and position == ChainPosition.DATA_ACCESS:
                score += 1.0
        
        return min(score, 10.0), position
    
    async def _calculate_exploit_probability(
        self,
        vuln: Dict,
        target: Dict
    ) -> float:
        """Ø­Ø³Ø§Ø¨ Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ø§Ù„Ø§Ø³ØªØºÙ„Ø§Ù„ Ø§Ù„ÙØ¹Ù„ÙŠ."""
        base = 5.0
        
        # Ø¹ÙˆØ§Ù…Ù„ Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ©
        if vuln.get("exploit_available"):
            base += 2.0
        
        if vuln.get("metasploit_module"):
            base += 1.5
        
        if vuln.get("nuclei_template"):
            base += 1.0
        
        # Ø¹Ù…Ø± Ø§Ù„Ø«ØºØ±Ø© (Ø£Ù‚Ø¯Ù… = Ø£ÙƒØ«Ø± Ø§Ø³ØªÙ‚Ø±Ø§Ø±Ø§Ù‹)
        vuln_type = vuln.get("type", "")
        if vuln_type.startswith("CVE-"):
            try:
                year = int(vuln_type.split("-")[1])
                age = datetime.utcnow().year - year
                if age >= 2:
                    base += 0.5
            except:
                pass
        
        # Ø§Ø³ØªØ´Ø§Ø±Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø©
        if self._memory:
            from .operational_memory import OperationalContext
            rate, count = await self._memory.get_success_rate_for_context(
                context=OperationalContext.EXPLOIT,
                vuln_type=vuln_type
            )
            if count >= 3:
                base = (base + rate * 10) / 2
        
        # Ø¹ÙˆØ§Ù…Ù„ Ø³Ù„Ø¨ÙŠØ©
        target_os = target.get("os", "").lower()
        if "hardened" in target_os or "secure" in target_os:
            base -= 1.0
        
        return min(max(base, 0), 10.0)
    
    def _calculate_stealth_factor(self, vuln: Dict) -> float:
        """Ø­Ø³Ø§Ø¨ Ø¹Ø§Ù…Ù„ Ø§Ù„ØªØ®ÙÙŠ."""
        score = 5.0
        vuln_type = vuln.get("type", "").lower()
        
        # Ø«ØºØ±Ø§Øª ØµØ§Ø®Ø¨Ø©
        noisy_patterns = [
            "bruteforce", "spray", "scan", "flood",
            "dos", "ddos", "crash"
        ]
        for pattern in noisy_patterns:
            if pattern in vuln_type:
                score -= 2.0
        
        # Ø«ØºØ±Ø§Øª Ù‡Ø§Ø¯Ø¦Ø©
        quiet_patterns = [
            "auth_bypass", "credential", "token",
            "session", "cookie", "jwt"
        ]
        for pattern in quiet_patterns:
            if pattern in vuln_type:
                score += 1.5
        
        # Living off the land
        if vuln.get("lolbins_compatible"):
            score += 1.0
        
        return min(max(score, 0), 10.0)
    
    def _calculate_priority(self, strategic_score: float) -> int:
        """ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø¥Ù„Ù‰ Ø£ÙˆÙ„ÙˆÙŠØ©."""
        if strategic_score >= 9:
            return 10
        elif strategic_score >= 8:
            return 9
        elif strategic_score >= 7:
            return 8
        elif strategic_score >= 6:
            return 7
        elif strategic_score >= 5:
            return 6
        elif strategic_score >= 4:
            return 5
        elif strategic_score >= 3:
            return 4
        else:
            return 3
```

---

## ğŸ¥· Ø§Ù„Ù…ÙƒÙˆÙ† 4: Stealth Profiles (Ù…Ù„ÙØ§Øª Ø§Ù„ØªØ®ÙÙŠ)

### Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªØ­ÙƒÙ… ÙÙŠ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¶Ø¬ÙŠØ¬/Ø§Ù„ØªØ®ÙÙŠ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª.

### Ø§Ù„Ø­Ù„ Ø§Ù„Ù…Ù‚ØªØ±Ø­

**Ù…Ù„Ù Ø¬Ø¯ÙŠØ¯: `/src/core/stealth_profiles.py`**

```python
"""
RAGLOX v3.0 - Stealth Profiles
Ù…Ù„ÙØ§Øª ØªØ¹Ø±ÙŠÙ Ø§Ù„ØªØ®ÙÙŠ Ù„Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©

Ø§Ù„Ù…Ø¨Ø¯Ø£: Red Team Ø§Ù„Ù…Ø­ØªØ±Ù ÙŠØªØµØ±Ù ÙƒÙ€ APTØŒ Ù„Ø§ ÙƒÙ€ Script Kiddie
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Any
import random


class StealthLevel(Enum):
    """Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„ØªØ®ÙÙŠ"""
    SILENT = "silent"           # ØµØ§Ù…Øª ØªÙ…Ø§Ù…Ø§Ù‹ - Ø¹Ù…Ù„ÙŠØ§Øª APT
    QUIET = "quiet"             # Ù‡Ø§Ø¯Ø¦ - Ø¹Ù…Ù„ÙŠØ§Øª Ù…Ø³ØªÙ‡Ø¯ÙØ©
    NORMAL = "normal"           # Ø¹Ø§Ø¯ÙŠ - ØªÙˆØ§Ø²Ù†
    AGGRESSIVE = "aggressive"   # Ø¹Ø¯ÙˆØ§Ù†ÙŠ - Ø³Ø±Ø¹Ø© Ø¹Ù„Ù‰ Ø§Ù„ØªØ®ÙÙŠ
    NOISY = "noisy"            # ØµØ§Ø®Ø¨ - Ø§Ø®ØªØ¨Ø§Ø± ÙÙ‚Ø·


@dataclass
class StealthProfile:
    """Ù…Ù„Ù ØªØ¹Ø±ÙŠÙ Ø§Ù„ØªØ®ÙÙŠ"""
    name: str
    level: StealthLevel
    
    # Ø§Ù„ØªÙˆÙ‚ÙŠØª
    min_delay_seconds: float = 1.0
    max_delay_seconds: float = 5.0
    jitter_percent: float = 0.2       # ØªØ°Ø¨Ø°Ø¨ Ø¹Ø´ÙˆØ§Ø¦ÙŠ
    
    # Ù…Ø¹Ø¯Ù„Ø§Øª Ø§Ù„Ø·Ù„Ø¨Ø§Øª
    max_requests_per_minute: int = 10
    max_connections_per_target: int = 3
    
    # Ø§Ù„Ø³Ù„ÙˆÙƒ
    use_evasion: bool = True
    encode_payloads: bool = True
    randomize_user_agent: bool = True
    avoid_signatures: bool = True
    
    # Ø£ÙˆÙ‚Ø§Øª Ø§Ù„Ù†Ø´Ø§Ø· (Ù„Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©)
    work_hours_only: bool = False     # ÙÙ‚Ø· Ø³Ø§Ø¹Ø§Øª Ø§Ù„Ø¹Ù…Ù„
    avoid_peak_hours: bool = True     # ØªØ¬Ù†Ø¨ Ø£ÙˆÙ‚Ø§Øª Ø§Ù„Ø°Ø±ÙˆØ©
    
    # Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…Ø³Ù…ÙˆØ­Ø©
    allowed_techniques: List[str] = field(default_factory=list)
    blocked_techniques: List[str] = field(default_factory=list)
    
    # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    log_all_actions: bool = True
    mask_ips: bool = False


class StealthManager:
    """
    Ù…Ø¯ÙŠØ± Ø§Ù„ØªØ®ÙÙŠ - ÙŠØªØ­ÙƒÙ… ÙÙŠ Ø³Ù„ÙˆÙƒ Ø§Ù„Ù†Ø¸Ø§Ù… Ø­Ø³Ø¨ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ
    """
    
    # Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ù…Ø¶Ù…Ù†Ø©
    BUILTIN_PROFILES = {
        "apt_simulation": StealthProfile(
            name="apt_simulation",
            level=StealthLevel.SILENT,
            min_delay_seconds=30.0,
            max_delay_seconds=300.0,
            jitter_percent=0.5,
            max_requests_per_minute=2,
            max_connections_per_target=1,
            use_evasion=True,
            encode_payloads=True,
            randomize_user_agent=True,
            avoid_signatures=True,
            work_hours_only=True,
            avoid_peak_hours=True,
            blocked_techniques=[
                "bruteforce", "spray", "scan_all_ports",
                "loud_exploit", "ddos"
            ]
        ),
        
        "red_team_standard": StealthProfile(
            name="red_team_standard",
            level=StealthLevel.QUIET,
            min_delay_seconds=5.0,
            max_delay_seconds=30.0,
            jitter_percent=0.3,
            max_requests_per_minute=5,
            max_connections_per_target=2,
            use_evasion=True,
            encode_payloads=True,
            randomize_user_agent=True,
            avoid_signatures=True,
            work_hours_only=False,
            avoid_peak_hours=True
        ),
        
        "pentest_normal": StealthProfile(
            name="pentest_normal",
            level=StealthLevel.NORMAL,
            min_delay_seconds=1.0,
            max_delay_seconds=10.0,
            jitter_percent=0.2,
            max_requests_per_minute=15,
            max_connections_per_target=5,
            use_evasion=True,
            encode_payloads=False,
            randomize_user_agent=True,
            avoid_signatures=False
        ),
        
        "vulnerability_assessment": StealthProfile(
            name="vulnerability_assessment",
            level=StealthLevel.AGGRESSIVE,
            min_delay_seconds=0.1,
            max_delay_seconds=1.0,
            jitter_percent=0.1,
            max_requests_per_minute=60,
            max_connections_per_target=10,
            use_evasion=False,
            encode_payloads=False,
            randomize_user_agent=False,
            avoid_signatures=False
        ),
        
        "testing_only": StealthProfile(
            name="testing_only",
            level=StealthLevel.NOISY,
            min_delay_seconds=0.0,
            max_delay_seconds=0.1,
            jitter_percent=0.0,
            max_requests_per_minute=1000,
            max_connections_per_target=50,
            use_evasion=False,
            encode_payloads=False,
            randomize_user_agent=False,
            avoid_signatures=False
        )
    }
    
    def __init__(self, profile_name: str = "pentest_normal"):
        """
        Args:
            profile_name: Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ
        """
        self._profile = self.BUILTIN_PROFILES.get(
            profile_name,
            self.BUILTIN_PROFILES["pentest_normal"]
        )
        self._request_counts: Dict[str, int] = {}
        self._last_request_times: Dict[str, float] = {}
    
    @property
    def profile(self) -> StealthProfile:
        return self._profile
    
    def set_profile(self, profile_name: str) -> None:
        """ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ."""
        if profile_name in self.BUILTIN_PROFILES:
            self._profile = self.BUILTIN_PROFILES[profile_name]
        else:
            raise ValueError(f"Unknown profile: {profile_name}")
    
    def set_custom_profile(self, profile: StealthProfile) -> None:
        """ØªØ¹ÙŠÙŠÙ† Ù…Ù„Ù Ø´Ø®ØµÙŠ Ù…Ø®ØµØµ."""
        self._profile = profile
    
    def get_delay(self) -> float:
        """
        Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªØ£Ø®ÙŠØ± Ø§Ù„ØªØ§Ù„ÙŠ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ.
        
        Returns:
            Ø§Ù„ØªØ£Ø®ÙŠØ± Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ Ù…Ø¹ jitter
        """
        base_delay = random.uniform(
            self._profile.min_delay_seconds,
            self._profile.max_delay_seconds
        )
        
        # Ø¥Ø¶Ø§ÙØ© jitter
        jitter = base_delay * self._profile.jitter_percent
        actual_delay = base_delay + random.uniform(-jitter, jitter)
        
        return max(0, actual_delay)
    
    def can_make_request(self, target: str) -> bool:
        """
        Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯.
        
        Args:
            target: Ø§Ù„Ù‡Ø¯Ù
            
        Returns:
            True Ø¥Ø°Ø§ Ù…Ø³Ù…ÙˆØ­
        """
        import time
        current_minute = int(time.time() / 60)
        key = f"{target}:{current_minute}"
        
        count = self._request_counts.get(key, 0)
        return count < self._profile.max_requests_per_minute
    
    def record_request(self, target: str) -> None:
        """ØªØ³Ø¬ÙŠÙ„ Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯."""
        import time
        current_minute = int(time.time() / 60)
        key = f"{target}:{current_minute}"
        
        self._request_counts[key] = self._request_counts.get(key, 0) + 1
        self._last_request_times[target] = time.time()
    
    def is_technique_allowed(self, technique: str) -> bool:
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨ØªÙ‚Ù†ÙŠØ© Ù…Ø¹ÙŠÙ†Ø©."""
        if technique in self._profile.blocked_techniques:
            return False
        
        if self._profile.allowed_techniques:
            return technique in self._profile.allowed_techniques
        
        return True
    
    def should_use_evasion(self) -> bool:
        """Ù‡Ù„ ÙŠØ¬Ø¨ Ø§Ø³ØªØ®Ø¯Ø§Ù… ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„ØªØ¬Ù†Ø¨ØŸ"""
        return self._profile.use_evasion
    
    def should_encode_payload(self) -> bool:
        """Ù‡Ù„ ÙŠØ¬Ø¨ ØªØ±Ù…ÙŠØ² Ø§Ù„Ø­Ù…ÙˆÙ„Ø©ØŸ"""
        return self._profile.encode_payloads
    
    def get_user_agent(self) -> str:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ User-Agent."""
        if not self._profile.randomize_user_agent:
            return "RAGLOX/3.0"
        
        agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101",
        ]
        return random.choice(agents)
    
    def is_good_time_to_operate(self) -> bool:
        """Ù‡Ù„ Ù‡Ø°Ø§ ÙˆÙ‚Øª Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ø¹Ù…Ù„ØŸ"""
        from datetime import datetime
        now = datetime.now()
        hour = now.hour
        
        if self._profile.work_hours_only:
            # Ø³Ø§Ø¹Ø§Øª Ø§Ù„Ø¹Ù…Ù„: 9-18
            if hour < 9 or hour >= 18:
                return False
        
        if self._profile.avoid_peak_hours:
            # ØªØ¬Ù†Ø¨ Ø£ÙˆÙ‚Ø§Øª Ø§Ù„Ø°Ø±ÙˆØ©: 9-10 Ùˆ 14-15
            if hour in [9, 10, 14, 15]:
                return False
        
        return True
    
    def get_execution_context(self) -> Dict[str, Any]:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø³ÙŠØ§Ù‚ Ø§Ù„ØªÙ†ÙÙŠØ° Ù„Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ø£Ø®Ø±Ù‰."""
        return {
            "profile_name": self._profile.name,
            "stealth_level": self._profile.level.value,
            "use_evasion": self._profile.use_evasion,
            "encode_payloads": self._profile.encode_payloads,
            "avoid_signatures": self._profile.avoid_signatures,
            "max_requests_per_minute": self._profile.max_requests_per_minute,
            "delay_range": (self._profile.min_delay_seconds, self._profile.max_delay_seconds)
        }
```

---

## ğŸ”§ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©

### ØªØ¹Ø¯ÙŠÙ„Ø§Øª AnalysisSpecialist

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 1: Ù‚Ø±Ø§Ø¡Ø© _analysis_history ÙÙŠ Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# ÙÙŠ analysis.pyØŒ ØªØ¹Ø¯ÙŠÙ„ _make_decision

async def _make_decision(self, ...):
    """
    Ø§ØªØ®Ø§Ø° Ø§Ù„Ù‚Ø±Ø§Ø± Ù…Ø¹ Ø§Ù„Ø§Ø³ØªÙØ§Ø¯Ø© Ù…Ù† Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØ­Ù„ÙŠÙ„ÙŠ.
    
    Ø§Ù„ØªØºÙŠÙŠØ±: Ø§Ù„Ø¢Ù† Ù†Ù‚Ø±Ø£ _analysis_history Ù‚Ø¨Ù„ Ø§ØªØ®Ø§Ø° Ø§Ù„Ù‚Ø±Ø§Ø±!
    """
    # Ø¬Ø¯ÙŠØ¯: Ø§Ø³ØªØ´Ø§Ø±Ø© Ø§Ù„ØªØ§Ø±ÙŠØ® Ø£ÙˆÙ„Ø§Ù‹
    historical_insight = self._get_historical_insight(
        category=category,
        vuln_type=context.get("vuln_info", {}).get("type"),
        target_os=self._get_target_platform(context["target_info"])
    )
    
    if historical_insight and historical_insight["confidence"] == "high":
        self.logger.info(f"[HISTORY] Using learned pattern: {historical_insight['recommendation']}")
        # ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªÙˆØµÙŠØ© Ù…Ù† Ø§Ù„ØªØ§Ø±ÙŠØ®
        return self._apply_historical_insight(historical_insight, context, strategy)
    
    # Ø¨Ø§Ù‚ÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ...
    # ...

def _get_historical_insight(
    self,
    category: str,
    vuln_type: Optional[str],
    target_os: Optional[str]
) -> Optional[Dict]:
    """
    Ø§Ø³ØªØ®Ù„Ø§Øµ Ø±Ø¤Ù‰ Ù…Ù† Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØ­Ù„ÙŠÙ„ÙŠ.
    
    Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ØªÙ‚Ø±Ø£ Ù…Ù† _analysis_history!
    """
    if len(self._analysis_history) < 3:
        return None  # Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ÙƒØ§ÙÙŠØ©
    
    # ÙÙ„ØªØ±Ø© Ø§Ù„ØªØ¬Ø§Ø±Ø¨ Ø§Ù„Ù…Ø´Ø§Ø¨Ù‡Ø©
    similar = [
        record for record in self._analysis_history[-50:]  # Ø¢Ø®Ø± 50 ØªØ¬Ø±Ø¨Ø©
        if record.get("category") == category
    ]
    
    if vuln_type:
        similar = [r for r in similar if r.get("vuln_type") == vuln_type] or similar
    
    if len(similar) < 3:
        return None
    
    # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø·
    decisions = [r.get("decision") for r in similar]
    most_common = max(set(decisions), key=decisions.count)
    frequency = decisions.count(most_common) / len(decisions)
    
    if frequency >= 0.6:  # 60%+ ØªÙƒØ±Ø§Ø±
        return {
            "confidence": "high" if frequency >= 0.8 else "medium",
            "recommendation": most_common,
            "frequency": frequency,
            "sample_size": len(similar),
            "reasoning": f"Historical pattern: {most_common} worked in {frequency:.0%} of similar cases"
        }
    
    return None

def _apply_historical_insight(
    self,
    insight: Dict,
    context: Dict,
    strategy: Dict
) -> Dict:
    """ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø¤ÙŠØ© Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ© ÙƒÙ‚Ø±Ø§Ø±."""
    decision_type = insight["recommendation"]
    
    base_decision = {
        "decision": decision_type,
        "reasoning": insight["reasoning"],
        "recommendations": strategy["recommendations"],
        "decision_source": "historical_learning",
        "confidence": insight["confidence"],
        "sample_size": insight["sample_size"]
    }
    
    # Ø¥Ø¶Ø§ÙØ© ØªÙØ§ØµÙŠÙ„ Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ù‚Ø±Ø§Ø±
    if decision_type == "modify_approach" and context.get("alternative_modules"):
        base_decision["new_module"] = context["alternative_modules"][0].get("rx_module_id")
        self._stats["modifications_recommended"] += 1
    elif decision_type == "retry":
        base_decision["delay_seconds"] = strategy["retry_delay"]
        self._stats["retries_recommended"] += 1
    elif decision_type == "skip":
        self._stats["skips_recommended"] += 1
    elif decision_type == "escalate":
        self._stats["escalations"] += 1
    
    return base_decision
```

### ØªØ¹Ø¯ÙŠÙ„Ø§Øª ReconSpecialist

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 1: Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ù†Ø§ÙØ° Ø§Ù„Ø«Ø§Ø¨ØªØ© ÙˆØ§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡Ø§ Ø¨Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# ÙÙŠ recon.pyØŒ ØªØ¹Ø¯ÙŠÙ„ __init__

def __init__(self, ...):
    # ...
    
    # Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù†:
    # self._common_ports = [21, 22, 23, ...]  # Ø«Ø§Ø¨Øª!
    
    # Ø§Ù„Ø¬Ø¯ÙŠØ¯: Ù…Ù†Ø§ÙØ° Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© Ø­Ø³Ø¨ Ø§Ù„Ø³ÙŠØ§Ù‚
    self._port_profiles = {
        "quick": [22, 80, 443, 445, 3389],
        "standard": [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 993, 995, 1433, 3306, 3389, 5432, 8080],
        "comprehensive": list(range(1, 1025)) + [3306, 3389, 5432, 5900, 6379, 8080, 8443, 9000, 27017],
        "stealth": [22, 80, 443],  # Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„ØªØ®ÙÙŠ
    }
    
    # Ø§Ù„Ù…Ù†Ø§ÙØ° ØªÙØ­Ø¯Ø¯ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ
    self._active_port_profile = "standard"
    
    # Ù…Ø¯ÙŠØ± Ø§Ù„ØªØ®ÙÙŠ (Ø¬Ø¯ÙŠØ¯)
    self._stealth_manager: Optional[StealthManager] = None

@property
def common_ports(self) -> List[int]:
    """Ø§Ù„Ù…Ù†Ø§ÙØ° Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ."""
    return self._port_profiles.get(self._active_port_profile, self._port_profiles["standard"])

def set_stealth_manager(self, manager: StealthManager) -> None:
    """ØªØ¹ÙŠÙŠÙ† Ù…Ø¯ÙŠØ± Ø§Ù„ØªØ®ÙÙŠ ÙˆØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ."""
    self._stealth_manager = manager
    
    # ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ù†Ø§ÙØ° Ø­Ø³Ø¨ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ®ÙÙŠ
    level = manager.profile.level
    if level == StealthLevel.SILENT:
        self._active_port_profile = "stealth"
    elif level == StealthLevel.QUIET:
        self._active_port_profile = "quick"
    elif level == StealthLevel.AGGRESSIVE:
        self._active_port_profile = "comprehensive"
    else:
        self._active_port_profile = "standard"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 2: ØªÙƒØ§Ù…Ù„ Ù…Ø¹ Intelligence Coordinator
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def _execute_service_enum(self, task: Dict[str, Any]) -> Dict[str, Any]:
    """
    ØªØ¹Ø¯Ø§Ø¯ Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ù…Ø¹ Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø°ÙƒÙŠ.
    
    Ø§Ù„ØªØºÙŠÙŠØ±: Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Intelligence Coordinator!
    """
    # ... Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø®Ø¯Ù…Ø§Øª ...
    
    # Ø¬Ø¯ÙŠØ¯: Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ
    if self._intelligence_coordinator:
        strategic_analysis = await self._intelligence_coordinator.process_recon_results(
            mission_id=self._current_mission_id,
            target_id=target_id,
            services=services_found,
            vulnerabilities=await self._get_target_vulns(target_id),
            credentials=await self._get_available_creds(target_id)
        )
        
        # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªØ­Ù„ÙŠÙ„
        self.logger.info(
            f"[STRATEGIC] Target {target_id} value: {strategic_analysis['strategic_value']}, "
            f"Recommended paths: {len(strategic_analysis['recommended_paths'])}"
        )
        
        # Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù†ØªÙŠØ¬Ø©
        result["strategic_analysis"] = strategic_analysis
    
    return result
```

### ØªØ¹Ø¯ÙŠÙ„Ø§Øª AttackSpecialist

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 1: Ø§Ø³ØªØ¨Ø¯Ø§Ù„ random.random() Ø¨Ø¨ÙŠØ§Ù†Ø§Øª ØªØ§Ø±ÙŠØ®ÙŠØ©
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# ÙÙŠ attack.pyØŒ ØªØ¹Ø¯ÙŠÙ„ _simulate_exploit

async def _simulate_exploit(
    self, 
    vuln_type: str, 
    rx_module: Optional[Dict[str, Any]] = None
) -> bool:
    """
    Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø§Ø³ØªØºÙ„Ø§Ù„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¨ÙŠØ§Ù†Ø§Øª ØªØ§Ø±ÙŠØ®ÙŠØ© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©.
    
    Ø§Ù„ØªØºÙŠÙŠØ±: Ù„Ø§ Ù†Ø³ØªØ®Ø¯Ù… random.random() Ù„Ù„Ù‚Ø±Ø§Ø±Ø§Øª Ø§Ù„Ø­Ø§Ø³Ù…Ø©!
    """
    # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ
    success_rate = await self._get_dynamic_exploit_success_rate(vuln_type, rx_module)
    
    # Ø¬Ø¯ÙŠØ¯: Ø§Ø³ØªØ´Ø§Ø±Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ©
    if self._operational_memory:
        from ..core.operational_memory import OperationalContext
        
        memory_rate, sample_count = await self._operational_memory.get_success_rate_for_context(
            context=OperationalContext.EXPLOIT,
            vuln_type=vuln_type
        )
        
        if sample_count >= 5:  # Ø¨ÙŠØ§Ù†Ø§Øª ÙƒØ§ÙÙŠØ©
            # ØªØ±Ø¬ÙŠØ­ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø¹Ù„Ù‰ Ø§Ù„ØªÙ‚Ø¯ÙŠØ±
            success_rate = (success_rate * 0.3) + (memory_rate * 0.7)
            self.logger.info(
                f"[MEMORY] Exploit success rate adjusted by history: "
                f"{success_rate:.2f} (from {sample_count} samples)"
            )
    
    # ØªØ£Ø®ÙŠØ± Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©
    await asyncio.sleep(0.5)
    
    # Ø§Ù„Ù‚Ø±Ø§Ø± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ (Ù„Ø§ ÙŠØ²Ø§Ù„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù„ÙƒÙ† Ù…ÙÙˆØ¬ÙÙ‘Ù‡ Ø¨Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª)
    import random
    return random.random() < success_rate

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 2: ØªØ³Ø¬ÙŠÙ„ ÙƒÙ„ Ù…Ø­Ø§ÙˆÙ„Ø© ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ©
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def _execute_exploit(self, task: Dict[str, Any]) -> Dict[str, Any]:
    """
    ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØºÙ„Ø§Ù„ Ù…Ø¹ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø©.
    
    Ø§Ù„ØªØºÙŠÙŠØ±: ÙƒÙ„ Ù…Ø­Ø§ÙˆÙ„Ø© ØªÙØ³Ø¬ÙÙ‘Ù„ Ù„Ù„ØªØ¹Ù„Ù… Ù…Ù†Ù‡Ø§!
    """
    # ØªØ³Ø¬ÙŠÙ„ Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†ÙÙŠØ°
    decision_id = None
    if self._operational_memory:
        from ..core.operational_memory import OperationalContext
        
        decision_id = await self._operational_memory.record_decision(
            mission_id=UUID(self._current_mission_id) if self._current_mission_id else None,
            context=OperationalContext.EXPLOIT,
            decision_type="exploit_attempt",
            decision_source="attack_specialist",
            parameters={
                "vuln_type": vuln.get("type") if vuln else None,
                "rx_module": rx_module,
                "target_id": target_id
            },
            target_info=target,
            vuln_info=vuln
        )
    
    # ... Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ù„Ø§Ø³ØªØºÙ„Ø§Ù„ ...
    
    # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù†ØªÙŠØ¬Ø©
    if decision_id and self._operational_memory:
        from ..core.operational_memory import DecisionOutcome
        
        await self._operational_memory.update_outcome(
            decision_id=decision_id,
            outcome=DecisionOutcome.SUCCESS if success else DecisionOutcome.FAILURE,
            details={
                "session_id": session_id if success else None,
                "error_context": error_context,
                "execution_mode": execution_mode
            },
            duration_ms=int((datetime.utcnow() - start_time).total_seconds() * 1000)
        )
    
    return result

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 3: Ø§Ø³ØªØ®Ø¯Ø§Ù… Strategic Scorer Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ø«ØºØ±Ø§Øª
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def prioritize_vulnerabilities(
    self,
    vulnerabilities: List[Dict],
    target: Dict
) -> List[Dict]:
    """
    ØªØ±ØªÙŠØ¨ Ø§Ù„Ø«ØºØ±Ø§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ.
    
    Ø¬Ø¯ÙŠØ¯: Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„ØªØ±ØªÙŠØ¨ Ø¨Ù€ CVSS ÙÙ‚Ø·!
    """
    if not self._strategic_scorer:
        # fallback Ù„Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ù‚Ø¯ÙŠÙ…
        return sorted(
            vulnerabilities,
            key=lambda v: {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(
                v.get("severity", "").lower(), 0
            ),
            reverse=True
        )
    
    # Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ
    ranked = await self._strategic_scorer.rank_vulnerabilities(
        vulnerabilities=vulnerabilities,
        target=target,
        mission_context={"goals": await self._get_mission_goals()}
    )
    
    # ØªØ³Ø¬ÙŠÙ„
    for vuln, score in ranked[:3]:
        self.logger.info(
            f"[STRATEGIC] Vuln {vuln.get('type')}: "
            f"Strategic={score.strategic_score:.2f}, "
            f"Priority={score.recommended_priority}, "
            f"Reason={score.reasoning[0] if score.reasoning else 'N/A'}"
        )
    
    return [vuln for vuln, _ in ranked]
```

---

## ğŸ“… Ø®Ø§Ø±Ø·Ø© Ø§Ù„Ø·Ø±ÙŠÙ‚ Ù„Ù„ØªÙ†ÙÙŠØ°

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1: Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ§Øª (2-3 Ø£Ø³Ø§Ø¨ÙŠØ¹)
- [ ] Ø¥Ù†Ø´Ø§Ø¡ OperationalMemory
- [ ] Ø¯Ù…Ø¬ Ù‚Ø±Ø§Ø¡Ø© _analysis_history ÙÙŠ AnalysisSpecialist
- [ ] Ø§Ø³ØªØ¨Ø¯Ø§Ù„ random.random() Ø¨Ø¨ÙŠØ§Ù†Ø§Øª ØªØ§Ø±ÙŠØ®ÙŠØ© ÙÙŠ AttackSpecialist
- [ ] Ø¥Ø¶Ø§ÙØ© ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª ÙÙŠ ÙƒÙ„ Ù…Ø­Ø§ÙˆÙ„Ø©

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2: Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ (1-2 Ø´Ù‡Ø±)
- [ ] Ø¥Ù†Ø´Ø§Ø¡ IntelligenceCoordinator
- [ ] Ø¯Ù…Ø¬ Strategic Vulnerability Scorer
- [ ] Ø±Ø¨Ø· ReconSpecialist Ø¨Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ
- [ ] Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ø°ÙƒÙŠØ©

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3: Ø§Ù„ØªØ­Ø³ÙŠÙ† (3+ Ø£Ø´Ù‡Ø±)
- [ ] Ø¥Ø¶Ø§ÙØ© Stealth Profiles
- [ ] ØªØ¯Ø±ÙŠØ¨ Ù†Ù…ÙˆØ°Ø¬ LLM Ù…ØªØ®ØµØµ Ù„Ù„Ù‚Ø±Ø§Ø±Ø§Øª Ø§Ù„Ù‡Ø¬ÙˆÙ…ÙŠØ©
- [ ] Ø±Ø³Ù… Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø¢Ù„ÙŠØ§Ù‹
- [ ] ØªØ¹Ù„Ù… Ù…Ø³ØªÙ…Ø± Ù…Ù† ÙƒÙ„ Ù…Ù‡Ù…Ø©

---

## ğŸ“Š Ù…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„Ù†Ø¬Ø§Ø­

| Ø§Ù„Ù…Ù‚ÙŠØ§Ø³ | Ø§Ù„Ø­Ø§Ù„ÙŠ | Ø§Ù„Ù‡Ø¯Ù |
|---------|--------|-------|
| Ù†Ø³Ø¨Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Agentic | 20% | 60%+ |
| Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°Ø§ÙƒØ±Ø© ÙÙŠ Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª | 0% | 70%+ |
| Ø§Ù„ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„ÙØ´Ù„ | Ù„Ø§ ÙŠÙˆØ¬Ø¯ | ÙƒÙ„ ÙØ´Ù„ ÙŠÙØ­Ù„ÙÙ‘Ù„ |
| Ø±Ø¨Ø· Recon-Attack | Ø¶Ø¹ÙŠÙ | Ø°ÙƒÙŠ ÙˆÙ…Ù†Ø³Ù‚ |
| ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø«ØºØ±Ø§Øª | CVSS ÙÙ‚Ø· | Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ |

---

## ğŸ¯ Ø§Ù„Ø®Ù„Ø§ØµØ©

Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø·Ø© Ø§Ù„Ø¹Ù„Ø§Ø¬ÙŠØ©:
1. **ØªØ­Ø§ÙØ¸ Ø¹Ù„Ù‰ LLM** - ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø³ØªØ´Ø§Ø± Ù„Ù„Ù‚Ø±Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø©
2. **ØªØ­Ø§ÙØ¸ Ø¹Ù„Ù‰ Knowledge Base** - ØªØ¨Ù‚Ù‰ Ø§Ù„Ø£Ø³Ø§Ø³ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªÙ‚Ù†ÙŠØ©
3. **ØªØ¶ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø©** - Ø§Ù„ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„ØªØ¬Ø§Ø±Ø¨ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
4. **ØªØ¶ÙŠÙ Ø§Ù„ØªÙ†Ø³ÙŠÙ‚** - Ø±Ø¨Ø· Ø°ÙƒÙŠ Ø¨ÙŠÙ† Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª
5. **ØªØ¶ÙŠÙ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©** - ØªÙ‚ÙŠÙŠÙ… ÙŠØªØ¬Ø§ÙˆØ² CVSS

Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©: ØªØ­ÙˆÙŠÙ„ RAGLOX Ù…Ù† **Ø£Ø¯Ø§Ø© Ø£ØªÙ…ØªØ© Ø°ÙƒÙŠØ©** Ø¥Ù„Ù‰ **Ø´Ø±ÙŠÙƒ ØªÙÙƒÙŠØ±** Ø­Ù‚ÙŠÙ‚ÙŠ Ù„ÙØ±Ù‚ Red Team Ø§Ù„Ù…Ø­ØªØ±ÙØ©.
