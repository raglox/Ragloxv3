# Ø®Ø·Ø© Ø§Ù„Ø¹Ù„Ø§Ø¬ Ø§Ù„Ø°ÙƒÙŠØ© Ù„Ù†Ø¸Ø§Ù… RAGLOX v3.0
## Hybrid Intelligence Treatment Plan
### "Ù„Ø§ Ù†ÙÙ‚Ø¯ Ø§Ù„ØºØ§ÙŠØ© ÙˆÙ„Ø§ Ø§Ù„ÙˆØ³ÙŠÙ„Ø©"

---

## ðŸ“‹ Ø§Ù„ÙÙ„Ø³ÙØ© Ø§Ù„ØªÙˆØ¬ÙŠÙ‡ÙŠØ©

### Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©:
```
Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ù‡Ø¬ÙŠÙ† = (Ù‚ÙˆØ§Ø¹Ø¯ Ù…Ø¹Ø±ÙÙŠØ© Ù…Ø¶Ù…Ù†Ø© Ã— Ø§Ø³ØªØ¯Ù„Ø§Ù„ LLM) + Ø°Ø§ÙƒØ±Ø© ØªØ´ØºÙŠÙ„ÙŠØ©
```

### Ø§Ù„Ù…Ø¨Ø§Ø¯Ø¦ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:
1. **LLM Ù„ÙŠØ³ Ø§Ù„Ø¨Ø¯ÙŠÙ„** - LLM ÙŠÙØ¹Ø²Ø² Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ù…Ø¶Ù…Ù†Ø©ØŒ Ù„Ø§ ÙŠÙÙ„ØºÙŠÙ‡Ø§
2. **Ø§Ù„Ù…Ø¹Ø±ÙØ© Ø§Ù„Ù…Ø¶Ù…Ù†Ø© Ù‡ÙŠ Ø§Ù„Ø£Ø³Ø§Ø³** - Ø³Ø±ÙŠØ¹Ø©ØŒ Ù…ÙˆØ«ÙˆÙ‚Ø©ØŒ Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ¯Ù‚ÙŠÙ‚
3. **LLM Ù„Ù„Ù‚Ø±Ø§Ø±Ø§Øª Ø§Ù„ØµØ¹Ø¨Ø©** - Ø¹Ù†Ø¯Ù…Ø§ Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ù„Ø§ ØªÙƒÙÙŠ
4. **Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ù„Ù„ØªØ¹Ù„Ù…** - Ø§Ù„ØªØ§Ø±ÙŠØ® ÙŠÙØ­Ø³Ù‘Ù† Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„

---

## ðŸ—ï¸ Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ù‡Ø¬ÙŠÙ† (Hybrid Intelligence Architecture)

### Ø§Ù„Ø·Ø¨Ù‚Ø© 1: Knowledge-First Decision Layer

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Ø·Ø¨Ù‚Ø© Ø§Ù„Ù‚Ø±Ø§Ø± Ø§Ù„Ø£ÙˆÙ„Ù‰                        â”‚
â”‚         (Knowledge-First Decision Layer)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚   Nuclei    â”‚    â”‚ RX Modules  â”‚    â”‚   MITRE     â”‚    â”‚
â”‚  â”‚  Templates  â”‚    â”‚  (1,761)    â”‚    â”‚  Techniques â”‚    â”‚
â”‚  â”‚  (11,927)   â”‚    â”‚             â”‚    â”‚   (327)     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â”‚                  â”‚                  â”‚            â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                            â–¼                               â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚              â”‚   EmbeddedKnowledge     â”‚                   â”‚
â”‚              â”‚   (Decision Engine v1)  â”‚                   â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                          â”‚                                 â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚              â”‚    Decision Confident?   â”‚                   â”‚
â”‚              â”‚    (Confidence > 0.75)   â”‚                   â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                    Yes â”Œâ”€â”´â”€â” No                            â”‚
â”‚                        â”‚   â”‚                               â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â” â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚              â”‚  Execute  â”‚        Escalate to   â”‚         â”‚
â”‚              â”‚  Directly â”‚        LLM Layer     â”‚         â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â–¼         â”‚
â”‚                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚                                    â”‚   LLM Service   â”‚    â”‚
â”‚                                    â”‚ (Decision v2)   â”‚    â”‚
â”‚                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ø§Ù„Ø·Ø¨Ù‚Ø© 2: Operational Memory Layer

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Ø·Ø¨Ù‚Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ©                     â”‚
â”‚           (Operational Memory Layer)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚              Redis + Vector Store                   â”‚    â”‚
â”‚  â”‚                                                     â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚  â”‚  â”‚ Action       â”‚  â”‚ Defense      â”‚  â”‚ Success  â”‚  â”‚    â”‚
â”‚  â”‚  â”‚ Outcomes     â”‚  â”‚ Signatures   â”‚  â”‚ Patterns â”‚  â”‚    â”‚
â”‚  â”‚  â”‚ History      â”‚  â”‚ Mapping      â”‚  â”‚ Cache    â”‚  â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚  â”‚                                                     â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚  â”‚  â”‚        Similarity Search Engine              â”‚  â”‚    â”‚
â”‚  â”‚  â”‚   (Find similar past situations)             â”‚  â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                             â”‚
â”‚  Query Interface:                                           â”‚
â”‚  - query_similar_outcomes(action, context) -> List[Outcome]â”‚
â”‚  - get_historical_success_rate(action, target) -> float    â”‚
â”‚  - get_defense_bypass_history(defense_type) -> List[Bypass]â”‚
â”‚  - record_outcome(action, result, context) -> void         â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ø§Ù„Ø·Ø¨Ù‚Ø© 3: Intelligence Coordinator

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Ù…Ù†Ø³Ù‚ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ù…Ø±ÙƒØ²ÙŠ                        â”‚
â”‚        (Intelligence Coordinator - The Brain)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚         â”‚   Recon    â”‚ â”‚   Attack   â”‚ â”‚  Analysis  â”‚       â”‚
â”‚         â”‚ Specialist â”‚ â”‚ Specialist â”‚ â”‚ Specialist â”‚       â”‚
â”‚         â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚               â”‚              â”‚              â”‚               â”‚
â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                              â–¼                              â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚              â”‚   IntelligenceCoordinator     â”‚              â”‚
â”‚              â”‚                               â”‚              â”‚
â”‚              â”‚  - Cross-Workspace Insights   â”‚              â”‚
â”‚              â”‚  - Attack Graph Generation    â”‚              â”‚
â”‚              â”‚  - Credential Correlation     â”‚              â”‚
â”‚              â”‚  - Strategic Target Selection â”‚              â”‚
â”‚              â”‚  - Mission Goal Optimization  â”‚              â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                              â”‚                              â”‚
â”‚                              â–¼                              â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚              â”‚      Unified World Model      â”‚              â”‚
â”‚              â”‚   (Complete Mission State)    â”‚              â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ðŸ“¦ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©

### 1. OperationalMemory Module

**Ø§Ù„Ù…Ù„Ù:** `src/core/memory/operational.py`

```python
"""
OperationalMemory - Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ© Ù„Ù„Ù†Ø¸Ø§Ù…

Ø§Ù„ØºØ±Ø¶: ØªØ®Ø²ÙŠÙ† ÙˆØ§Ø³ØªØ±Ø¬Ø§Ø¹ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠØ©
Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… random.random() Ø£Ùˆ magic numbers

Ø§Ù„Ù…Ø¨Ø¯Ø£: "Ù…Ù† Ù„Ø§ ÙŠØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„ØªØ§Ø±ÙŠØ® Ù…Ø­ÙƒÙˆÙ… Ø¹Ù„ÙŠÙ‡ Ø¨ØªÙƒØ±Ø§Ø±Ù‡"
"""

from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from uuid import UUID
import json
import hashlib

from ..blackboard import Blackboard


@dataclass
class ActionOutcome:
    """Ø³Ø¬Ù„ Ù†ØªÙŠØ¬Ø© Ø¹Ù…Ù„ÙŠØ© ÙˆØ§Ø­Ø¯Ø©"""
    action_type: str           # EXPLOIT, PRIVESC, LATERAL, etc.
    module_id: Optional[str]   # RX Module used
    target_context: Dict       # OS, services, ports, etc.
    defense_context: List[str] # Detected defenses
    result: str                # success, failed, blocked, timeout
    error_category: Optional[str]  # If failed: network, defense, etc.
    timestamp: datetime
    mission_id: UUID
    
    # Similarity key for fast lookups
    @property
    def context_signature(self) -> str:
        """Generate a signature for similarity matching"""
        key_parts = [
            self.action_type,
            self.target_context.get("os", "unknown"),
            ",".join(sorted(self.defense_context)),
        ]
        return hashlib.md5("|".join(key_parts).encode()).hexdigest()[:16]


class OperationalMemory:
    """
    Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ© - ØªØ®Ø²Ù† ÙˆØªØ³ØªØ±Ø¬Ø¹ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª
    
    Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:
    - Ù‚Ø¨Ù„ ØªÙ†ÙÙŠØ° Ø¹Ù…Ù„ÙŠØ©: query Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ historical success rate
    - Ø¨Ø¹Ø¯ ØªÙ†ÙÙŠØ° Ø¹Ù…Ù„ÙŠØ©: record Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù†ØªÙŠØ¬Ø©
    - ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„: get_similar_failures Ù„Ù„ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ù…Ø§Ø¶ÙŠ
    """
    
    def __init__(self, blackboard: Blackboard):
        self.blackboard = blackboard
        self._local_cache: Dict[str, List[ActionOutcome]] = {}
        
    async def record_outcome(
        self,
        action_type: str,
        module_id: Optional[str],
        target_context: Dict,
        defense_context: List[str],
        result: str,
        error_category: Optional[str] = None,
        mission_id: Optional[UUID] = None
    ) -> None:
        """
        ØªØ³Ø¬ÙŠÙ„ Ù†ØªÙŠØ¬Ø© Ø¹Ù…Ù„ÙŠØ©
        
        ÙŠÙØ³ØªØ¯Ø¹Ù‰ Ø¨Ø¹Ø¯ ÙƒÙ„ ØªÙ†ÙÙŠØ° (Ù†Ø¬Ø§Ø­ Ø£Ùˆ ÙØ´Ù„)
        """
        outcome = ActionOutcome(
            action_type=action_type,
            module_id=module_id,
            target_context=target_context,
            defense_context=defense_context,
            result=result,
            error_category=error_category,
            timestamp=datetime.utcnow(),
            mission_id=mission_id or UUID('00000000-0000-0000-0000-000000000000')
        )
        
        # Store in Redis stream
        await self.blackboard.redis.xadd(
            "memory:outcomes",
            {
                "data": json.dumps(outcome.__dict__, default=str),
                "signature": outcome.context_signature,
                "result": result,
            }
        )
        
        # Update local cache
        sig = outcome.context_signature
        if sig not in self._local_cache:
            self._local_cache[sig] = []
        self._local_cache[sig].append(outcome)
    
    async def get_historical_success_rate(
        self,
        action_type: str,
        target_context: Dict,
        defense_context: List[str],
        min_samples: int = 3
    ) -> Tuple[float, int]:
        """
        Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­ Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠ Ù„Ø³ÙŠØ§Ù‚ Ù…Ø´Ø§Ø¨Ù‡
        
        Returns:
            Tuple of (success_rate, sample_count)
            If sample_count < min_samples, returns (0.5, sample_count) as default
        """
        # Build signature for lookup
        key_parts = [
            action_type,
            target_context.get("os", "unknown"),
            ",".join(sorted(defense_context)),
        ]
        signature = hashlib.md5("|".join(key_parts).encode()).hexdigest()[:16]
        
        # Query from Redis
        outcomes = await self._query_by_signature(signature)
        
        if len(outcomes) < min_samples:
            return 0.5, len(outcomes)  # Default rate when insufficient data
        
        successes = sum(1 for o in outcomes if o["result"] == "success")
        return successes / len(outcomes), len(outcomes)
    
    async def get_similar_failures(
        self,
        action_type: str,
        error_category: str,
        limit: int = 10
    ) -> List[Dict]:
        """
        Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø¥Ø®ÙØ§Ù‚Ø§Øª Ù…Ø´Ø§Ø¨Ù‡Ø© Ù„Ù„ØªØ¹Ù„Ù… Ù…Ù†Ù‡Ø§
        
        ÙŠÙØ³ØªØ®Ø¯Ù… Ø¨ÙˆØ§Ø³Ø·Ø© AnalysisSpecialist Ù„ÙÙ‡Ù… Ø£Ù†Ù…Ø§Ø· Ø§Ù„ÙØ´Ù„
        """
        # Query failures with same action type and error category
        results = await self.blackboard.redis.xrevrange(
            "memory:outcomes",
            count=100
        )
        
        similar = []
        for entry_id, fields in results:
            data = json.loads(fields.get("data", "{}"))
            if (data.get("action_type") == action_type and 
                data.get("error_category") == error_category and
                data.get("result") == "failed"):
                similar.append(data)
                if len(similar) >= limit:
                    break
        
        return similar
    
    async def get_defense_bypass_history(
        self,
        defense_type: str,
        limit: int = 20
    ) -> List[Dict]:
        """
        Ø§Ø³ØªØ±Ø¬Ø§Ø¹ ØªØ§Ø±ÙŠØ® ØªØ¬Ø§ÙˆØ² Ø¯ÙØ§Ø¹ Ù…Ø¹ÙŠÙ†
        
        ÙŠØ¹ÙŠØ¯ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù†Ø§Ø¬Ø­Ø© Ø§Ù„ØªÙŠ ÙˆØ§Ø¬Ù‡Øª Ù†ÙØ³ Ø§Ù„Ø¯ÙØ§Ø¹
        """
        results = await self.blackboard.redis.xrevrange(
            "memory:outcomes",
            count=500
        )
        
        bypasses = []
        for entry_id, fields in results:
            data = json.loads(fields.get("data", "{}"))
            if (defense_type in data.get("defense_context", []) and
                data.get("result") == "success"):
                bypasses.append({
                    "module_id": data.get("module_id"),
                    "target_context": data.get("target_context"),
                    "timestamp": data.get("timestamp"),
                })
                if len(bypasses) >= limit:
                    break
        
        return bypasses
    
    async def _query_by_signature(self, signature: str) -> List[Dict]:
        """Query outcomes by context signature"""
        # Check local cache first
        if signature in self._local_cache:
            return [o.__dict__ for o in self._local_cache[signature]]
        
        # Query Redis
        results = await self.blackboard.redis.xrevrange(
            "memory:outcomes",
            count=100
        )
        
        matching = []
        for entry_id, fields in results:
            if fields.get("signature") == signature:
                matching.append(json.loads(fields.get("data", "{}")))
        
        return matching


# Singleton instance
_operational_memory: Optional[OperationalMemory] = None

def get_operational_memory(blackboard: Blackboard = None) -> OperationalMemory:
    """Get or create the operational memory instance"""
    global _operational_memory
    if _operational_memory is None:
        if blackboard is None:
            raise ValueError("Blackboard required for first initialization")
        _operational_memory = OperationalMemory(blackboard)
    return _operational_memory
```

---

### 2. IntelligenceCoordinator Module

**Ø§Ù„Ù…Ù„Ù:** `src/core/intelligence/coordinator.py`

```python
"""
IntelligenceCoordinator - Ù…Ù†Ø³Ù‚ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ù…Ø±ÙƒØ²ÙŠ

Ø§Ù„ØºØ±Ø¶: Ø±Ø¨Ø· Ø§ÙƒØªØ´Ø§ÙØ§Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù€ Specialists ÙˆØªÙˆÙ„ÙŠØ¯ Ø±Ø¤Ù‰ Ø¹Ø¨Ø±-Ù…Ø³Ø§Ø­Ø§Øª Ø§Ù„Ø¹Ù…Ù„

Ø§Ù„Ù…Ø¨Ø¯Ø£: "Ø§Ù„ÙƒÙ„ Ø£ÙƒØ¨Ø± Ù…Ù† Ù…Ø¬Ù…ÙˆØ¹ Ø£Ø¬Ø²Ø§Ø¦Ù‡"
"""

from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple
from uuid import UUID

from ..blackboard import Blackboard
from ..knowledge import EmbeddedKnowledge
from ..memory.operational import OperationalMemory
from ..llm.service import LLMService


@dataclass
class TargetInsight:
    """Ø±Ø¤ÙŠØ© Ù…Ø­Ø³Ù‘Ù†Ø© Ø¹Ù† Ù‡Ø¯Ù"""
    target_id: str
    strategic_value: float          # 0-1 based on multiple factors
    attack_readiness: float         # 0-1 how ready we are to attack
    recommended_approach: str       # Best attack vector
    credential_availability: int    # Number of relevant credentials
    related_targets: List[str]      # Similar targets in network


@dataclass
class AttackPath:
    """Ù…Ø³Ø§Ø± Ù‡Ø¬ÙˆÙ… Ù…Ù‚ØªØ±Ø­"""
    steps: List[Dict]
    total_confidence: float
    estimated_time_minutes: int
    required_resources: List[str]
    risk_level: str  # low, medium, high


class IntelligenceCoordinator:
    """
    Ù…Ù†Ø³Ù‚ Ø§Ù„Ø°ÙƒØ§Ø¡ - ÙŠØ±Ø¨Ø· Ø¨ÙŠÙ† Workspaces Ø§Ù„Ù…Ø®ØªÙ„ÙØ©
    
    Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ§Øª:
    1. Cross-Target Credential Correlation
    2. Attack Graph Generation
    3. Strategic Target Prioritization
    4. Mission Goal Optimization
    """
    
    def __init__(
        self,
        blackboard: Blackboard,
        knowledge: EmbeddedKnowledge,
        memory: OperationalMemory,
        llm_service: Optional[LLMService] = None
    ):
        self.blackboard = blackboard
        self.knowledge = knowledge
        self.memory = memory
        self.llm_service = llm_service
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Cross-Target Credential Correlation
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async def correlate_credential_with_targets(
        self,
        credential_id: str,
        mission_id: str
    ) -> List[Tuple[str, float]]:
        """
        Ù„ÙƒÙ„ credentialØŒ Ø­Ø¯Ø¯ targets Ø£Ø®Ø±Ù‰ ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ Ø¹Ù„ÙŠÙ‡Ø§
        
        Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ù…Ø¶Ù…Ù†Ø© (Ù„Ø§ ØªØ­ØªØ§Ø¬ LLM):
        1. Ù†ÙØ³ Ø§Ù„Ù€ Domain -> Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ø¹Ø§Ù„ÙŠØ©
        2. Ù†ÙØ³ Ø§Ù„Ù€ OS Version -> Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ù…ØªÙˆØ³Ø·Ø©
        3. Ù†ÙØ³ Ø§Ù„Ù€ Service (SMB, SSH) -> Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ù…ØªÙˆØ³Ø·Ø©
        
        Returns:
            List of (target_id, probability) tuples
        """
        cred = await self.blackboard.get_credential(credential_id)
        if not cred:
            return []
        
        cred_domain = cred.get("domain")
        cred_type = cred.get("type")  # hash, password, etc.
        
        # Get all targets in mission
        all_targets = await self.blackboard.get_mission_targets(mission_id)
        
        correlations = []
        
        for target_key in all_targets:
            target_id = target_key.replace("target:", "")
            target = await self.blackboard.get_target(target_id)
            if not target:
                continue
            
            # Skip already-owned targets
            if target.get("status") in ("exploited", "owned"):
                continue
            
            probability = 0.0
            
            # Rule 1: Domain match (Knowledge-based)
            if cred_domain and cred_domain == target.get("domain"):
                probability += 0.4
            
            # Rule 2: Same OS family
            target_os = (target.get("os") or "").lower()
            if cred_type == "hash" and "windows" in target_os:
                probability += 0.25  # NTLM hashes work on Windows
            elif cred_type == "password":
                probability += 0.15  # Passwords more universal
            
            # Rule 3: Check ports for compatible services
            ports = await self.blackboard.get_target_ports(target_id)
            if cred_type == "hash" and "445" in ports:
                probability += 0.2  # SMB for pass-the-hash
            if "22" in ports or "3389" in ports:
                probability += 0.1  # SSH/RDP for password auth
            
            # Rule 4: Historical success (Memory-based)
            hist_rate, samples = await self.memory.get_historical_success_rate(
                action_type="LATERAL",
                target_context={"os": target_os},
                defense_context=[]
            )
            if samples >= 3:
                probability = (probability * 0.7) + (hist_rate * 0.3)
            
            if probability > 0.3:
                correlations.append((target_id, round(probability, 2)))
        
        # Sort by probability
        return sorted(correlations, key=lambda x: x[1], reverse=True)
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Strategic Target Prioritization
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async def calculate_strategic_target_value(
        self,
        target_id: str,
        mission_id: str,
        mission_goals: List[str]
    ) -> TargetInsight:
        """
        Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ù„Ù„Ù‡Ø¯Ù
        
        Ù„Ø§ ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ CVSS ÙÙ‚Ø·!
        
        Ø§Ù„Ø¹ÙˆØ§Ù…Ù„ (Knowledge-based):
        1. Asset Criticality (30%)
        2. Attack Readiness (25%)
        3. Goal Proximity (20%)
        4. Historical Success on Similar (15%)
        5. Credential Availability (10%)
        """
        target = await self.blackboard.get_target(target_id)
        if not target:
            return TargetInsight(
                target_id=target_id,
                strategic_value=0.0,
                attack_readiness=0.0,
                recommended_approach="unknown",
                credential_availability=0,
                related_targets=[]
            )
        
        target_ip = target.get("ip", "")
        target_os = (target.get("os") or "").lower()
        hostname = (target.get("hostname") or "").lower()
        
        # Factor 1: Asset Criticality (Knowledge-based rules)
        criticality = 0.3  # Default
        critical_indicators = ["dc", "domain", "ad", "exchange", "sql", "db", "backup"]
        for indicator in critical_indicators:
            if indicator in hostname:
                criticality = 0.8
                break
        if "server" in target_os:
            criticality = max(criticality, 0.6)
        
        # Factor 2: Attack Readiness
        vulns = await self._get_target_vulns(target_id, mission_id)
        creds = await self._get_target_creds(target_id, mission_id)
        
        readiness = 0.0
        if vulns:
            # Check for exploitable vulns
            high_vulns = [v for v in vulns if v.get("severity") in ("critical", "high")]
            readiness += min(len(high_vulns) * 0.2, 0.5)
        if creds:
            readiness += min(len(creds) * 0.15, 0.3)
        
        # Factor 3: Goal Proximity (Simple keyword matching)
        goal_proximity = 0.0
        for goal in mission_goals:
            goal_lower = goal.lower()
            if "domain" in goal_lower and any(x in hostname for x in ["dc", "domain", "ad"]):
                goal_proximity = 0.9
                break
            if "database" in goal_lower and any(x in hostname for x in ["sql", "db", "mysql"]):
                goal_proximity = 0.8
                break
            if "credential" in goal_lower:
                goal_proximity = 0.5  # Any target can yield creds
        
        # Factor 4: Historical Success Rate
        hist_rate, samples = await self.memory.get_historical_success_rate(
            action_type="EXPLOIT",
            target_context={"os": target_os},
            defense_context=[]
        )
        history_factor = hist_rate if samples >= 3 else 0.5
        
        # Factor 5: Credential Availability
        cred_factor = min(len(creds) * 0.1, 0.3) if creds else 0.0
        
        # Calculate final strategic value
        strategic_value = (
            criticality * 0.30 +
            readiness * 0.25 +
            goal_proximity * 0.20 +
            history_factor * 0.15 +
            cred_factor * 0.10
        )
        
        # Determine recommended approach
        recommended_approach = await self._determine_best_approach(
            target, vulns, creds, target_os
        )
        
        # Find related targets
        related = await self._find_related_targets(target, mission_id)
        
        return TargetInsight(
            target_id=target_id,
            strategic_value=round(strategic_value, 2),
            attack_readiness=round(readiness, 2),
            recommended_approach=recommended_approach,
            credential_availability=len(creds) if creds else 0,
            related_targets=related[:5]
        )
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Attack Graph Generation
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async def generate_attack_path(
        self,
        source_session_id: Optional[str],
        target_id: str,
        mission_id: str,
        use_llm: bool = False
    ) -> Optional[AttackPath]:
        """
        ØªÙˆÙ„ÙŠØ¯ Ù…Ø³Ø§Ø± Ù‡Ø¬ÙˆÙ… Ù…Ù† Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø¥Ù„Ù‰ Ø§Ù„Ù‡Ø¯Ù
        
        Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ: Knowledge-based (Ø³Ø±ÙŠØ¹ØŒ Ù…ÙˆØ«ÙˆÙ‚)
        use_llm=True: ÙŠØ³ØªØ®Ø¯Ù… LLM Ù„Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø©
        """
        # Get available resources
        sessions = await self.blackboard.get_mission_sessions(mission_id)
        creds = await self.blackboard.get_mission_creds(mission_id)
        vulns = await self.blackboard.get_mission_vulns(mission_id)
        
        # Knowledge-based path generation
        steps = []
        
        # Step 1: If no session, need initial access
        if not source_session_id and not sessions:
            # Look for exploitable vulns on target
            target_vulns = await self._get_target_vulns(target_id, mission_id)
            if target_vulns:
                best_vuln = max(target_vulns, key=lambda v: self._vuln_score(v))
                steps.append({
                    "action": "EXPLOIT",
                    "target_id": target_id,
                    "vuln_id": best_vuln.get("id"),
                    "confidence": 0.7 if best_vuln.get("severity") == "critical" else 0.5
                })
            else:
                # Look for credentials
                target_creds = await self._get_target_creds(target_id, mission_id)
                if target_creds:
                    steps.append({
                        "action": "CREDENTIAL_AUTH",
                        "target_id": target_id,
                        "cred_id": target_creds[0].get("id"),
                        "confidence": 0.6
                    })
        
        # Step 2: If we have session but need to reach target
        elif source_session_id:
            # Check if we need lateral movement
            steps.append({
                "action": "LATERAL",
                "from_session": source_session_id,
                "target_id": target_id,
                "confidence": 0.5
            })
        
        # Step 3: Privilege escalation if needed
        steps.append({
            "action": "PRIVESC",
            "target_id": target_id,
            "confidence": 0.4
        })
        
        # Step 4: Credential harvesting
        steps.append({
            "action": "CRED_HARVEST",
            "target_id": target_id,
            "confidence": 0.6
        })
        
        # Use LLM for complex path optimization (optional)
        if use_llm and self.llm_service and len(steps) > 3:
            optimized = await self._llm_optimize_path(steps, mission_id)
            if optimized:
                steps = optimized
        
        # Calculate totals
        total_confidence = 1.0
        for step in steps:
            total_confidence *= step.get("confidence", 0.5)
        
        return AttackPath(
            steps=steps,
            total_confidence=round(total_confidence, 2),
            estimated_time_minutes=len(steps) * 5,
            required_resources=["session" if source_session_id else "vuln_or_cred"],
            risk_level="medium"
        )
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Helper Methods
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async def _get_target_vulns(self, target_id: str, mission_id: str) -> List[Dict]:
        """Get vulnerabilities for a target"""
        all_vulns = await self.blackboard.get_mission_vulns(mission_id)
        target_vulns = []
        
        for vuln_key in all_vulns:
            vuln_id = vuln_key.replace("vuln:", "")
            vuln = await self.blackboard.get_vulnerability(vuln_id)
            if vuln and str(vuln.get("target_id", "")).replace("target:", "") == target_id:
                target_vulns.append(vuln)
        
        return target_vulns
    
    async def _get_target_creds(self, target_id: str, mission_id: str) -> List[Dict]:
        """Get credentials relevant to a target"""
        all_creds = await self.blackboard.get_mission_creds(mission_id)
        target_creds = []
        
        for cred_key in all_creds:
            cred_id = cred_key.replace("cred:", "")
            cred = await self.blackboard.get_credential(cred_id)
            if cred:
                cred_target = str(cred.get("target_id", "")).replace("target:", "")
                if cred_target == target_id or cred.get("domain"):
                    target_creds.append(cred)
        
        return target_creds
    
    async def _determine_best_approach(
        self,
        target: Dict,
        vulns: List[Dict],
        creds: List[Dict],
        target_os: str
    ) -> str:
        """Determine best attack approach for target"""
        # Priority 1: Critical vulns
        critical_vulns = [v for v in vulns if v.get("severity") == "critical"]
        if critical_vulns:
            return f"exploit_vuln:{critical_vulns[0].get('type', 'unknown')}"
        
        # Priority 2: High-reliability credentials
        intel_creds = [c for c in creds if c.get("source", "").startswith("intel:")]
        if intel_creds:
            return "credential_auth:intel"
        
        # Priority 3: Any credentials
        if creds:
            return "credential_auth:harvested"
        
        # Priority 4: High vulns
        high_vulns = [v for v in vulns if v.get("severity") == "high"]
        if high_vulns:
            return f"exploit_vuln:{high_vulns[0].get('type', 'unknown')}"
        
        # Default
        return "reconnaissance_needed"
    
    async def _find_related_targets(
        self,
        target: Dict,
        mission_id: str
    ) -> List[str]:
        """Find targets similar to this one"""
        target_os = (target.get("os") or "").lower()
        target_domain = target.get("domain")
        
        all_targets = await self.blackboard.get_mission_targets(mission_id)
        related = []
        
        for t_key in all_targets:
            t_id = t_key.replace("target:", "")
            if t_id == str(target.get("id", "")):
                continue
            
            t = await self.blackboard.get_target(t_id)
            if not t:
                continue
            
            t_os = (t.get("os") or "").lower()
            
            # Same OS family
            if "windows" in target_os and "windows" in t_os:
                related.append(t_id)
            elif "linux" in target_os and "linux" in t_os:
                related.append(t_id)
            # Same domain
            elif target_domain and t.get("domain") == target_domain:
                related.append(t_id)
        
        return related
    
    def _vuln_score(self, vuln: Dict) -> float:
        """Score vulnerability for prioritization"""
        severity_scores = {
            "critical": 10.0,
            "high": 8.0,
            "medium": 5.0,
            "low": 3.0,
            "info": 1.0
        }
        return severity_scores.get(vuln.get("severity", "").lower(), 5.0)
    
    async def _llm_optimize_path(
        self,
        steps: List[Dict],
        mission_id: str
    ) -> Optional[List[Dict]]:
        """Use LLM to optimize attack path (optional enhancement)"""
        if not self.llm_service:
            return None
        
        # This would call LLM for complex path optimization
        # For now, return None to use knowledge-based path
        return None
```

---

### 3. Strategic Decision Engine (ØªØ­Ø³ÙŠÙ† AnalysisSpecialist)

**Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¹Ù„Ù‰:** `src/specialists/analysis.py`

```python
# Ø¥Ø¶Ø§ÙØ§Øª Ù„Ù„Ù€ AnalysisSpecialist

class AnalysisSpecialist(BaseSpecialist):
    
    def __init__(self, ...):
        # ... existing init ...
        
        # NEW: Operational Memory integration
        self._memory: Optional[OperationalMemory] = None
        
        # NEW: Decision confidence thresholds
        self.KNOWLEDGE_CONFIDENCE_THRESHOLD = 0.75
        self.LLM_ESCALATION_THRESHOLD = 0.50
    
    @property
    def memory(self) -> OperationalMemory:
        """Get operational memory instance"""
        if self._memory is None:
            from ..core.memory.operational import get_operational_memory
            self._memory = get_operational_memory(self.blackboard)
        return self._memory
    
    async def _make_decision(
        self,
        original_task: Dict[str, Any],
        error_context: Dict[str, Any],
        execution_logs: List[Dict[str, Any]],
        category: str,
        strategy: Dict[str, Any],
        context: Dict[str, Any],
        retry_count: int,
        max_retries: int
    ) -> Dict[str, Any]:
        """
        Ù‚Ø±Ø§Ø± Ù‡Ø¬ÙŠÙ†: Knowledge-First + LLM-Enhanced
        
        Ø§Ù„Ù…Ù†Ù‡Ø¬:
        1. Ø£ÙˆÙ„Ø§Ù‹: Ø§Ø³ØªØ´Ø± Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ© (Ø§Ù„ØªØ§Ø±ÙŠØ®)
        2. Ø«Ø§Ù†ÙŠØ§Ù‹: Ø·Ø¨Ù‘Ù‚ Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ù…Ø¶Ù…Ù†Ø©
        3. Ø«Ø§Ù„Ø«Ø§Ù‹: Ù‚ÙŠÙ‘Ù… Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø©
        4. Ø±Ø§Ø¨Ø¹Ø§Ù‹: Ø¥Ø°Ø§ Ø§Ù„Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø© -> Ø§Ø³ØªØ´Ø± LLM
        """
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø§Ø³ØªØ´Ø§Ø±Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ©
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        historical_insight = await self._consult_operational_memory(
            original_task, error_context, context
        )
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Ø§Ù„Ø®Ø·ÙˆØ© 2: ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ù…Ø¶Ù…Ù†Ø© Ù…Ø¹ Ø§Ù„Ø³ÙŠØ§Ù‚ Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠ
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        knowledge_decision, confidence = await self._knowledge_based_decision(
            original_task=original_task,
            error_context=error_context,
            category=category,
            strategy=strategy,
            context=context,
            historical_insight=historical_insight,
            retry_count=retry_count,
            max_retries=max_retries
        )
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Ø§Ù„Ø®Ø·ÙˆØ© 3: ØªÙ‚ÙŠÙŠÙ… Ù…Ø§ Ø¥Ø°Ø§ ÙƒÙ†Ø§ Ù†Ø­ØªØ§Ø¬ LLM
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        needs_llm = self._should_escalate_to_llm(
            confidence=confidence,
            category=category,
            context=context,
            historical_insight=historical_insight
        )
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Ø§Ù„Ø®Ø·ÙˆØ© 4: Ø§Ø³ØªØ´Ø§Ø±Ø© LLM Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        if needs_llm and self.llm_enabled:
            self.logger.info(
                f"[HYBRID] Knowledge confidence={confidence:.2f}, escalating to LLM"
            )
            llm_decision = await self._llm_decision(
                original_task, error_context, execution_logs, context
            )
            
            # Merge knowledge and LLM insights
            final_decision = self._merge_decisions(
                knowledge_decision, llm_decision, confidence
            )
        else:
            self.logger.info(
                f"[HYBRID] Knowledge confidence={confidence:.2f}, using knowledge-based decision"
            )
            final_decision = knowledge_decision
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Ø§Ù„Ø®Ø·ÙˆØ© 5: ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù‚Ø±Ø§Ø± ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ©
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        # Record this decision for future learning (will be updated with outcome later)
        await self._record_decision_to_memory(
            original_task, final_decision, context
        )
        
        return final_decision
    
    async def _consult_operational_memory(
        self,
        task: Dict,
        error_context: Dict,
        context: Dict
    ) -> Dict[str, Any]:
        """
        Ø§Ø³ØªØ´Ø§Ø±Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±Ø¤Ù‰ ØªØ§Ø±ÙŠØ®ÙŠØ©
        """
        insight = {
            "historical_success_rate": 0.5,
            "sample_count": 0,
            "similar_failures": [],
            "successful_bypasses": []
        }
        
        try:
            # Get historical success rate for this action type
            task_type = task.get("type", "UNKNOWN")
            target_info = context.get("target_info") or {}
            target_os = (target_info.get("os") or "unknown").lower()
            defenses = context.get("detected_defenses", [])
            
            success_rate, samples = await self.memory.get_historical_success_rate(
                action_type=task_type,
                target_context={"os": target_os},
                defense_context=defenses
            )
            insight["historical_success_rate"] = success_rate
            insight["sample_count"] = samples
            
            # Get similar failures
            error_category = self._categorize_error(error_context.get("error_type", "unknown"))
            similar = await self.memory.get_similar_failures(
                action_type=task_type,
                error_category=error_category,
                limit=5
            )
            insight["similar_failures"] = similar
            
            # Get defense bypass history if defenses detected
            if defenses:
                for defense in defenses[:2]:
                    bypasses = await self.memory.get_defense_bypass_history(
                        defense_type=defense,
                        limit=5
                    )
                    insight["successful_bypasses"].extend(bypasses)
            
        except Exception as e:
            self.logger.warning(f"Error consulting memory: {e}")
        
        return insight
    
    async def _knowledge_based_decision(
        self,
        original_task: Dict,
        error_context: Dict,
        category: str,
        strategy: Dict,
        context: Dict,
        historical_insight: Dict,
        retry_count: int,
        max_retries: int
    ) -> Tuple[Dict, float]:
        """
        Ù‚Ø±Ø§Ø± Ù‚Ø§Ø¦Ù… Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¹Ø±ÙØ© Ù…Ø¹ Ø­Ø³Ø§Ø¨ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø©
        
        Returns:
            Tuple of (decision_dict, confidence_score)
        """
        confidence = 0.5  # Base confidence
        
        # Adjust confidence based on historical data
        hist_samples = historical_insight.get("sample_count", 0)
        if hist_samples >= 5:
            # Good historical data -> higher confidence
            confidence += 0.2
        elif hist_samples >= 3:
            confidence += 0.1
        
        # Check for successful bypasses in history
        if historical_insight.get("successful_bypasses"):
            confidence += 0.15
        
        # Defense detected handling (IMPROVED)
        if category == "defense":
            # First: check memory for successful bypasses
            bypasses = historical_insight.get("successful_bypasses", [])
            if bypasses:
                best_bypass = bypasses[0]
                confidence += 0.1
                self._stats["modifications_recommended"] += 1
                return {
                    "decision": "modify_approach",
                    "reasoning": f"Historical bypass found: {best_bypass.get('module_id')}",
                    "new_module": best_bypass.get("module_id"),
                    "modified_parameters": {"use_evasion": True},
                    "confidence": confidence,
                    "source": "historical_memory"
                }, confidence
            
            # Second: check Nuclei alternatives
            nuclei_alts = context.get("nuclei_alternatives", {})
            if nuclei_alts.get("alternative_approaches"):
                best_approach = nuclei_alts["alternative_approaches"][0]
                confidence += 0.05
                self._stats["modifications_recommended"] += 1
                return {
                    "decision": "modify_approach",
                    "reasoning": f"Nuclei suggests: {best_approach.get('description')}",
                    "nuclei_approach": best_approach,
                    "confidence": confidence,
                    "source": "nuclei_knowledge"
                }, confidence
            
            # Third: KB alternatives
            if context.get("alternative_modules"):
                self._stats["modifications_recommended"] += 1
                return {
                    "decision": "modify_approach",
                    "reasoning": "KB alternative module available",
                    "new_module": context["alternative_modules"][0].get("rx_module_id"),
                    "confidence": confidence,
                    "source": "embedded_knowledge"
                }, confidence
            
            # No alternatives - low confidence
            confidence = 0.3
            return {
                "decision": "skip",
                "reasoning": "Defense detected, no alternatives found",
                "confidence": confidence,
                "source": "rule_based"
            }, confidence
        
        # Network issues - use historical success rate
        if category == "network":
            hist_rate = historical_insight.get("historical_success_rate", 0.5)
            
            # If history shows low success, don't waste retries
            if hist_rate < 0.2 and hist_samples >= 3:
                confidence = 0.7
                return {
                    "decision": "skip",
                    "reasoning": f"Historical success rate too low ({hist_rate:.0%})",
                    "confidence": confidence,
                    "source": "historical_memory"
                }, confidence
            
            if retry_count < max_retries:
                confidence = 0.6 + (hist_rate * 0.2)
                return {
                    "decision": "retry",
                    "reasoning": f"Network issue - retry {retry_count + 1}/{max_retries}",
                    "delay_seconds": strategy["retry_delay"],
                    "confidence": confidence,
                    "source": "rule_based"
                }, confidence
        
        # Authentication - check if we have better creds in memory
        if category == "authentication":
            if retry_count < max_retries:
                confidence = 0.5
                return {
                    "decision": "retry",
                    "reasoning": "Auth failed - may be transient",
                    "confidence": confidence,
                    "source": "rule_based"
                }, confidence
            else:
                # Suggest credential harvesting
                confidence = 0.6
                return {
                    "decision": "modify_approach",
                    "reasoning": "Need different credentials",
                    "modified_parameters": {"harvest_more_creds": True},
                    "confidence": confidence,
                    "source": "rule_based"
                }, confidence
        
        # Vulnerability patched
        if category == "vulnerability":
            # Before skipping, check if Nuclei suggests recon
            nuclei_alts = context.get("nuclei_alternatives", {})
            recon_approaches = [
                a for a in nuclei_alts.get("alternative_approaches", [])
                if a.get("type") == "reconnaissance"
            ]
            
            if recon_approaches:
                confidence = 0.55
                return {
                    "decision": "modify_approach",
                    "reasoning": "Patched - suggest additional recon",
                    "nuclei_approach": recon_approaches[0],
                    "confidence": confidence,
                    "source": "nuclei_knowledge"
                }, confidence
            
            confidence = 0.75
            return {
                "decision": "skip",
                "reasoning": "Target appears patched",
                "confidence": confidence,
                "source": "rule_based"
            }, confidence
        
        # Unknown - low confidence, may need LLM
        confidence = 0.4
        return {
            "decision": "escalate",
            "reasoning": "Unknown error type",
            "confidence": confidence,
            "source": "rule_based"
        }, confidence
    
    def _should_escalate_to_llm(
        self,
        confidence: float,
        category: str,
        context: Dict,
        historical_insight: Dict
    ) -> bool:
        """
        ØªØ­Ø¯ÙŠØ¯ Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠØ¬Ø¨ ØªØµØ¹ÙŠØ¯ Ø§Ù„Ù‚Ø±Ø§Ø± Ø¥Ù„Ù‰ LLM
        
        LLM ÙŠÙØ³ØªØ¯Ø¹Ù‰ ÙÙ‚Ø· Ø¹Ù†Ø¯Ù…Ø§:
        1. Ø§Ù„Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø© (< 0.5)
        2. Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ Ù…Ø¹Ù‚Ø¯ (Ø¹Ø¯Ø© Ø¯ÙØ§Ø¹Ø§Øª)
        3. Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª ØªØ§Ø±ÙŠØ®ÙŠØ© ÙƒØ§ÙÙŠØ©
        """
        # Low confidence -> need LLM
        if confidence < self.LLM_ESCALATION_THRESHOLD:
            return True
        
        # Complex defense scenario
        defenses = context.get("detected_defenses", [])
        if len(defenses) > 2:
            return True
        
        # Many alternatives to choose from
        alternatives = context.get("alternative_modules", [])
        if len(alternatives) > 5:
            return True
        
        # Insufficient historical data and not a simple case
        samples = historical_insight.get("sample_count", 0)
        if samples < 3 and category in ("defense", "unknown"):
            return True
        
        return False
    
    def _merge_decisions(
        self,
        knowledge_decision: Dict,
        llm_decision: Dict,
        knowledge_confidence: float
    ) -> Dict:
        """
        Ø¯Ù…Ø¬ Ù‚Ø±Ø§Ø± Ø§Ù„Ù…Ø¹Ø±ÙØ© ÙˆÙ‚Ø±Ø§Ø± LLM
        
        Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯:
        - Ø¥Ø°Ø§ Ø§ØªÙÙ‚Ø§ -> Ø§Ø³ØªØ®Ø¯Ù… LLM (Ø£ÙƒØ«Ø± ØªÙØµÙŠÙ„Ø§Ù‹)
        - Ø¥Ø°Ø§ Ø§Ø®ØªÙ„ÙØ§ + knowledge_confidence > 0.6 -> Ø§Ø³ØªØ®Ø¯Ù… Knowledge
        - Ø¥Ø°Ø§ Ø§Ø®ØªÙ„ÙØ§ + knowledge_confidence <= 0.6 -> Ø§Ø³ØªØ®Ø¯Ù… LLM
        """
        knowledge_action = knowledge_decision.get("decision")
        llm_action = llm_decision.get("decision")
        
        # If they agree, use LLM decision (more detailed)
        if knowledge_action == llm_action:
            final = llm_decision.copy()
            final["merged"] = True
            final["agreement"] = True
            return final
        
        # If they disagree, use confidence to decide
        if knowledge_confidence > 0.6:
            self.logger.info(
                f"[MERGE] Decisions differ: Knowledge={knowledge_action}, LLM={llm_action}. "
                f"Using Knowledge (confidence={knowledge_confidence:.2f})"
            )
            final = knowledge_decision.copy()
            final["merged"] = True
            final["llm_suggestion"] = llm_action
            return final
        else:
            self.logger.info(
                f"[MERGE] Decisions differ: Knowledge={knowledge_action}, LLM={llm_action}. "
                f"Using LLM (knowledge_confidence={knowledge_confidence:.2f})"
            )
            final = llm_decision.copy()
            final["merged"] = True
            final["knowledge_suggestion"] = knowledge_action
            return final
    
    async def _record_decision_to_memory(
        self,
        task: Dict,
        decision: Dict,
        context: Dict
    ) -> None:
        """ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù‚Ø±Ø§Ø± Ù„Ù„ØªØ¹Ù„Ù… Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠ"""
        # Note: The outcome will be recorded separately when we know if it succeeded
        # This just logs the decision for analysis
        if self.blackboard and self._current_mission_id:
            await self.blackboard.log_result(
                self._current_mission_id,
                "decision_made",
                {
                    "task_id": task.get("id"),
                    "decision": decision.get("decision"),
                    "confidence": decision.get("confidence"),
                    "source": decision.get("source"),
                    "merged": decision.get("merged", False)
                }
            )
```

---

### 4. ØªØ­Ø³ÙŠÙ† AttackSpecialist Ù…Ø¹ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ©

**Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¹Ù„Ù‰:** `src/specialists/attack.py`

```python
# ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¹Ù„Ù‰ AttackSpecialist

class AttackSpecialist(BaseSpecialist):
    
    @property
    def memory(self) -> OperationalMemory:
        """Get operational memory instance"""
        if not hasattr(self, '_memory') or self._memory is None:
            from ..core.memory.operational import get_operational_memory
            self._memory = get_operational_memory(self.blackboard)
        return self._memory
    
    async def _get_dynamic_exploit_success_rate(
        self,
        vuln_type: str,
        rx_module: Optional[Dict[str, Any]] = None
    ) -> float:
        """
        Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ù†Ø¬Ø§Ø­ Ø§Ù„Ø§Ø³ØªØºÙ„Ø§Ù„ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Ù‹
        
        Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©:
        1. Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ© Ù…Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ© (Ø§Ù„Ø£ÙƒØ«Ø± Ù…ÙˆØ«ÙˆÙ‚ÙŠØ©)
        2. Ø¨ÙŠØ§Ù†Ø§Øª Knowledge Base
        3. Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© (Ø§Ù„Ø£Ù‚Ù„ Ù…ÙˆØ«ÙˆÙ‚ÙŠØ©)
        """
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø§Ø³ØªØ´Ø§Ø±Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ© (Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ù‚ØµÙˆÙ‰)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        try:
            # Get target context
            target_os = "unknown"
            if hasattr(self, '_current_target_os'):
                target_os = self._current_target_os
            
            hist_rate, samples = await self.memory.get_historical_success_rate(
                action_type="EXPLOIT",
                target_context={"os": target_os, "vuln_type": vuln_type},
                defense_context=[]
            )
            
            if samples >= 5:
                # Strong historical data - use it directly
                self.logger.debug(
                    f"[MEMORY] Using historical rate for {vuln_type}: "
                    f"{hist_rate:.2f} (n={samples})"
                )
                return hist_rate
            elif samples >= 3:
                # Some data - blend with KB rate
                kb_rate = await self._get_kb_success_rate(vuln_type, rx_module)
                blended = (hist_rate * 0.6) + (kb_rate * 0.4)
                self.logger.debug(
                    f"[MEMORY] Blending rates: hist={hist_rate:.2f}, kb={kb_rate:.2f}, "
                    f"final={blended:.2f}"
                )
                return blended
        except Exception as e:
            self.logger.warning(f"Memory query failed: {e}")
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Ø§Ù„Ø®Ø·ÙˆØ© 2: Ø§Ø³ØªØ´Ø§Ø±Ø© Knowledge Base
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        return await self._get_kb_success_rate(vuln_type, rx_module)
    
    async def _get_kb_success_rate(
        self,
        vuln_type: str,
        rx_module: Optional[Dict[str, Any]]
    ) -> float:
        """Get success rate from Knowledge Base"""
        
        base_rate = 0.35  # Conservative default
        
        if rx_module:
            base_rate = 0.5  # Module exists in KB
            
            reliability = rx_module.get("reliability")
            if reliability == "high":
                base_rate = 0.70
            elif reliability == "medium":
                base_rate = 0.50
            elif reliability == "low":
                base_rate = 0.35
            
            # References boost
            refs = rx_module.get("references", [])
            if len(refs) >= 3:
                base_rate = min(base_rate + 0.08, 0.90)
            
            # Evasion support
            if rx_module.get("supports_evasion"):
                base_rate = min(base_rate + 0.05, 0.90)
        
        # Query KB for additional data
        if self.knowledge and self.knowledge.is_loaded():
            try:
                modules = self.knowledge.search_modules(query=vuln_type, limit=1)
                if modules:
                    cvss = modules[0].get("cvss", 5.0)
                    cvss_factor = min(cvss / 10.0, 0.95)
                    # Blend CVSS with base rate
                    base_rate = (base_rate * 0.7) + (cvss_factor * 0.3)
            except Exception:
                pass
        
        return round(base_rate, 2)
    
    async def _execute_exploit(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """
        ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØºÙ„Ø§Ù„ Ù…Ø¹ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù†ØªÙŠØ¬Ø© ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
        """
        # ... existing exploit logic ...
        
        result = await self._do_exploit(task)  # Original implementation
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù†ØªÙŠØ¬Ø© ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ©
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        try:
            target_info = await self._get_target_info(task.get("target_id"))
            vuln_info = await self._get_vuln_info(task.get("vuln_id"))
            
            await self.memory.record_outcome(
                action_type="EXPLOIT",
                module_id=task.get("rx_module"),
                target_context={
                    "os": target_info.get("os", "unknown") if target_info else "unknown",
                    "vuln_type": vuln_info.get("type") if vuln_info else "unknown"
                },
                defense_context=[],  # Would be populated if defenses detected
                result="success" if result.get("success") else "failed",
                error_category=result.get("error_context", {}).get("error_type"),
                mission_id=UUID(self._current_mission_id) if self._current_mission_id else None
            )
        except Exception as e:
            self.logger.warning(f"Failed to record outcome: {e}")
        
        return result
```

---

## ðŸ”„ Ù…Ø®Ø·Ø· Ø§Ù„ØªØ¯ÙÙ‚ Ø§Ù„Ù‡Ø¬ÙŠÙ†

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ØªØ¯ÙÙ‚ Ø§Ù„Ù‚Ø±Ø§Ø± Ø§Ù„Ù‡Ø¬ÙŠÙ†                              â”‚
â”‚                  Hybrid Decision Flow                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  Task/Event â”‚
       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 1. Query Operationalâ”‚
    â”‚    Memory           â”‚
    â”‚    (Historical Data)â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 2. Apply Embedded   â”‚
    â”‚    Knowledge Rules  â”‚
    â”‚    (Nuclei + MITRE) â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 3. Calculate        â”‚
    â”‚    Confidence Score â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
         â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
         â”‚         â”‚
    Conf > 0.6   Conf <= 0.6
         â”‚         â”‚
         â–¼         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Execute â”‚ â”‚ 4. Consult  â”‚
    â”‚ Decisionâ”‚ â”‚    LLM      â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
         â”‚            â”‚
         â”‚            â–¼
         â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚     â”‚ 5. Merge    â”‚
         â”‚     â”‚   Decisions â”‚
         â”‚     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
         â”‚            â”‚
         â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 6. Execute Action   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 7. Record Outcome   â”‚
    â”‚    to Memory        â”‚
    â”‚    (For Learning)   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ðŸ“Š Ù…Ù‚Ø§Ø±Ù†Ø©: Ù‚Ø¨Ù„ ÙˆØ¨Ø¹Ø¯

| Ø§Ù„Ø¬Ø§Ù†Ø¨ | Ù‚Ø¨Ù„ (Ø§Ù„Ø­Ø§Ù„ÙŠ) | Ø¨Ø¹Ø¯ (Ø§Ù„Ù‡Ø¬ÙŠÙ†) |
|--------|-------------|--------------|
| Ù…ØµØ¯Ø± Success Rate | `random.random()` + magic numbers | Historical Memory + KB + Fallback |
| Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªØ§Ø±ÙŠØ® | ÙŠÙÙƒØªØ¨ ÙˆÙ„Ø§ ÙŠÙÙ‚Ø±Ø£ | ÙŠÙÙ‚Ø±Ø£ ÙˆÙŠÙÙƒØªØ¨ (bidirectional) |
| LLM Usage | ~15% Ù…Ù† Ø§Ù„Ø­Ø§Ù„Ø§Øª | Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø© ÙÙ‚Ø· (confidence < 0.6) |
| Cross-Workspace | Ù„Ø§ ÙŠÙˆØ¬Ø¯ | IntelligenceCoordinator |
| ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ø¥Ø®ÙØ§Ù‚Ø§Øª | ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ | Memory-based learning |
| ØªÙƒÙ„ÙØ© LLM | Ø«Ø§Ø¨ØªØ© | Ù…ÙØ­Ø³Ù‘Ù†Ø© (Ø£Ù‚Ù„ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡Ø§Øª) |
| Ù…ÙˆØ«ÙˆÙ‚ÙŠØ© Ø§Ù„Ù‚Ø±Ø§Ø± | ØªØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ | ØªØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª |

---

## ðŸ“… Ø®Ø·Ø© Ø§Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ù…Ø±Ø­Ù„ÙŠØ©

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1: Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ÙŠØ© (Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 1-2)

```bash
# Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
src/core/memory/__init__.py
src/core/memory/operational.py

# Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª
src/specialists/attack.py  # Add memory integration
src/specialists/analysis.py  # Add memory integration
```

**Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª:**
- `tests/test_operational_memory.py`
- ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø© ØªÙØ­Ø³Ù‘Ù† Ø¯Ù‚Ø© Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2: ØªØ­Ø³ÙŠÙ† Ù…Ø­Ø±Ùƒ Ø§Ù„Ù‚Ø±Ø§Ø± (Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 2-3)

```bash
# Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª
src/specialists/analysis.py  # Hybrid decision engine
src/core/llm/prompts.py  # Add memory context to prompts
```

**Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª:**
- `tests/test_hybrid_decisions.py`
- Ù‚ÙŠØ§Ø³: LLM calls Ù‚Ø¨Ù„ ÙˆØ¨Ø¹Ø¯

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3: Ù…Ù†Ø³Ù‚ Ø§Ù„Ø°ÙƒØ§Ø¡ (Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 3-4)

```bash
# Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
src/core/intelligence/__init__.py
src/core/intelligence/coordinator.py

# Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª
src/specialists/base.py  # Add coordinator access
src/controller/mission.py  # Integrate coordinator
```

**Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª:**
- `tests/test_intelligence_coordinator.py`
- `tests/test_cross_workspace_correlation.py`

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 4: Ø§Ù„ØªÙƒØ§Ù…Ù„ ÙˆØ§Ù„ØªØ­Ø³ÙŠÙ† (Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 4-5)

- ØªÙƒØ§Ù…Ù„ Ø´Ø§Ù…Ù„
- Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª End-to-End
- Ù‚ÙŠØ§Ø³ Ø§Ù„Ø£Ø¯Ø§Ø¡
- ØªÙˆØ«ÙŠÙ‚

---

## ðŸ“ˆ Ù…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„Ù†Ø¬Ø§Ø­

1. **ØªÙ‚Ù„ÙŠÙ„ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡Ø§Øª LLM Ø¨Ù€ 40%** Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø¬ÙˆØ¯Ø© Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª
2. **Ø²ÙŠØ§Ø¯Ø© Ø¯Ù‚Ø© ØªÙˆÙ‚Ø¹ Success Rate Ø¨Ù€ 30%** (Ù…Ù‚Ø§Ø±Ù†Ø© Ø¨Ù€ random)
3. **ØªØ­Ø³ÙŠÙ† Cross-Workspace Correlation** - Ø§ÙƒØªØ´Ø§Ù ÙØ±Øµ lateral movement ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
4. **ØªÙ‚Ù„ÙŠÙ„ ØªÙƒØ±Ø§Ø± Ø§Ù„Ø¥Ø®ÙØ§Ù‚Ø§Øª** - Ø¹Ø¯Ù… ØªÙƒØ±Ø§Ø± Ù†ÙØ³ Ø§Ù„Ø®Ø·Ø£ Ù…Ø±ØªÙŠÙ†

---

## ðŸŽ¯ Ø§Ù„Ø®Ù„Ø§ØµØ©

Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø·Ø© ØªØ­Ù‚Ù‚ **"Ø¹Ø¯Ù… ÙÙ‚Ø¯Ø§Ù† Ø§Ù„ØºØ§ÙŠØ© ÙˆÙ„Ø§ Ø§Ù„ÙˆØ³ÙŠÙ„Ø©"**:

- **Ø§Ù„ØºØ§ÙŠØ© (LLM)**: ÙŠØ¨Ù‚Ù‰ Ù…ØªØ§Ø­Ø§Ù‹ Ù„Ù„Ù‚Ø±Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø©ØŒ Ù„ÙƒÙ† ÙŠÙØ³ØªØ¯Ø¹Ù‰ Ø¨Ø°ÙƒØ§Ø¡
- **Ø§Ù„ÙˆØ³ÙŠÙ„Ø© (Embedded Knowledge)**: ØªØ¨Ù‚Ù‰ Ø§Ù„Ø£Ø³Ø§Ø³ØŒ Ù…ÙØ¹Ø²Ø²Ø© Ø¨Ø°Ø§ÙƒØ±Ø© ØªØ´ØºÙŠÙ„ÙŠØ©
- **Ø§Ù„Ù†ØªÙŠØ¬Ø©**: Ù†Ø¸Ø§Ù… **Ù‡Ø¬ÙŠÙ†** ÙŠØ¬Ù…Ø¹ Ø¨ÙŠÙ† Ø³Ø±Ø¹Ø© Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ ÙˆØ°ÙƒØ§Ø¡ LLM
