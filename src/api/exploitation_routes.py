# ═══════════════════════════════════════════════════════════════
# RAGLOX v3.0 - Exploitation & C2 API Routes
# Real-time session management and exploitation monitoring
# ═══════════════════════════════════════════════════════════════

import logging
import time
import asyncio
from typing import Dict, List, Optional, Any
from fastapi import APIRouter, HTTPException, status, Depends, Request
from pydantic import BaseModel, Field, ValidationError
from functools import lru_cache

from ..core.exceptions import (
    RAGLOXException,
    ServiceUnavailableError,
    ExploitationException,
    ConnectionTimeoutError,
    sanitize_error_message,
)

logger = logging.getLogger("raglox.api.exploitation")


def handle_api_exception(e: Exception, operation: str) -> HTTPException:
    """
    Convert exceptions to appropriate HTTP responses.
    
    Args:
        e: The exception to handle
        operation: Description of the operation that failed
        
    Returns:
        HTTPException with appropriate status code
    """
    # Sanitize error message to remove sensitive data
    safe_message = sanitize_error_message(str(e))
    
    if isinstance(e, HTTPException):
        raise e
    elif isinstance(e, ValidationError):
        logger.warning(f"Validation error in {operation}: {safe_message}")
        return HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Validation error: {safe_message}"
        )
    elif isinstance(e, asyncio.TimeoutError):
        logger.warning(f"Timeout in {operation}: {safe_message}")
        return HTTPException(
            status_code=status.HTTP_504_GATEWAY_TIMEOUT,
            detail=f"Operation timed out: {operation}"
        )
    elif isinstance(e, (ConnectionError, OSError)):
        logger.error(f"Connection error in {operation}: {safe_message}")
        return HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=f"Service connection error: {operation}"
        )
    elif isinstance(e, RAGLOXException):
        logger.error(f"RAGLOX error in {operation}: {safe_message}")
        return HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    else:
        logger.exception(f"Unexpected error in {operation}")
        return HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal error during {operation}"
        )

# PERF-08: Response caching configuration
RESPONSE_CACHE_TTL = 60  # 60 seconds for status endpoints

# Simple TTL cache implementation for async functions
class TTLCache:
    """Simple TTL cache for async function results."""
    def __init__(self, ttl: int = 60):
        self.ttl = ttl
        self._cache: Dict[str, Any] = {}
        self._timestamps: Dict[str, float] = {}
    
    def get(self, key: str) -> Optional[Any]:
        if key in self._cache:
            if time.time() - self._timestamps.get(key, 0) < self.ttl:
                return self._cache[key]
            else:
                # Expired
                del self._cache[key]
                del self._timestamps[key]
        return None
    
    def set(self, key: str, value: Any):
        self._cache[key] = value
        self._timestamps[key] = time.time()
    
    def clear(self):
        self._cache.clear()
        self._timestamps.clear()

# Global caches for status endpoints
_metasploit_status_cache = TTLCache(ttl=RESPONSE_CACHE_TTL)
_exploitation_status_cache = TTLCache(ttl=RESPONSE_CACHE_TTL)
_exploit_stats_cache = TTLCache(ttl=RESPONSE_CACHE_TTL)

router = APIRouter(prefix="/exploitation", tags=["Exploitation"])


# ═══════════════════════════════════════════════════════════════
# Request/Response Models
# ═══════════════════════════════════════════════════════════════

class C2SessionInfo(BaseModel):
    """C2 Session information."""
    session_id: str
    target_host: str
    target_port: int
    session_type: str  # "ssh", "meterpreter", "shell", etc.
    status: str  # "active", "inactive", "error"
    created_at: str
    last_heartbeat: Optional[str] = None
    encryption_enabled: bool
    privilege_level: Optional[str] = None
    commands_executed: int = 0
    data_exfiltrated_bytes: int = 0


class C2CommandRequest(BaseModel):
    """Execute command on C2 session."""
    session_id: str = Field(..., description="Target C2 session ID")
    command: str = Field(..., description="Command to execute")
    timeout: int = Field(default=30, description="Command timeout in seconds")


class C2CommandResponse(BaseModel):
    """C2 command execution result."""
    success: bool
    session_id: str
    command: str
    output: Optional[str] = None
    error: Optional[str] = None
    execution_time: float
    timestamp: str


class ExploitStatusRequest(BaseModel):
    """Request exploit status."""
    exploit_id: Optional[str] = None
    target_id: Optional[str] = None


class ExploitStatusResponse(BaseModel):
    """Exploit execution status."""
    exploit_id: str
    target_id: str
    status: str  # "pending", "running", "success", "failed"
    exploit_type: str
    started_at: str
    completed_at: Optional[str] = None
    session_id: Optional[str] = None
    error: Optional[str] = None


class SessionProxyRequest(BaseModel):
    """Setup SOCKS proxy via session."""
    session_id: str
    proxy_port: int = Field(default=1080, description="Local SOCKS proxy port")
    proxy_type: str = Field(default="socks5", description="Proxy type: socks4/socks5")


class ExploitInfo(BaseModel):
    """Exploit metadata."""
    exploit_id: str
    name: str
    description: str
    cve_ids: List[str]
    platforms: List[str]
    targets: List[str]
    reliability: str
    exploit_type: str
    success_rate: float
    total_attempts: int = 0
    successful_attempts: int = 0


class PayloadRequest(BaseModel):
    """Generate custom payload."""
    payload_type: str = Field(..., description="meterpreter, reverse_shell, bind_shell, etc.")
    target_os: str = Field(..., description="windows, linux, macos")
    architecture: str = Field(default="x64", description="x86, x64, arm")
    lhost: str = Field(..., description="Listener host")
    lport: int = Field(..., description="Listener port")
    encoder: Optional[str] = Field(None, description="shikata_ga_nai, xor, etc.")
    iterations: int = Field(default=1, description="Encoding iterations")


class PayloadResponse(BaseModel):
    """Generated payload."""
    success: bool
    payload_type: str
    payload_data: str
    payload_size: int
    encoded: bool
    encoder: Optional[str] = None


class CredentialHarvestRequest(BaseModel):
    """Harvest credentials request."""
    session_id: str
    harvest_type: str = Field(..., description="mimikatz, lsass, sam, browsers")
    target_path: Optional[str] = None


class PortForwardRequest(BaseModel):
    """Port forwarding request."""
    session_id: str
    local_port: int
    remote_host: str
    remote_port: int


# ═══════════════════════════════════════════════════════════════
# C2 Session Management Endpoints
# ═══════════════════════════════════════════════════════════════

@router.get("/c2/sessions", response_model=List[C2SessionInfo])
async def list_c2_sessions(
    request: Request,
    mission_id: Optional[str] = None,
    status: Optional[str] = None
) -> List[C2SessionInfo]:
    """
    List all active C2 sessions.
    
    Args:
        mission_id: Filter by mission ID (optional)
        status: Filter by status: active/inactive/error (optional)
    
    Returns:
        List of C2 session information
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized. Enable USE_REAL_EXPLOITS=true"
            )
        
        # Get all sessions
        sessions = await c2_manager.list_sessions()
        
        # Apply filters
        if mission_id:
            sessions = [s for s in sessions if s.get('mission_id') == mission_id]
        if status:
            sessions = [s for s in sessions if s.get('status') == status]
        
        return [C2SessionInfo(**s) for s in sessions]
        
    except Exception as e:
        logger.error(f"Failed to list C2 sessions: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list C2 sessions: {str(e)}"
        )


@router.get("/c2/sessions/{session_id}", response_model=C2SessionInfo)
async def get_c2_session(
    request: Request,
    session_id: str
) -> C2SessionInfo:
    """
    Get detailed information about a specific C2 session.
    
    Args:
        session_id: C2 session ID
    
    Returns:
        C2 session information
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized"
            )
        
        session = await c2_manager.get_session(session_id)
        
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"C2 session {session_id} not found"
            )
        
        return C2SessionInfo(**session)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get C2 session: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get C2 session: {str(e)}"
        )


@router.post("/c2/sessions/{session_id}/execute", response_model=C2CommandResponse)
async def execute_c2_command(
    request: Request,
    session_id: str,
    command_request: C2CommandRequest
) -> C2CommandResponse:
    """
    Execute a command on a C2 session.
    
    Args:
        session_id: Target C2 session ID
        command_request: Command details
    
    Returns:
        Command execution result
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized"
            )
        
        # Execute command
        result = await c2_manager.execute_command(
            session_id=session_id,
            command=command_request.command,
            timeout=command_request.timeout
        )
        
        return C2CommandResponse(**result)
        
    except Exception as e:
        logger.error(f"Failed to execute command: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to execute command: {str(e)}"
        )


@router.delete("/c2/sessions/{session_id}")
async def terminate_c2_session(
    request: Request,
    session_id: str
) -> Dict[str, str]:
    """
    Terminate a C2 session.
    
    Args:
        session_id: C2 session ID to terminate
    
    Returns:
        Success message
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized"
            )
        
        await c2_manager.terminate_session(session_id)
        
        return {
            "status": "success",
            "message": f"C2 session {session_id} terminated"
        }
        
    except Exception as e:
        logger.error(f"Failed to terminate session: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to terminate session: {str(e)}"
        )


@router.post("/c2/sessions/{session_id}/proxy", response_model=Dict[str, Any])
async def setup_socks_proxy(
    request: Request,
    session_id: str,
    proxy_request: SessionProxyRequest
) -> Dict[str, Any]:
    """
    Setup SOCKS proxy through a C2 session for network pivoting.
    
    Args:
        session_id: C2 session to use for proxy
        proxy_request: Proxy configuration
    
    Returns:
        Proxy connection details
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized"
            )
        
        # Setup SOCKS proxy
        proxy_info = await c2_manager.setup_proxy(
            session_id=session_id,
            proxy_port=proxy_request.proxy_port,
            proxy_type=proxy_request.proxy_type
        )
        
        return {
            "status": "success",
            "proxy_type": proxy_request.proxy_type,
            "proxy_host": "127.0.0.1",
            "proxy_port": proxy_request.proxy_port,
            "session_id": session_id,
            "message": f"SOCKS proxy established on port {proxy_request.proxy_port}"
        }
        
    except Exception as e:
        logger.error(f"Failed to setup proxy: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to setup proxy: {str(e)}"
        )


# ═══════════════════════════════════════════════════════════════
# Exploitation Status & Monitoring
# ═══════════════════════════════════════════════════════════════

@router.get("/status/metasploit", response_model=Dict[str, Any])
async def get_metasploit_status(request: Request) -> Dict[str, Any]:
    """
    Get Metasploit RPC connection status.
    
    PERF-08: Response cached for 60 seconds.
    
    Returns:
        Metasploit connection and version information
    """
    # PERF-08: Check cache first
    cached = _metasploit_status_cache.get("status")
    if cached:
        return cached
    
    try:
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        use_real_exploits = getattr(request.app.state, 'use_real_exploits', False)
        
        if not use_real_exploits:
            result = {
                "status": "disabled",
                "message": "Real exploitation disabled. Set USE_REAL_EXPLOITS=true",
                "mode": "simulation"
            }
            _metasploit_status_cache.set("status", result)
            return result
        
        if not metasploit_adapter:
            result = {
                "status": "unavailable",
                "message": "Metasploit RPC adapter not initialized",
                "mode": "simulation"
            }
            _metasploit_status_cache.set("status", result)
            return result
        
        # Get Metasploit version and stats
        version = await metasploit_adapter.get_version()
        exploits = await metasploit_adapter.list_exploits()
        
        result = {
            "status": "connected",
            "mode": "real_exploitation",
            "version": version,
            "total_exploits": len(exploits) if exploits else 0,
            "connection": {
                "host": metasploit_adapter.host,
                "port": metasploit_adapter.port,
                "ssl": metasploit_adapter.ssl
            }
        }
        _metasploit_status_cache.set("status", result)
        return result
        
    except Exception as e:
        logger.error(f"Failed to get Metasploit status: {e}")
        return {
            "status": "error",
            "message": str(e),
            "mode": "simulation"
        }


@router.get("/status/exploitation", response_model=Dict[str, Any])
async def get_exploitation_status(request: Request) -> Dict[str, Any]:
    """
    Get overall exploitation framework status.
    
    Returns:
        Exploitation framework health and statistics
    """
    try:
        use_real_exploits = getattr(request.app.state, 'use_real_exploits', False)
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        return {
            "mode": "real_exploitation" if use_real_exploits else "simulation",
            "metasploit": {
                "enabled": use_real_exploits,
                "connected": metasploit_adapter is not None and await metasploit_adapter.is_connected()
            },
            "c2": {
                "enabled": c2_manager is not None,
                "active_sessions": len(await c2_manager.list_sessions()) if c2_manager else 0
            },
            "capabilities": {
                "real_exploits": use_real_exploits and metasploit_adapter is not None,
                "post_exploitation": c2_manager is not None,
                "network_pivoting": c2_manager is not None,
                "credential_harvesting": c2_manager is not None
            }
        }
        
    except Exception as e:
        logger.error(f"Failed to get exploitation status: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get exploitation status: {str(e)}"
        )


# ═══════════════════════════════════════════════════════════════
# Health Check
# ═══════════════════════════════════════════════════════════════

@router.get("/health", response_model=Dict[str, Any])
async def exploitation_health_check(request: Request) -> Dict[str, Any]:
    """
    Health check for exploitation framework.
    
    Returns:
        Health status of all exploitation components
    """
    try:
        use_real_exploits = getattr(request.app.state, 'use_real_exploits', False)
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        health = {
            "status": "healthy",
            "mode": "real_exploitation" if use_real_exploits else "simulation",
            "components": {}
        }
        
        # Check Metasploit
        if use_real_exploits and metasploit_adapter:
            try:
                connected = await metasploit_adapter.is_connected()
                health["components"]["metasploit"] = {
                    "status": "healthy" if connected else "unhealthy",
                    "connected": connected
                }
            except Exception as e:
                health["components"]["metasploit"] = {
                    "status": "unhealthy",
                    "error": str(e)
                }
                health["status"] = "degraded"
        
        # Check C2
        if c2_manager:
            try:
                sessions = await c2_manager.list_sessions()
                health["components"]["c2"] = {
                    "status": "healthy",
                    "active_sessions": len(sessions)
                }
            except Exception as e:
                health["components"]["c2"] = {
                    "status": "unhealthy",
                    "error": str(e)
                }
                health["status"] = "degraded"
        
        return health
        
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        return {
            "status": "unhealthy",
            "error": str(e)
        }


# ═══════════════════════════════════════════════════════════════
# Exploit Repository Endpoints
# ═══════════════════════════════════════════════════════════════

@router.get("/exploits", response_model=List[ExploitInfo])
async def list_exploits(
    request: Request,
    platform: Optional[str] = None,
    cve_id: Optional[str] = None,
    min_reliability: Optional[str] = None
) -> List[ExploitInfo]:
    """
    List all available exploits from ExploitRepository.
    
    Args:
        platform: Filter by platform (windows, linux, etc.)
        cve_id: Filter by CVE ID
        min_reliability: Minimum reliability (excellent, great, good, normal)
    
    Returns:
        List of exploit information
    """
    try:
        from ..exploitation.knowledge.exploit_repository import get_exploit_repository
        
        repo = get_exploit_repository()
        exploits = repo.query_exploits(
            platform=platform,
            cve_id=cve_id,
            min_reliability=min_reliability
        )
        
        return [ExploitInfo(**exploit.dict()) for exploit in exploits]
        
    except Exception as e:
        logger.error(f"Failed to list exploits: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list exploits: {str(e)}"
        )


@router.get("/exploits/{exploit_id}", response_model=ExploitInfo)
async def get_exploit(request: Request, exploit_id: str) -> ExploitInfo:
    """Get detailed information about a specific exploit."""
    try:
        from ..exploitation.knowledge.exploit_repository import get_exploit_repository
        
        repo = get_exploit_repository()
        exploit = repo.get_exploit(exploit_id)
        
        if not exploit:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Exploit {exploit_id} not found"
            )
        
        return ExploitInfo(**exploit.dict())
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get exploit: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get exploit: {str(e)}"
        )


@router.get("/exploits/cve/{cve_id}", response_model=List[ExploitInfo])
async def find_exploits_by_cve(request: Request, cve_id: str) -> List[ExploitInfo]:
    """Find exploits by CVE ID."""
    try:
        from ..exploitation.knowledge.exploit_repository import get_exploit_repository
        
        repo = get_exploit_repository()
        exploits = repo.query_exploits(cve_id=cve_id)
        
        return [ExploitInfo(**exploit.dict()) for exploit in exploits]
        
    except Exception as e:
        logger.error(f"Failed to find exploits by CVE: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to find exploits: {str(e)}"
        )


@router.get("/exploits/stats", response_model=Dict[str, Any])
async def get_exploit_stats(request: Request) -> Dict[str, Any]:
    """
    Get exploit repository statistics.
    
    PERF-08: Response cached for 60 seconds.
    """
    # PERF-08: Check cache first
    cached = _exploit_stats_cache.get("stats")
    if cached:
        return cached
    
    try:
        from ..exploitation.knowledge.exploit_repository import get_exploit_repository
        
        repo = get_exploit_repository()
        stats = repo.get_statistics()
        
        # Cache the result
        _exploit_stats_cache.set("stats", stats)
        
        return stats
        
    except Exception as e:
        logger.error(f"Failed to get exploit stats: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get exploit stats: {str(e)}"
        )


@router.delete("/cache/clear")
async def clear_response_caches() -> Dict[str, str]:
    """
    Clear all response caches.
    
    Use this endpoint to force fresh data retrieval.
    """
    _metasploit_status_cache.clear()
    _exploitation_status_cache.clear()
    _exploit_stats_cache.clear()
    
    return {
        "status": "success",
        "message": "All response caches cleared"
    }


# ═══════════════════════════════════════════════════════════════
# Payload Generation Endpoints
# ═══════════════════════════════════════════════════════════════

@router.post("/payloads/generate", response_model=PayloadResponse)
async def generate_payload(
    request: Request,
    payload_request: PayloadRequest
) -> PayloadResponse:
    """
    Generate a custom payload.
    
    Args:
        payload_request: Payload configuration
    
    Returns:
        Generated payload data
    """
    try:
        from ..exploitation.payloads.payload_generator import get_payload_generator
        
        generator = get_payload_generator()
        
        # Generate payload
        result = await generator.generate_payload(
            payload_type=payload_request.payload_type,
            lhost=payload_request.lhost,
            lport=payload_request.lport,
            target_os=payload_request.target_os,
            architecture=payload_request.architecture,
            encoder=payload_request.encoder,
            iterations=payload_request.iterations
        )
        
        return PayloadResponse(
            success=result.get("success", False),
            payload_type=payload_request.payload_type,
            payload_data=result.get("payload", ""),
            payload_size=len(result.get("payload", "")),
            encoded=payload_request.encoder is not None,
            encoder=payload_request.encoder
        )
        
    except Exception as e:
        logger.error(f"Failed to generate payload: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate payload: {str(e)}"
        )


@router.get("/payloads/types", response_model=List[str])
async def list_payload_types(request: Request) -> List[str]:
    """List available payload types."""
    return [
        "reverse_shell",
        "bind_shell",
        "meterpreter",
        "meterpreter_reverse_tcp",
        "meterpreter_bind_tcp",
        "meterpreter_reverse_https",
        "windows_shell",
        "linux_shell",
        "powershell",
        "shellcode"
    ]


# ═══════════════════════════════════════════════════════════════
# Post-Exploitation: Credential Harvesting
# ═══════════════════════════════════════════════════════════════

@router.post("/post-exploitation/harvest", response_model=Dict[str, Any])
async def harvest_credentials(
    request: Request,
    harvest_request: CredentialHarvestRequest
) -> Dict[str, Any]:
    """
    Harvest credentials from a compromised host.
    
    Args:
        harvest_request: Harvesting configuration
    
    Returns:
        Harvested credentials
    """
    try:
        from ..exploitation.post_exploitation.credential_harvester import CredentialHarvester
        
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not available"
            )
        
        harvester = CredentialHarvester(c2_manager=c2_manager)
        
        # Harvest based on type
        if harvest_request.harvest_type == "mimikatz":
            result = await harvester.run_mimikatz(harvest_request.session_id)
        elif harvest_request.harvest_type == "lsass":
            result = await harvester.dump_lsass(harvest_request.session_id)
        elif harvest_request.harvest_type == "sam":
            result = await harvester.dump_sam(harvest_request.session_id)
        elif harvest_request.harvest_type == "browsers":
            result = await harvester.extract_browser_credentials(harvest_request.session_id)
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid harvest type: {harvest_request.harvest_type}"
            )
        
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to harvest credentials: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to harvest credentials: {str(e)}"
        )


# ═══════════════════════════════════════════════════════════════
# Post-Exploitation: Network Pivoting
# ═══════════════════════════════════════════════════════════════

@router.post("/pivoting/port-forward", response_model=Dict[str, Any])
async def setup_port_forward(
    request: Request,
    forward_request: PortForwardRequest
) -> Dict[str, Any]:
    """Setup port forwarding through a compromised host."""
    try:
        from ..exploitation.post_exploitation.network_pivoting import NetworkPivoting
        
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not available"
            )
        
        pivoting = NetworkPivoting(c2_manager=c2_manager)
        
        result = await pivoting.setup_port_forward(
            session_id=forward_request.session_id,
            local_port=forward_request.local_port,
            remote_host=forward_request.remote_host,
            remote_port=forward_request.remote_port
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Failed to setup port forward: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to setup port forward: {str(e)}"
        )


@router.get("/pivoting/routes", response_model=List[Dict[str, Any]])
async def list_pivot_routes(request: Request, session_id: Optional[str] = None) -> List[Dict[str, Any]]:
    """List all active pivot routes."""
    try:
        from ..exploitation.post_exploitation.network_pivoting import NetworkPivoting
        
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        if not c2_manager:
            return []
        
        pivoting = NetworkPivoting(c2_manager=c2_manager)
        routes = await pivoting.list_routes(session_id=session_id)
        
        return routes
        
    except Exception as e:
        logger.error(f"Failed to list pivot routes: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list routes: {str(e)}"
        )


# ═══════════════════════════════════════════════════════════════
# Specific Exploit Execution Endpoints
# ═══════════════════════════════════════════════════════════════

@router.post("/exploits/eternalblue/execute", response_model=Dict[str, Any])
async def execute_eternalblue(
    request: Request,
    target_host: str,
    target_port: int = 445,
    lhost: Optional[str] = None,
    lport: int = 4444
) -> Dict[str, Any]:
    """
    Execute EternalBlue (MS17-010) exploit against target.
    
    Args:
        target_host: Target Windows host
        target_port: SMB port (default 445)
        lhost: Listener host for reverse shell
        lport: Listener port
    
    Returns:
        Exploit execution result
    """
    try:
        from ..exploitation.exploits.eternalblue import EternalBlueExploit
        from ..exploitation.adapters.metasploit_adapter import get_metasploit_adapter
        
        metasploit = get_metasploit_adapter()
        exploit = EternalBlueExploit(metasploit_adapter=metasploit)
        
        result = await exploit.execute(
            target_host=target_host,
            target_port=target_port,
            lhost=lhost or request.app.state.settings.lhost,
            lport=lport
        )
        
        return result
        
    except Exception as e:
        logger.error(f"EternalBlue exploit failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Exploit failed: {str(e)}"
        )


@router.post("/exploits/eternalblue/check", response_model=Dict[str, Any])
async def check_eternalblue(
    request: Request,
    target_host: str,
    target_port: int = 445
) -> Dict[str, Any]:
    """
    Check if target is vulnerable to EternalBlue.
    
    Args:
        target_host: Target Windows host
        target_port: SMB port (default 445)
    
    Returns:
        Vulnerability check result
    """
    try:
        from ..exploitation.exploits.eternalblue import EternalBlueExploit
        from ..exploitation.adapters.metasploit_adapter import get_metasploit_adapter
        
        metasploit = get_metasploit_adapter()
        exploit = EternalBlueExploit(metasploit_adapter=metasploit)
        
        result = await exploit.check_vulnerability(
            target_host=target_host,
            target_port=target_port
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Vulnerability check failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Check failed: {str(e)}"
        )


@router.post("/exploits/log4shell/execute", response_model=Dict[str, Any])
async def execute_log4shell(
    request: Request,
    target_url: str,
    target_port: int = 8080,
    lhost: Optional[str] = None,
    lport: int = 4444,
    jndi_payload: Optional[str] = None
) -> Dict[str, Any]:
    """
    Execute Log4Shell (CVE-2021-44228) exploit against target.
    
    Args:
        target_url: Target URL with Log4j
        target_port: Target port
        lhost: Listener host for reverse shell
        lport: Listener port
        jndi_payload: Custom JNDI payload (optional)
    
    Returns:
        Exploit execution result
    """
    try:
        from ..exploitation.exploits.log4shell import Log4ShellExploit
        from ..exploitation.adapters.metasploit_adapter import get_metasploit_adapter
        
        metasploit = get_metasploit_adapter()
        exploit = Log4ShellExploit(metasploit_adapter=metasploit)
        
        result = await exploit.execute(
            target_url=target_url,
            target_port=target_port,
            lhost=lhost or request.app.state.settings.lhost,
            lport=lport,
            jndi_payload=jndi_payload
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Log4Shell exploit failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Exploit failed: {str(e)}"
        )


@router.post("/exploits/log4shell/scan", response_model=Dict[str, Any])
async def scan_log4shell(
    request: Request,
    target_url: str
) -> Dict[str, Any]:
    """
    Scan target for Log4Shell vulnerability.
    
    Args:
        target_url: Target URL to scan
    
    Returns:
        Scan result with vulnerability status
    """
    try:
        from ..exploitation.exploits.log4shell import Log4ShellExploit
        from ..exploitation.adapters.metasploit_adapter import get_metasploit_adapter
        
        metasploit = get_metasploit_adapter()
        exploit = Log4ShellExploit(metasploit_adapter=metasploit)
        
        result = await exploit.scan_vulnerability(target_url=target_url)
        
        return result
        
    except Exception as e:
        logger.error(f"Log4Shell scan failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Scan failed: {str(e)}"
        )


# ═══════════════════════════════════════════════════════════════
# Metasploit Direct Interaction
# ═══════════════════════════════════════════════════════════════

@router.get("/metasploit/modules", response_model=List[str])
async def list_metasploit_modules(
    request: Request,
    module_type: Optional[str] = None
) -> List[str]:
    """
    List available Metasploit modules.
    
    Args:
        module_type: Filter by type (exploit, auxiliary, post, etc.)
    
    Returns:
        List of module names
    """
    try:
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        
        if not metasploit_adapter:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Metasploit adapter not available"
            )
        
        modules = await metasploit_adapter.list_modules(module_type=module_type)
        
        return modules
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to list Metasploit modules: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list modules: {str(e)}"
        )


@router.post("/metasploit/execute", response_model=Dict[str, Any])
async def execute_metasploit_module(
    request: Request,
    module_name: str,
    options: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Execute a Metasploit module with custom options.
    
    Args:
        module_name: Full module path (e.g., exploit/windows/smb/ms17_010_eternalblue)
        options: Module options (RHOSTS, RPORT, LHOST, LPORT, etc.)
    
    Returns:
        Execution result
    """
    try:
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        
        if not metasploit_adapter:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Metasploit adapter not available"
            )
        
        result = await metasploit_adapter.execute_module(
            module_name=module_name,
            options=options
        )
        
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to execute Metasploit module: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Module execution failed: {str(e)}"
        )
