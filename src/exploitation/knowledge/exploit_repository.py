"""
RAGLOX v3.0 - Exploit Repository (Knowledge Base)
In-memory repository for exploit metadata, patterns, and statistics.

Author: RAGLOX Team
Version: 3.0.0
"""

import asyncio
import logging
import json
from typing import Optional, Dict, Any, List, Set
from datetime import datetime
from dataclasses import dataclass, field, asdict
from pathlib import Path
from json import JSONDecodeError

logger = logging.getLogger("raglox.exploitation.knowledge.repository")


@dataclass
class ExploitMetadata:
    """Exploit metadata stored in Knowledge Base"""
    exploit_id: str
    name: str
    description: str
    cve_ids: List[str]
    platforms: List[str]
    targets: List[str]
    reliability: str  # excellent, good, fair, poor, experimental
    exploit_type: str  # remote, local, client_side, web
    
    # Metasploit integration
    metasploit_module: Optional[str] = None
    metasploit_rank: Optional[str] = None
    
    # Payloads
    default_payloads: List[str] = field(default_factory=list)
    compatible_payloads: List[str] = field(default_factory=list)
    
    # Requirements
    required_ports: List[int] = field(default_factory=list)
    required_services: List[str] = field(default_factory=list)
    required_privileges: str = "none"
    
    # Evasion
    evasion_techniques: List[str] = field(default_factory=list)
    stealth_level: str = "medium"  # very_high, high, medium, low, very_low
    
    # Statistics (runtime updated)
    total_attempts: int = 0
    successful_attempts: int = 0
    failed_attempts: int = 0
    avg_execution_time: float = 0.0
    last_updated: Optional[datetime] = None
    
    # Intelligence
    success_indicators: List[str] = field(default_factory=list)
    failure_indicators: List[str] = field(default_factory=list)
    defense_bypass_methods: List[str] = field(default_factory=list)
    
    # References
    references: List[str] = field(default_factory=list)
    mitre_attack_ids: List[str] = field(default_factory=list)
    
    @property
    def success_rate(self) -> float:
        """Calculate success rate"""
        if self.total_attempts == 0:
            return 0.0
        return self.successful_attempts / self.total_attempts
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        data = asdict(self)
        if self.last_updated:
            data["last_updated"] = self.last_updated.isoformat()
        data["success_rate"] = self.success_rate
        return data


class ExploitRepository:
    """
    In-Memory Exploit Knowledge Base
    
    Features:
    - Fast O(1) lookups by exploit_id and CVE
    - O(n) filtering by platform, OS, service
    - Runtime statistics updates
    - Persistent storage to disk
    - Thread-safe operations
    """
    
    def __init__(self, data_dir: Optional[str] = None):
        """
        Initialize Exploit Repository
        
        Args:
            data_dir: Directory for persistent storage
        """
        self.data_dir = Path(data_dir) if data_dir else Path("data/exploits")
        self.data_dir.mkdir(parents=True, exist_ok=True)
        
        # Core data structures (all in RAM)
        self._exploits: Dict[str, ExploitMetadata] = {}
        self._cve_to_exploits: Dict[str, List[str]] = {}
        self._platform_to_exploits: Dict[str, Set[str]] = {}
        self._service_to_exploits: Dict[str, Set[str]] = {}
        
        # Lock for thread safety
        self._lock = asyncio.Lock()
        
        logger.info("ExploitRepository initialized")
    
    async def load_exploits(self, file_path: Optional[str] = None):
        """
        Load exploits from JSON file into RAM
        
        Args:
            file_path: Path to exploits JSON file
        """
        if file_path is None:
            file_path = self.data_dir / "exploits.json"
        else:
            file_path = Path(file_path)
        
        if not file_path.exists():
            logger.warning(f"Exploits file not found: {file_path}")
            # Load built-in exploits
            await self._load_builtin_exploits()
            return
        
        logger.info(f"Loading exploits from {file_path}")
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Validate JSON schema
            if not isinstance(data, dict):
                logger.error(f"Invalid exploits file format: expected dict, got {type(data).__name__}")
                await self._load_builtin_exploits()
                return
            
            if "exploits" not in data:
                logger.error("Invalid exploits file: missing 'exploits' key")
                await self._load_builtin_exploits()
                return
            
            exploits_list = data.get("exploits", [])
            if not isinstance(exploits_list, list):
                logger.error(f"Invalid exploits format: expected list, got {type(exploits_list).__name__}")
                await self._load_builtin_exploits()
                return
            
            count = 0
            errors = 0
            for i, exploit_data in enumerate(exploits_list):
                try:
                    if not isinstance(exploit_data, dict):
                        logger.warning(f"Skipping invalid exploit entry at index {i}: expected dict")
                        errors += 1
                        continue
                    
                    # Validate required fields
                    required_fields = ["exploit_id", "name", "description", "cve_ids", "platforms", "targets", "reliability", "exploit_type"]
                    missing = [f for f in required_fields if f not in exploit_data]
                    if missing:
                        logger.warning(f"Skipping exploit at index {i}: missing fields {missing}")
                        errors += 1
                        continue
                    
                    await self.add_exploit(ExploitMetadata(**exploit_data))
                    count += 1
                except TypeError as e:
                    logger.warning(f"Invalid exploit data at index {i}: {e}")
                    errors += 1
                    continue
            
            logger.info(f"Loaded {count} exploits into Knowledge Base (skipped {errors} invalid entries)")
            
            # If no valid exploits loaded, fall back to built-in
            if count == 0:
                logger.warning("No valid exploits loaded from file, falling back to built-in exploits")
                await self._load_builtin_exploits()
            
        except JSONDecodeError as e:
            logger.error(f"Invalid JSON in exploits file: {e}")
            await self._load_builtin_exploits()
        except FileNotFoundError:
            logger.error(f"Exploits file not found: {file_path}")
            await self._load_builtin_exploits()
        except PermissionError as e:
            logger.error(f"Permission denied reading exploits file: {e}")
            await self._load_builtin_exploits()
        except UnicodeDecodeError as e:
            logger.error(f"Encoding error in exploits file: {e}")
            await self._load_builtin_exploits()
        except IOError as e:
            logger.error(f"I/O error reading exploits file: {e}")
            await self._load_builtin_exploits()
    
    async def _load_builtin_exploits(self):
        """Load built-in exploits (EternalBlue, BlueKeep, Log4Shell)"""
        logger.info("Loading built-in exploits")
        
        # EternalBlue (MS17-010)
        eternalblue = ExploitMetadata(
            exploit_id="ms17_010_eternalblue",
            name="EternalBlue",
            description="SMBv1 Remote Code Execution vulnerability",
            cve_ids=["CVE-2017-0144", "CVE-2017-0145"],
            platforms=["Windows"],
            targets=[
                "Windows 7 SP1",
                "Windows Server 2008 R2",
                "Windows 8.1",
                "Windows Server 2012"
            ],
            reliability="excellent",
            exploit_type="remote",
            metasploit_module="exploit/windows/smb/ms17_010_eternalblue",
            metasploit_rank="average",
            default_payloads=[
                "windows/x64/meterpreter/reverse_tcp",
                "windows/x64/shell/reverse_tcp"
            ],
            compatible_payloads=[
                "windows/x64/meterpreter/reverse_https",
                "windows/meterpreter/reverse_tcp"
            ],
            required_ports=[445],
            required_services=["SMB"],
            required_privileges="none",
            evasion_techniques=[
                "disable_nx",
                "heap_spray",
                "kernel_pool_grooming"
            ],
            stealth_level="medium",
            success_indicators=[
                "session_created",
                "smb_named_pipe",
                "kernel_shellcode_executed"
            ],
            failure_indicators=[
                "smb_connection_failed",
                "exploit_timeout",
                "target_not_vulnerable"
            ],
            defense_bypass_methods=[
                "ASLR bypass",
                "DEP bypass"
            ],
            references=[
                "https://docs.microsoft.com/security-updates/SecurityBulletins/2017/ms17-010",
                "https://www.exploit-db.com/exploits/42031"
            ],
            mitre_attack_ids=["T1210"]
        )
        await self.add_exploit(eternalblue)
        
        # BlueKeep (CVE-2019-0708)
        bluekeep = ExploitMetadata(
            exploit_id="cve_2019_0708_bluekeep",
            name="BlueKeep",
            description="RDP Remote Code Execution vulnerability",
            cve_ids=["CVE-2019-0708"],
            platforms=["Windows"],
            targets=[
                "Windows 7 SP1",
                "Windows Server 2008 R2",
                "Windows XP",
                "Windows Server 2003"
            ],
            reliability="good",
            exploit_type="remote",
            metasploit_module="exploit/windows/rdp/cve_2019_0708_bluekeep_rce",
            metasploit_rank="manual",
            default_payloads=[
                "windows/x64/meterpreter/reverse_tcp"
            ],
            required_ports=[3389],
            required_services=["RDP"],
            required_privileges="none",
            evasion_techniques=[
                "heap_manipulation",
                "kernel_stability_check"
            ],
            stealth_level="low",
            success_indicators=[
                "session_created",
                "rdp_exploit_successful"
            ],
            failure_indicators=[
                "rdp_connection_failed",
                "kernel_crash",
                "target_patched"
            ],
            references=[
                "https://portal.msrc.microsoft.com/security-guidance/advisory/CVE-2019-0708"
            ],
            mitre_attack_ids=["T1210"]
        )
        await self.add_exploit(bluekeep)
        
        # Log4Shell (CVE-2021-44228)
        log4shell = ExploitMetadata(
            exploit_id="cve_2021_44228_log4shell",
            name="Log4Shell",
            description="Log4j JNDI Remote Code Execution",
            cve_ids=["CVE-2021-44228"],
            platforms=["Linux", "Windows", "macOS"],
            targets=[
                "Apache Log4j 2.0-2.14.1",
                "Java applications"
            ],
            reliability="excellent",
            exploit_type="remote",
            metasploit_module="exploit/multi/http/log4shell_header_injection",
            default_payloads=[
                "linux/x64/meterpreter/reverse_tcp",
                "java/meterpreter/reverse_tcp"
            ],
            required_ports=[80, 443, 8080],
            required_services=["HTTP", "HTTPS"],
            required_privileges="none",
            evasion_techniques=[
                "jndi_obfuscation",
                "waf_bypass",
                "header_injection_variants"
            ],
            stealth_level="high",
            success_indicators=[
                "jndi_callback_received",
                "ldap_connection_established",
                "session_created"
            ],
            failure_indicators=[
                "jndi_blocked",
                "waf_detected",
                "no_callback"
            ],
            defense_bypass_methods=[
                "WAF evasion",
                "IDS signature bypass"
            ],
            references=[
                "https://nvd.nist.gov/vuln/detail/CVE-2021-44228",
                "https://www.lunasec.io/docs/blog/log4j-zero-day/"
            ],
            mitre_attack_ids=["T1190"]
        )
        await self.add_exploit(log4shell)
        
        logger.info("Built-in exploits loaded: EternalBlue, BlueKeep, Log4Shell")
    
    async def add_exploit(self, exploit: ExploitMetadata):
        """
        Add exploit to Knowledge Base
        
        Args:
            exploit: Exploit metadata
        """
        async with self._lock:
            # Store exploit
            self._exploits[exploit.exploit_id] = exploit
            
            # Index by CVE
            for cve_id in exploit.cve_ids:
                if cve_id not in self._cve_to_exploits:
                    self._cve_to_exploits[cve_id] = []
                self._cve_to_exploits[cve_id].append(exploit.exploit_id)
            
            # Index by platform
            for platform in exploit.platforms:
                platform_key = platform.lower()
                if platform_key not in self._platform_to_exploits:
                    self._platform_to_exploits[platform_key] = set()
                self._platform_to_exploits[platform_key].add(exploit.exploit_id)
            
            # Index by service
            for service in exploit.required_services:
                service_key = service.lower()
                if service_key not in self._service_to_exploits:
                    self._service_to_exploits[service_key] = set()
                self._service_to_exploits[service_key].add(exploit.exploit_id)
        
        logger.debug(f"Added exploit to KB: {exploit.name}")
    
    async def query_exploits(
        self,
        cve_id: Optional[str] = None,
        platform: Optional[str] = None,
        target_os_version: Optional[str] = None,
        architecture: Optional[str] = None,
        service: Optional[str] = None,
        min_reliability: Optional[str] = None
    ) -> List[ExploitMetadata]:
        """
        Query exploits from Knowledge Base
        
        Args:
            cve_id: CVE identifier
            platform: Target platform
            target_os_version: Specific OS version
            architecture: CPU architecture
            service: Required service
            min_reliability: Minimum reliability level
        
        Returns:
            List of matching exploits
        """
        async with self._lock:
            candidates = []
            
            # Fast CVE lookup
            if cve_id and cve_id in self._cve_to_exploits:
                exploit_ids = self._cve_to_exploits[cve_id]
                candidates = [self._exploits[eid] for eid in exploit_ids]
            # Platform lookup
            elif platform and platform.lower() in self._platform_to_exploits:
                exploit_ids = self._platform_to_exploits[platform.lower()]
                candidates = [self._exploits[eid] for eid in exploit_ids]
            # Service lookup
            elif service and service.lower() in self._service_to_exploits:
                exploit_ids = self._service_to_exploits[service.lower()]
                candidates = [self._exploits[eid] for eid in exploit_ids]
            else:
                # Full scan
                candidates = list(self._exploits.values())
            
            # Filter by target OS version
            if target_os_version:
                candidates = [
                    e for e in candidates
                    if any(target_os_version in target for target in e.targets)
                ]
            
            # Filter by reliability
            if min_reliability:
                reliability_order = ["excellent", "good", "fair", "poor", "experimental"]
                min_index = reliability_order.index(min_reliability)
                candidates = [
                    e for e in candidates
                    if reliability_order.index(e.reliability) <= min_index
                ]
            
            # Sort by success rate
            candidates.sort(key=lambda e: e.success_rate, reverse=True)
            
            return candidates
    
    async def get_exploit(self, exploit_id: str) -> Optional[ExploitMetadata]:
        """Get exploit by ID"""
        async with self._lock:
            return self._exploits.get(exploit_id)
    
    async def update_exploit_stats(
        self,
        exploit_id: str,
        success: bool,
        duration: Optional[float] = None
    ):
        """
        Update exploit statistics
        
        Args:
            exploit_id: Exploit ID
            success: Whether exploit succeeded
            duration: Execution duration
        """
        async with self._lock:
            if exploit_id not in self._exploits:
                return
            
            exploit = self._exploits[exploit_id]
            exploit.total_attempts += 1
            
            if success:
                exploit.successful_attempts += 1
            else:
                exploit.failed_attempts += 1
            
            # Update average execution time
            if duration is not None:
                if exploit.avg_execution_time == 0:
                    exploit.avg_execution_time = duration
                else:
                    # Moving average
                    exploit.avg_execution_time = (
                        (exploit.avg_execution_time * (exploit.total_attempts - 1) + duration)
                        / exploit.total_attempts
                    )
            
            exploit.last_updated = datetime.utcnow()
    
    def count_exploits(self) -> int:
        """Get total number of exploits"""
        return len(self._exploits)
    
    async def save_to_disk(self, file_path: Optional[str] = None):
        """
        Save exploits to disk
        
        Args:
            file_path: Path to save file
        """
        if file_path is None:
            file_path = self.data_dir / "exploits.json"
        else:
            file_path = Path(file_path)
        
        async with self._lock:
            data = {
                "version": "3.0.0",
                "last_updated": datetime.utcnow().isoformat(),
                "total_exploits": len(self._exploits),
                "exploits": [e.to_dict() for e in self._exploits.values()]
            }
        
        try:
            with open(file_path, 'w') as f:
                json.dump(data, f, indent=2)
            logger.info(f"Saved {len(self._exploits)} exploits to {file_path}")
        except Exception as e:
            logger.error(f"Failed to save exploits: {str(e)}")
    
    async def health_check(self) -> bool:
        """Check if repository is healthy"""
        return len(self._exploits) > 0
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get repository statistics"""
        total_attempts = sum(e.total_attempts for e in self._exploits.values())
        total_success = sum(e.successful_attempts for e in self._exploits.values())
        
        return {
            "total_exploits": len(self._exploits),
            "total_cves": len(self._cve_to_exploits),
            "platforms": list(self._platform_to_exploits.keys()),
            "total_attempts": total_attempts,
            "total_successes": total_success,
            "overall_success_rate": total_success / total_attempts if total_attempts > 0 else 0.0
        }
