"""
RAGLOX v3.0 - Metasploit RPC Adapter
Enterprise-grade adapter for Metasploit Framework integration via msgpack-RPC.

Author: RAGLOX Team
Version: 3.0.0
"""

import asyncio
import logging
import msgpack
import socket
import ssl as ssl_module
from typing import Optional, Dict, Any, List
from datetime import datetime
from dataclasses import dataclass
from contextlib import asynccontextmanager
from pathlib import Path

# Optional aiofiles for async file I/O
try:
    import aiofiles
    HAS_AIOFILES = True
except ImportError:
    HAS_AIOFILES = False
    logging.getLogger(__name__).warning("aiofiles not installed - falling back to sync I/O")

logger = logging.getLogger("raglox.exploitation.adapters.metasploit")


@dataclass
class MetasploitSession:
    """Metasploit session representation"""
    session_id: str
    session_type: str  # meterpreter, shell, etc.
    target_host: str
    exploit_uuid: str
    created_at: datetime
    info: Dict[str, Any]
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "session_id": self.session_id,
            "session_type": self.session_type,
            "target_host": self.target_host,
            "exploit_uuid": self.exploit_uuid,
            "created_at": self.created_at.isoformat(),
            "info": self.info
        }


class MetasploitRPCError(Exception):
    """Metasploit RPC error"""
    pass


class MetasploitConnectionError(MetasploitRPCError):
    """Connection related errors"""
    pass


class MetasploitAuthenticationError(MetasploitRPCError):
    """Authentication related errors"""
    pass


class MetasploitTimeoutError(MetasploitRPCError):
    """Timeout related errors"""
    pass


class MetasploitAdapter:
    """
    Enterprise Metasploit Framework Adapter
    
    Features:
    - Msgpack-RPC communication
    - Connection pooling
    - Automatic reconnection
    - Session management
    - Exploit execution
    - Payload generation
    - Post-exploitation modules
    """
    
    def __init__(
        self,
        host: Optional[str] = None,
        port: Optional[int] = None,
        username: Optional[str] = None,
        password: Optional[str] = None,
        ssl: Optional[bool] = None,
        timeout: Optional[int] = None,
        max_retries: int = 3
    ):
        """
        Initialize Metasploit Adapter
        
        Args:
            host: Metasploit RPC server host
            port: Metasploit RPC server port
            username: RPC username
            password: RPC password
            ssl: Use SSL/TLS
            timeout: Connection timeout
            max_retries: Maximum connection retries
        """
        # Load from environment/config with sensible defaults
        import os
        self.host = host or os.getenv("MSF_RPC_HOST", "127.0.0.1")
        self.port = port or int(os.getenv("MSF_RPC_PORT", "55553"))
        self.username = username or os.getenv("MSF_RPC_USER", "msf")
        self.password = password or os.getenv("MSF_RPC_PASS", "msf")
        self.ssl = ssl if ssl is not None else os.getenv("MSF_RPC_SSL", "true").lower() == "true"
        self.timeout = timeout or int(os.getenv("MSF_RPC_TIMEOUT", "30"))
        self.max_retries = max_retries
        
        # Connection state
        self._socket: Optional[socket.socket] = None
        self._token: Optional[str] = None
        self._connected = False
        
        # Session tracking
        self._sessions: Dict[str, MetasploitSession] = {}
        
        # Lock for thread safety
        self._lock = asyncio.Lock()
        
        logger.info(f"MetasploitAdapter initialized: {host}:{port}")
    
    async def connect(self) -> bool:
        """
        Connect to Metasploit RPC server and authenticate
        
        Returns:
            True if connection successful
        """
        async with self._lock:
            if self._connected:
                logger.debug("Already connected to Metasploit")
                return True
            
            try:
                # Create socket connection
                self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self._socket.settimeout(self.timeout)
                
                if self.ssl:
                    context = ssl_module.create_default_context()
                    context.check_hostname = False
                    context.verify_mode = ssl_module.CERT_NONE
                    self._socket = context.wrap_socket(self._socket, server_hostname=self.host)
                
                self._socket.connect((self.host, self.port))
                
                # Authenticate
                auth_response = await self._call("auth.login", [self.username, self.password])
                
                if not auth_response or "result" not in auth_response:
                    raise MetasploitRPCError("Authentication failed")
                
                self._token = auth_response["result"]
                self._connected = True
                
                logger.info(f"Connected to Metasploit RPC: {self.host}:{self.port}")
                return True
                
            except socket.timeout as e:
                logger.error(f"Connection timeout to Metasploit {self.host}:{self.port}: {e}")
                await self.disconnect()
                return False
            except ConnectionRefusedError as e:
                logger.error(f"Connection refused to Metasploit {self.host}:{self.port}: {e}")
                await self.disconnect()
                return False
            except ssl_module.SSLError as e:
                logger.error(f"SSL error connecting to Metasploit: {e}")
                await self.disconnect()
                return False
            except OSError as e:
                logger.error(f"Network error connecting to Metasploit: {e}")
                await self.disconnect()
                return False
    
    async def disconnect(self):
        """Disconnect from Metasploit RPC"""
        async with self._lock:
            if self._socket:
                try:
                    self._socket.close()
                except (OSError, socket.error) as e:
                    logger.debug(f"Error closing socket: {e}")
                self._socket = None
            
            self._token = None
            self._connected = False
            logger.info("Disconnected from Metasploit")
    
    async def _call(self, method: str, params: List[Any]) -> Optional[Dict[str, Any]]:
        """
        Call Metasploit RPC method
        
        Args:
            method: RPC method name
            params: Method parameters
        
        Returns:
            RPC response
        """
        if not self._socket:
            raise MetasploitRPCError("Not connected to Metasploit")
        
        try:
            # Prepare request
            if self._token:
                params = [self._token] + params
            
            request = msgpack.packb([method, params])
            
            # Send request
            self._socket.sendall(request)
            
            # Receive response
            response_data = b""
            while True:
                chunk = self._socket.recv(4096)
                if not chunk:
                    break
                response_data += chunk
                
                # Try to unpack
                try:
                    response = msgpack.unpackb(response_data, raw=False)
                    return response
                except (msgpack.UnpackException, ValueError):
                    # Incomplete data, continue reading
                    continue
            
            return None
            
        except socket.timeout as e:
            logger.error(f"RPC call timeout: {method} - {e}")
            raise MetasploitTimeoutError(f"RPC call timeout: {method}")
        except (ConnectionResetError, BrokenPipeError) as e:
            logger.error(f"Connection lost during RPC call: {method} - {e}")
            self._connected = False
            raise MetasploitConnectionError(f"Connection lost: {e}")
        except (msgpack.PackException, msgpack.UnpackException) as e:
            logger.error(f"Msgpack serialization error: {method} - {e}")
            raise MetasploitRPCError(f"Serialization error: {e}")
        except OSError as e:
            logger.error(f"Network error during RPC call: {method} - {e}")
            raise MetasploitConnectionError(f"Network error: {e}")
    
    async def execute_exploit(
        self,
        module_path: str,
        target_host: str,
        target_port: int,
        payload: str,
        options: Optional[Dict[str, Any]] = None
    ) -> Optional[str]:
        """
        Execute Metasploit exploit
        
        Args:
            module_path: Exploit module path (e.g., exploit/windows/smb/ms17_010_eternalblue)
            target_host: Target IP address
            target_port: Target port
            payload: Payload module path
            options: Additional exploit options
        
        Returns:
            Exploit UUID if successful
        """
        if not self._connected:
            await self.connect()
        
        try:
            logger.info(f"Executing exploit: {module_path} against {target_host}:{target_port}")
            
            # Set exploit options
            exploit_options = {
                "RHOSTS": target_host,
                "RPORT": target_port,
                **(options or {})
            }
            
            # Execute exploit
            response = await self._call("module.execute", [
                "exploit",
                module_path,
                {
                    **exploit_options,
                    "PAYLOAD": payload
                }
            ])
            
            if not response or "result" not in response:
                logger.error(f"Exploit execution failed: {response}")
                return None
            
            exploit_uuid = response["result"].get("uuid")
            
            if exploit_uuid:
                logger.info(f"Exploit launched: UUID={exploit_uuid}")
                
                # Wait for session
                await asyncio.sleep(2)
                await self._check_for_sessions(exploit_uuid)
            
            return exploit_uuid
            
        except MetasploitRPCError:
            raise
        except (socket.timeout, asyncio.TimeoutError) as e:
            logger.error(f"Exploit execution timeout: {e}")
            return None
        except (ConnectionError, OSError) as e:
            logger.error(f"Network error during exploit: {e}")
            return None
    
    async def _check_for_sessions(self, exploit_uuid: str):
        """Check for new sessions created by exploit"""
        try:
            response = await self._call("session.list", [])
            
            if not response or "result" not in response:
                return
            
            sessions = response["result"]
            
            for session_id, session_info in sessions.items():
                if session_id not in self._sessions:
                    # New session
                    session = MetasploitSession(
                        session_id=session_id,
                        session_type=session_info.get("type", "unknown"),
                        target_host=session_info.get("target_host", "unknown"),
                        exploit_uuid=exploit_uuid,
                        created_at=datetime.utcnow(),
                        info=session_info
                    )
                    
                    self._sessions[session_id] = session
                    logger.info(f"New session created: {session_id} ({session.session_type})")
        
        except MetasploitRPCError as e:
            logger.error(f"Failed to check sessions: {e}")
        except (KeyError, TypeError) as e:
            logger.error(f"Invalid session data format: {e}")
    
    async def get_session(self, session_id: str) -> Optional[MetasploitSession]:
        """Get session by ID"""
        return self._sessions.get(session_id)
    
    async def list_sessions(self) -> List[MetasploitSession]:
        """List all active sessions"""
        # Refresh session list
        try:
            response = await self._call("session.list", [])
            if response and "result" in response:
                active_ids = set(response["result"].keys())
                
                # Remove dead sessions
                dead_sessions = [sid for sid in self._sessions if sid not in active_ids]
                for sid in dead_sessions:
                    del self._sessions[sid]
        except MetasploitRPCError as e:
            logger.debug(f"Could not refresh sessions: {e}")
        except (KeyError, TypeError) as e:
            logger.debug(f"Session data parsing error: {e}")
        
        return list(self._sessions.values())
    
    async def execute_shell_command(
        self,
        session_id: str,
        command: str
    ) -> Optional[str]:
        """
        Execute shell command in session
        
        Args:
            session_id: Session ID
            command: Command to execute
        
        Returns:
            Command output
        """
        try:
            response = await self._call("session.shell_write", [session_id, command + "\n"])
            
            if not response or "result" not in response:
                logger.error(f"Failed to execute command: {command}")
                return None
            
            # Wait for output
            await asyncio.sleep(1)
            
            # Read output
            output_response = await self._call("session.shell_read", [session_id])
            
            if output_response and "result" in output_response:
                return output_response["result"].get("data", "")
            
            return None
            
        except MetasploitRPCError as e:
            logger.error(f"Shell command execution error: {e}")
            return None
        except (asyncio.TimeoutError, socket.timeout) as e:
            logger.error(f"Shell command timeout: {e}")
            return None
    
    async def execute_meterpreter_command(
        self,
        session_id: str,
        command: str
    ) -> Optional[str]:
        """
        Execute Meterpreter command
        
        Args:
            session_id: Meterpreter session ID
            command: Meterpreter command
        
        Returns:
            Command output
        """
        try:
            response = await self._call("session.meterpreter_write", [session_id, command])
            
            if not response or "result" not in response:
                return None
            
            # Wait for output
            await asyncio.sleep(1)
            
            # Read output
            output_response = await self._call("session.meterpreter_read", [session_id])
            
            if output_response and "result" in output_response:
                return output_response["result"].get("data", "")
            
            return None
            
        except MetasploitRPCError as e:
            logger.error(f"Meterpreter command error: {e}")
            return None
        except (asyncio.TimeoutError, socket.timeout) as e:
            logger.error(f"Meterpreter command timeout: {e}")
            return None
    
    async def upload_file(
        self,
        session_id: str,
        local_path: str,
        remote_path: str
    ) -> bool:
        """
        Upload file to target
        
        Args:
            session_id: Session ID
            local_path: Local file path
            remote_path: Remote file path
        
        Returns:
            True if successful
        """
        try:
            # Validate local file exists
            local_file = Path(local_path)
            if not local_file.exists():
                logger.error(f"Local file not found: {local_path}")
                return False
            
            # Read local file - use async if available
            if HAS_AIOFILES:
                async with aiofiles.open(local_path, 'rb') as f:
                    file_data = await f.read()
            else:
                # Fallback to sync I/O (should be rare)
                with open(local_path, 'rb') as f:
                    file_data = f.read()
            
            # Upload via Meterpreter
            response = await self._call("session.meterpreter_run_single", [
                session_id,
                f"upload {local_path} {remote_path}"
            ])
            
            if response and "result" in response:
                logger.info(f"File uploaded: {local_path} -> {remote_path}")
                return True
            
            return False
            
        except FileNotFoundError as e:
            logger.error(f"Local file not found: {local_path}")
            return False
        except PermissionError as e:
            logger.error(f"Permission denied reading file: {local_path}")
            return False
        except MetasploitRPCError as e:
            logger.error(f"Upload RPC error: {e}")
            return False
        except IOError as e:
            logger.error(f"File I/O error during upload: {e}")
            return False
    
    async def download_file(
        self,
        session_id: str,
        remote_path: str,
        local_path: str
    ) -> bool:
        """
        Download file from target
        
        Args:
            session_id: Session ID
            remote_path: Remote file path
            local_path: Local file path
        
        Returns:
            True if successful
        """
        try:
            response = await self._call("session.meterpreter_run_single", [
                session_id,
                f"download {remote_path} {local_path}"
            ])
            
            if response and "result" in response:
                logger.info(f"File downloaded: {remote_path} -> {local_path}")
                return True
            
            return False
            
        except MetasploitRPCError as e:
            logger.error(f"Download RPC error: {e}")
            return False
        except (PermissionError, IOError) as e:
            logger.error(f"File I/O error during download: {e}")
            return False
    
    async def kill_session(self, session_id: str) -> bool:
        """
        Kill session
        
        Args:
            session_id: Session ID
        
        Returns:
            True if successful
        """
        try:
            response = await self._call("session.stop", [session_id])
            
            if session_id in self._sessions:
                del self._sessions[session_id]
            
            logger.info(f"Session killed: {session_id}")
            return True
            
        except MetasploitRPCError as e:
            logger.error(f"Failed to kill session: {e}")
            return False
        except KeyError:
            # Session not in our tracking, that's fine
            return True
    
    async def health_check(self) -> bool:
        """Check if Metasploit connection is healthy"""
        if not self._connected:
            return False
        
        try:
            response = await self._call("core.version", [])
            return response is not None
        except MetasploitRPCError as e:
            logger.debug(f"Health check failed: {e}")
            return False
        except (socket.timeout, asyncio.TimeoutError):
            logger.debug("Health check timeout")
            return False
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get adapter statistics"""
        return {
            "connected": self._connected,
            "host": self.host,
            "port": self.port,
            "active_sessions": len(self._sessions),
            "session_types": list(set(s.session_type for s in self._sessions.values()))
        }
    
    @asynccontextmanager
    async def session_context(self):
        """Context manager for automatic connection/disconnection"""
        try:
            await self.connect()
            yield self
        finally:
            await self.disconnect()


# Singleton instance
_metasploit_adapter: Optional[MetasploitAdapter] = None


def get_metasploit_adapter(
    host: Optional[str] = None,
    port: Optional[int] = None,
    username: Optional[str] = None,
    password: Optional[str] = None,
    ssl: Optional[bool] = None
) -> MetasploitAdapter:
    """
    Get singleton Metasploit adapter.
    
    On first call, creates adapter with provided or default params.
    Subsequent calls return the same instance (ignoring params).
    
    Args:
        host: Metasploit RPC host (default: from env MSF_RPC_HOST or 127.0.0.1)
        port: Metasploit RPC port (default: from env MSF_RPC_PORT or 55553)
        username: RPC username (default: from env MSF_RPC_USER or msf)
        password: RPC password (default: from env MSF_RPC_PASS or msf)
        ssl: Use SSL (default: from env MSF_RPC_SSL or true)
    
    Returns:
        MetasploitAdapter singleton instance
    """
    global _metasploit_adapter
    if _metasploit_adapter is None:
        _metasploit_adapter = MetasploitAdapter(
            host=host,
            port=port,
            username=username,
            password=password,
            ssl=ssl
        )
    return _metasploit_adapter


def reset_metasploit_adapter():
    """Reset singleton adapter (for testing)"""
    global _metasploit_adapter
    _metasploit_adapter = None
