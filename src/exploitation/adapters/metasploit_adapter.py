"""
RAGLOX v3.0 - Metasploit RPC Adapter
Enterprise-grade adapter for Metasploit Framework integration via msgpack-RPC.

Author: RAGLOX Team
Version: 3.0.0
"""

import asyncio
import logging
import msgpack
import socket
from typing import Optional, Dict, Any, List
from datetime import datetime
from dataclasses import dataclass
from contextlib import asynccontextmanager

logger = logging.getLogger("raglox.exploitation.adapters.metasploit")


@dataclass
class MetasploitSession:
    """Metasploit session representation"""
    session_id: str
    session_type: str  # meterpreter, shell, etc.
    target_host: str
    exploit_uuid: str
    created_at: datetime
    info: Dict[str, Any]
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "session_id": self.session_id,
            "session_type": self.session_type,
            "target_host": self.target_host,
            "exploit_uuid": self.exploit_uuid,
            "created_at": self.created_at.isoformat(),
            "info": self.info
        }


class MetasploitRPCError(Exception):
    """Metasploit RPC error"""
    pass


class MetasploitAdapter:
    """
    Enterprise Metasploit Framework Adapter
    
    Features:
    - Msgpack-RPC communication
    - Connection pooling
    - Automatic reconnection
    - Session management
    - Exploit execution
    - Payload generation
    - Post-exploitation modules
    """
    
    def __init__(
        self,
        host: str = "127.0.0.1",
        port: int = 55553,
        username: str = "msf",
        password: str = "msf",
        ssl: bool = True,
        timeout: int = 30,
        max_retries: int = 3
    ):
        """
        Initialize Metasploit Adapter
        
        Args:
            host: Metasploit RPC server host
            port: Metasploit RPC server port
            username: RPC username
            password: RPC password
            ssl: Use SSL/TLS
            timeout: Connection timeout
            max_retries: Maximum connection retries
        """
        self.host = host
        self.port = port
        self.username = username
        self.password = password
        self.ssl = ssl
        self.timeout = timeout
        self.max_retries = max_retries
        
        # Connection state
        self._socket: Optional[socket.socket] = None
        self._token: Optional[str] = None
        self._connected = False
        
        # Session tracking
        self._sessions: Dict[str, MetasploitSession] = {}
        
        # Lock for thread safety
        self._lock = asyncio.Lock()
        
        logger.info(f"MetasploitAdapter initialized: {host}:{port}")
    
    async def connect(self) -> bool:
        """
        Connect to Metasploit RPC server and authenticate
        
        Returns:
            True if connection successful
        """
        async with self._lock:
            if self._connected:
                logger.debug("Already connected to Metasploit")
                return True
            
            try:
                # Create socket connection
                self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self._socket.settimeout(self.timeout)
                
                if self.ssl:
                    import ssl as ssl_module
                    context = ssl_module.create_default_context()
                    context.check_hostname = False
                    context.verify_mode = ssl_module.CERT_NONE
                    self._socket = context.wrap_socket(self._socket, server_hostname=self.host)
                
                self._socket.connect((self.host, self.port))
                
                # Authenticate
                auth_response = await self._call("auth.login", [self.username, self.password])
                
                if not auth_response or "result" not in auth_response:
                    raise MetasploitRPCError("Authentication failed")
                
                self._token = auth_response["result"]
                self._connected = True
                
                logger.info(f"Connected to Metasploit RPC: {self.host}:{self.port}")
                return True
                
            except Exception as e:
                logger.error(f"Failed to connect to Metasploit: {str(e)}")
                await self.disconnect()
                return False
    
    async def disconnect(self):
        """Disconnect from Metasploit RPC"""
        async with self._lock:
            if self._socket:
                try:
                    self._socket.close()
                except:
                    pass
                self._socket = None
            
            self._token = None
            self._connected = False
            logger.info("Disconnected from Metasploit")
    
    async def _call(self, method: str, params: List[Any]) -> Optional[Dict[str, Any]]:
        """
        Call Metasploit RPC method
        
        Args:
            method: RPC method name
            params: Method parameters
        
        Returns:
            RPC response
        """
        if not self._socket:
            raise MetasploitRPCError("Not connected to Metasploit")
        
        try:
            # Prepare request
            if self._token:
                params = [self._token] + params
            
            request = msgpack.packb([method, params])
            
            # Send request
            self._socket.sendall(request)
            
            # Receive response
            response_data = b""
            while True:
                chunk = self._socket.recv(4096)
                if not chunk:
                    break
                response_data += chunk
                
                # Try to unpack
                try:
                    response = msgpack.unpackb(response_data, raw=False)
                    return response
                except:
                    continue
            
            return None
            
        except Exception as e:
            logger.error(f"RPC call failed: {method} - {str(e)}")
            raise MetasploitRPCError(f"RPC call failed: {str(e)}")
    
    async def execute_exploit(
        self,
        module_path: str,
        target_host: str,
        target_port: int,
        payload: str,
        options: Optional[Dict[str, Any]] = None
    ) -> Optional[str]:
        """
        Execute Metasploit exploit
        
        Args:
            module_path: Exploit module path (e.g., exploit/windows/smb/ms17_010_eternalblue)
            target_host: Target IP address
            target_port: Target port
            payload: Payload module path
            options: Additional exploit options
        
        Returns:
            Exploit UUID if successful
        """
        if not self._connected:
            await self.connect()
        
        try:
            logger.info(f"Executing exploit: {module_path} against {target_host}:{target_port}")
            
            # Set exploit options
            exploit_options = {
                "RHOSTS": target_host,
                "RPORT": target_port,
                **(options or {})
            }
            
            # Execute exploit
            response = await self._call("module.execute", [
                "exploit",
                module_path,
                {
                    **exploit_options,
                    "PAYLOAD": payload
                }
            ])
            
            if not response or "result" not in response:
                logger.error(f"Exploit execution failed: {response}")
                return None
            
            exploit_uuid = response["result"].get("uuid")
            
            if exploit_uuid:
                logger.info(f"Exploit launched: UUID={exploit_uuid}")
                
                # Wait for session
                await asyncio.sleep(2)
                await self._check_for_sessions(exploit_uuid)
            
            return exploit_uuid
            
        except Exception as e:
            logger.error(f"Exploit execution error: {str(e)}")
            return None
    
    async def _check_for_sessions(self, exploit_uuid: str):
        """Check for new sessions created by exploit"""
        try:
            response = await self._call("session.list", [])
            
            if not response or "result" not in response:
                return
            
            sessions = response["result"]
            
            for session_id, session_info in sessions.items():
                if session_id not in self._sessions:
                    # New session
                    session = MetasploitSession(
                        session_id=session_id,
                        session_type=session_info.get("type", "unknown"),
                        target_host=session_info.get("target_host", "unknown"),
                        exploit_uuid=exploit_uuid,
                        created_at=datetime.utcnow(),
                        info=session_info
                    )
                    
                    self._sessions[session_id] = session
                    logger.info(f"New session created: {session_id} ({session.session_type})")
        
        except Exception as e:
            logger.error(f"Failed to check sessions: {str(e)}")
    
    async def get_session(self, session_id: str) -> Optional[MetasploitSession]:
        """Get session by ID"""
        return self._sessions.get(session_id)
    
    async def list_sessions(self) -> List[MetasploitSession]:
        """List all active sessions"""
        # Refresh session list
        try:
            response = await self._call("session.list", [])
            if response and "result" in response:
                active_ids = set(response["result"].keys())
                
                # Remove dead sessions
                dead_sessions = [sid for sid in self._sessions if sid not in active_ids]
                for sid in dead_sessions:
                    del self._sessions[sid]
        except:
            pass
        
        return list(self._sessions.values())
    
    async def execute_shell_command(
        self,
        session_id: str,
        command: str
    ) -> Optional[str]:
        """
        Execute shell command in session
        
        Args:
            session_id: Session ID
            command: Command to execute
        
        Returns:
            Command output
        """
        try:
            response = await self._call("session.shell_write", [session_id, command + "\n"])
            
            if not response or "result" not in response:
                logger.error(f"Failed to execute command: {command}")
                return None
            
            # Wait for output
            await asyncio.sleep(1)
            
            # Read output
            output_response = await self._call("session.shell_read", [session_id])
            
            if output_response and "result" in output_response:
                return output_response["result"].get("data", "")
            
            return None
            
        except Exception as e:
            logger.error(f"Command execution error: {str(e)}")
            return None
    
    async def execute_meterpreter_command(
        self,
        session_id: str,
        command: str
    ) -> Optional[str]:
        """
        Execute Meterpreter command
        
        Args:
            session_id: Meterpreter session ID
            command: Meterpreter command
        
        Returns:
            Command output
        """
        try:
            response = await self._call("session.meterpreter_write", [session_id, command])
            
            if not response or "result" not in response:
                return None
            
            # Wait for output
            await asyncio.sleep(1)
            
            # Read output
            output_response = await self._call("session.meterpreter_read", [session_id])
            
            if output_response and "result" in output_response:
                return output_response["result"].get("data", "")
            
            return None
            
        except Exception as e:
            logger.error(f"Meterpreter command error: {str(e)}")
            return None
    
    async def upload_file(
        self,
        session_id: str,
        local_path: str,
        remote_path: str
    ) -> bool:
        """
        Upload file to target
        
        Args:
            session_id: Session ID
            local_path: Local file path
            remote_path: Remote file path
        
        Returns:
            True if successful
        """
        try:
            # Read local file
            with open(local_path, 'rb') as f:
                file_data = f.read()
            
            # Upload via Meterpreter
            response = await self._call("session.meterpreter_run_single", [
                session_id,
                f"upload {local_path} {remote_path}"
            ])
            
            if response and "result" in response:
                logger.info(f"File uploaded: {local_path} -> {remote_path}")
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"File upload error: {str(e)}")
            return False
    
    async def download_file(
        self,
        session_id: str,
        remote_path: str,
        local_path: str
    ) -> bool:
        """
        Download file from target
        
        Args:
            session_id: Session ID
            remote_path: Remote file path
            local_path: Local file path
        
        Returns:
            True if successful
        """
        try:
            response = await self._call("session.meterpreter_run_single", [
                session_id,
                f"download {remote_path} {local_path}"
            ])
            
            if response and "result" in response:
                logger.info(f"File downloaded: {remote_path} -> {local_path}")
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"File download error: {str(e)}")
            return False
    
    async def kill_session(self, session_id: str) -> bool:
        """
        Kill session
        
        Args:
            session_id: Session ID
        
        Returns:
            True if successful
        """
        try:
            response = await self._call("session.stop", [session_id])
            
            if session_id in self._sessions:
                del self._sessions[session_id]
            
            logger.info(f"Session killed: {session_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to kill session: {str(e)}")
            return False
    
    async def health_check(self) -> bool:
        """Check if Metasploit connection is healthy"""
        if not self._connected:
            return False
        
        try:
            response = await self._call("core.version", [])
            return response is not None
        except:
            return False
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get adapter statistics"""
        return {
            "connected": self._connected,
            "host": self.host,
            "port": self.port,
            "active_sessions": len(self._sessions),
            "session_types": list(set(s.session_type for s in self._sessions.values()))
        }
    
    @asynccontextmanager
    async def session_context(self):
        """Context manager for automatic connection/disconnection"""
        try:
            await self.connect()
            yield self
        finally:
            await self.disconnect()


# Singleton instance
_metasploit_adapter: Optional[MetasploitAdapter] = None


def get_metasploit_adapter() -> MetasploitAdapter:
    """Get singleton Metasploit adapter"""
    global _metasploit_adapter
    if _metasploit_adapter is None:
        _metasploit_adapter = MetasploitAdapter()
    return _metasploit_adapter
