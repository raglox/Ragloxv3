"""
RAGLOX v3.0 - Exploit Orchestrator
Enterprise-grade exploit selection and execution with intelligence integration.

Author: RAGLOX Team
Version: 3.0.0
"""

import asyncio
import logging
from typing import Optional, Dict, Any, List, Callable
from datetime import datetime
from enum import Enum

from .exploit_base import (
    ExploitBase,
    ExploitTarget,
    ExploitPayload,
    ExploitResult,
    ExploitStatus,
    ExploitType,
    ExploitReliability
)
from ..knowledge.exploit_repository import ExploitRepository
from ...core.intelligence_decision_engine import (
    IntelligenceDecisionEngine,
    DecisionType,
    DecisionContext
)
from ...core.retry_policy import RetryPolicy, CircuitBreaker
from ...core.operational_memory import OperationalMemory


logger = logging.getLogger("raglox.exploitation.orchestrator")


class SelectionStrategy(str, Enum):
    """Exploit selection strategy"""
    HIGHEST_SUCCESS_RATE = "highest_success_rate"
    MOST_RELIABLE = "most_reliable"
    FASTEST_EXECUTION = "fastest_execution"
    MOST_STEALTHY = "most_stealthy"
    INTELLIGENCE_RECOMMENDED = "intelligence_recommended"


class ExploitOrchestrator:
    """
    Enterprise Exploit Orchestrator
    
    Integrates with:
    - Knowledge Base (RAM): Exploit repository
    - Intelligence Engine: Decision-making
    - Operational Memory: Historical patterns
    - Circuit Breaker: Failure protection
    - Retry Policy: Automatic retries
    
    Responsibilities:
    - Query exploits from Knowledge Base
    - Consult Intelligence Engine for decisions
    - Select optimal exploit based on strategy
    - Execute with circuit breaker protection
    - Update Operational Memory with results
    - Provide real-time metrics
    """
    
    def __init__(
        self,
        knowledge_base: ExploitRepository,
        intelligence_engine: Optional[IntelligenceDecisionEngine] = None,
        operational_memory: Optional[OperationalMemory] = None,
        retry_policy: Optional[RetryPolicy] = None,
        circuit_breaker: Optional[CircuitBreaker] = None
    ):
        """
        Initialize Exploit Orchestrator
        
        Args:
            knowledge_base: RAM-based exploit repository
            intelligence_engine: Intelligence decision engine
            operational_memory: Historical success/failure patterns
            retry_policy: Retry policy for failed exploits
            circuit_breaker: Circuit breaker for protection
        """
        self.knowledge_base = knowledge_base
        self.intelligence_engine = intelligence_engine
        self.operational_memory = operational_memory
        self.retry_policy = retry_policy
        self.circuit_breaker = circuit_breaker
        
        # Registry of loaded exploit implementations
        self._exploit_registry: Dict[str, ExploitBase] = {}
        
        # Active exploits tracking
        self._active_exploits: Dict[str, ExploitBase] = {}
        
        # Statistics
        self._total_exploits = 0
        self._successful_exploits = 0
        self._failed_exploits = 0
        self._blocked_exploits = 0
        
        # Lock for thread safety
        self._lock = asyncio.Lock()
        
        logger.info("ExploitOrchestrator initialized")
    
    def register_exploit(
        self,
        exploit: ExploitBase,
        override: bool = False
    ):
        """
        Register an exploit implementation
        
        Args:
            exploit: Exploit instance
            override: Override existing registration
        """
        if exploit.exploit_id in self._exploit_registry and not override:
            logger.warning(
                f"Exploit {exploit.exploit_id} already registered, "
                "use override=True to replace"
            )
            return
        
        self._exploit_registry[exploit.exploit_id] = exploit
        logger.info(f"Registered exploit: {exploit.name} ({exploit.exploit_id})")
    
    async def query_available_exploits(
        self,
        target: ExploitTarget,
        strategy: SelectionStrategy = SelectionStrategy.INTELLIGENCE_RECOMMENDED
    ) -> List[Dict[str, Any]]:
        """
        Query available exploits from Knowledge Base
        
        Args:
            target: Target information
            strategy: Selection strategy
        
        Returns:
            List of available exploits with metadata
        """
        # Query Knowledge Base (RAM)
        exploits = await self.knowledge_base.query_exploits(
            cve_id=target.vulnerability_id,
            platform=target.os,
            target_os_version=target.os_version,
            architecture=target.architecture
        )
        
        # Enrich with operational memory data
        enriched_exploits = []
        for exploit_meta in exploits:
            # Get historical success rate
            success_rate = 0.0
            if self.operational_memory:
                success_rate = await self.operational_memory.get_success_rate(
                    exploit_id=exploit_meta.exploit_id,
                    target_profile={
                        "os": target.os,
                        "os_version": target.os_version,
                        "architecture": target.architecture
                    }
                )
            
            enriched_exploits.append({
                "exploit_id": exploit_meta.exploit_id,
                "name": exploit_meta.name,
                "cve_ids": exploit_meta.cve_ids,
                "reliability": exploit_meta.reliability,
                "historical_success_rate": success_rate,
                "platforms": exploit_meta.platforms,
                "metasploit_module": exploit_meta.metasploit_module,
                "execution_time_avg": exploit_meta.avg_execution_time,
                "stealth_level": exploit_meta.stealth_level,
                "available": exploit_meta.exploit_id in self._exploit_registry
            })
        
        # Sort by strategy
        if strategy == SelectionStrategy.HIGHEST_SUCCESS_RATE:
            enriched_exploits.sort(
                key=lambda e: e["historical_success_rate"],
                reverse=True
            )
        elif strategy == SelectionStrategy.MOST_RELIABLE:
            reliability_order = ["excellent", "good", "fair", "poor", "experimental"]
            enriched_exploits.sort(
                key=lambda e: reliability_order.index(e["reliability"])
            )
        elif strategy == SelectionStrategy.FASTEST_EXECUTION:
            enriched_exploits.sort(key=lambda e: e["execution_time_avg"])
        elif strategy == SelectionStrategy.MOST_STEALTHY:
            stealth_order = ["very_high", "high", "medium", "low", "very_low"]
            enriched_exploits.sort(
                key=lambda e: stealth_order.index(e["stealth_level"])
            )
        
        return enriched_exploits
    
    async def select_exploit(
        self,
        target: ExploitTarget,
        strategy: SelectionStrategy = SelectionStrategy.INTELLIGENCE_RECOMMENDED,
        mission_context: Optional[Dict[str, Any]] = None
    ) -> Optional[ExploitBase]:
        """
        Select optimal exploit using intelligence
        
        Args:
            target: Target information
            strategy: Selection strategy
            mission_context: Mission context for intelligence
        
        Returns:
            Selected exploit instance or None
        """
        # Query available exploits from Knowledge Base
        available_exploits = await self.query_available_exploits(target, strategy)
        
        if not available_exploits:
            logger.warning(
                f"No exploits available for target {target.ip_address} "
                f"(CVE: {target.vulnerability_id})"
            )
            return None
        
        # If intelligence engine available, consult it
        if self.intelligence_engine and strategy == SelectionStrategy.INTELLIGENCE_RECOMMENDED:
            # Build decision context
            context = DecisionContext(
                operation_type="exploit",
                target_id=target.target_id,
                vuln_id=target.vulnerability_id,
                technique_id=available_exploits[0]["exploit_id"],
                target_os=target.os,
                target_ip=target.ip_address,
                target_services=[target.service_name] if target.service_name else [],
                mission_id=mission_context.get("mission_id") if mission_context else None,
                goals=mission_context.get("goals", []) if mission_context else [],
                stealth_level=mission_context.get("stealth_level", "medium") if mission_context else "medium",
                strategic_score=0.0,  # Will be calculated by engine
                similar_operations=await self._get_similar_operations(target)
            )
            
            # Get intelligence decision
            decision = await self.intelligence_engine.evaluate_exploit(context)
            
            if decision.decision_type == DecisionType.SKIP:
                logger.warning(
                    f"Intelligence Engine recommends SKIP: {decision.reasoning}"
                )
                return None
            
            if decision.decision_type == DecisionType.REQUEST_APPROVAL:
                logger.info(
                    f"Intelligence Engine requires approval: {decision.reasoning}"
                )
                # In real system, this would trigger HITL approval
                # For now, we'll continue with the top exploit
            
            # Use intelligence-recommended exploit if available
            if decision.recommended_action:
                recommended_id = decision.recommended_action.get("exploit_id")
                if recommended_id:
                    # Find recommended exploit
                    for exploit_meta in available_exploits:
                        if exploit_meta["exploit_id"] == recommended_id:
                            if exploit_meta["available"]:
                                return self._exploit_registry[recommended_id]
                            break
        
        # Fallback: use first available exploit (already sorted by strategy)
        for exploit_meta in available_exploits:
            if exploit_meta["available"]:
                return self._exploit_registry[exploit_meta["exploit_id"]]
        
        logger.warning("No registered exploit implementation found")
        return None
    
    async def execute_exploit(
        self,
        target: ExploitTarget,
        payload: ExploitPayload,
        strategy: SelectionStrategy = SelectionStrategy.INTELLIGENCE_RECOMMENDED,
        mission_context: Optional[Dict[str, Any]] = None
    ) -> ExploitResult:
        """
        Execute exploit with full orchestration
        
        Args:
            target: Target information
            payload: Payload configuration
            strategy: Selection strategy
            mission_context: Mission context
        
        Returns:
            ExploitResult
        """
        self._total_exploits += 1
        
        # Select exploit
        exploit = await self.select_exploit(target, strategy, mission_context)
        
        if not exploit:
            ended_at = datetime.utcnow()
            return ExploitResult(
                exploit_id="none",
                status=ExploitStatus.FAILED,
                target=target,
                started_at=datetime.utcnow(),
                ended_at=ended_at,
                duration_seconds=0.0,
                error="No suitable exploit found"
            )
        
        logger.info(
            f"Executing exploit {exploit.name} against "
            f"{target.ip_address}:{target.port}"
        )
        
        # Track active exploit
        async with self._lock:
            self._active_exploits[exploit.exploit_id] = exploit
        
        try:
            # Execute with circuit breaker if available
            if self.circuit_breaker:
                result = await self.circuit_breaker.call(
                    exploit.run,
                    target,
                    payload
                )
            else:
                result = await exploit.run(target, payload)
            
            # Update statistics
            if result.success:
                self._successful_exploits += 1
            else:
                if result.status == ExploitStatus.BLOCKED:
                    self._blocked_exploits += 1
                else:
                    self._failed_exploits += 1
            
            # Update Operational Memory
            if self.operational_memory:
                if result.success:
                    await self.operational_memory.record_success(
                        exploit_id=exploit.exploit_id,
                        target_profile={
                            "os": target.os,
                            "os_version": target.os_version,
                            "architecture": target.architecture,
                            "service": target.service_name
                        },
                        technique=exploit.exploit_id,
                        duration_seconds=result.duration_seconds
                    )
                else:
                    await self.operational_memory.record_failure(
                        exploit_id=exploit.exploit_id,
                        target_profile={
                            "os": target.os,
                            "os_version": target.os_version
                        },
                        reason=result.error or "Unknown",
                        defenses_detected=result.indicators.get("defenses", [])
                    )
            
            # Update Knowledge Base statistics
            await self.knowledge_base.update_exploit_stats(
                exploit_id=exploit.exploit_id,
                success=result.success,
                duration=result.duration_seconds
            )
            
            return result
            
        finally:
            # Remove from active exploits
            async with self._lock:
                if exploit.exploit_id in self._active_exploits:
                    del self._active_exploits[exploit.exploit_id]
    
    async def _get_similar_operations(
        self,
        target: ExploitTarget
    ) -> List[Dict[str, Any]]:
        """Get similar operations from operational memory"""
        if not self.operational_memory:
            return []
        
        return await self.operational_memory.query_similar_operations(
            target_profile={
                "os": target.os,
                "os_version": target.os_version,
                "service": target.service_name
            },
            limit=5
        )
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get orchestrator statistics"""
        success_rate = 0.0
        if self._total_exploits > 0:
            success_rate = self._successful_exploits / self._total_exploits
        
        return {
            "total_exploits": self._total_exploits,
            "successful_exploits": self._successful_exploits,
            "failed_exploits": self._failed_exploits,
            "blocked_exploits": self._blocked_exploits,
            "success_rate": success_rate,
            "active_exploits": len(self._active_exploits),
            "registered_exploits": len(self._exploit_registry),
            "knowledge_base_exploits": self.knowledge_base.count_exploits()
        }
    
    async def health_check(self) -> Dict[str, bool]:
        """Check health of all components"""
        health = {
            "orchestrator": True,
            "knowledge_base": await self.knowledge_base.health_check(),
            "intelligence_engine": True,
            "operational_memory": True,
            "circuit_breaker": True
        }
        
        if self.intelligence_engine:
            # Add intelligence engine health check if available
            pass
        
        if self.circuit_breaker:
            health["circuit_breaker"] = self.circuit_breaker.is_closed()
        
        return health
