"""
RAGLOX v3.0 - Base Exploit Class
Abstract base for all exploit implementations with enterprise features.

Author: RAGLOX Team
Version: 3.0.0
"""

import asyncio
import logging
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any, List
from datetime import datetime
from enum import Enum
from dataclasses import dataclass, field
import uuid

logger = logging.getLogger("raglox.exploitation.base")


class ExploitStatus(str, Enum):
    """Exploit execution status"""
    PENDING = "pending"
    PREPARING = "preparing"
    EXECUTING = "executing"
    SUCCESS = "success"
    FAILED = "failed"
    TIMEOUT = "timeout"
    BLOCKED = "blocked"  # Blocked by defense mechanisms
    DEGRADED = "degraded"  # Partial success


class ExploitType(str, Enum):
    """Exploit type classification"""
    REMOTE = "remote"
    LOCAL = "local"
    CLIENT_SIDE = "client_side"
    WEB = "web"
    NETWORK = "network"


class ExploitReliability(str, Enum):
    """Exploit reliability rating"""
    EXCELLENT = "excellent"  # 90-100% success
    GOOD = "good"  # 70-90% success
    FAIR = "fair"  # 50-70% success
    POOR = "poor"  # <50% success
    EXPERIMENTAL = "experimental"  # Untested


@dataclass
class ExploitTarget:
    """Target information for exploit"""
    target_id: str
    ip_address: str
    port: int
    protocol: str = "tcp"
    os: Optional[str] = None
    os_version: Optional[str] = None
    architecture: Optional[str] = None
    service_name: Optional[str] = None
    service_version: Optional[str] = None
    vulnerability_id: Optional[str] = None  # CVE ID
    additional_info: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ExploitPayload:
    """Payload configuration"""
    payload_type: str  # e.g., "windows/meterpreter/reverse_tcp"
    lhost: str
    lport: int
    encoder: Optional[str] = None
    iterations: int = 1
    format: str = "raw"
    bad_chars: Optional[str] = None
    platform: Optional[str] = None
    arch: Optional[str] = None
    options: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ExploitResult:
    """Result of exploit execution"""
    exploit_id: str
    status: ExploitStatus
    target: ExploitTarget
    
    # Timing
    started_at: datetime
    ended_at: datetime
    duration_seconds: float
    
    # Results
    session_id: Optional[str] = None
    session_type: Optional[str] = None
    success: bool = False
    
    # Details
    output: str = ""
    error: Optional[str] = None
    warnings: List[str] = field(default_factory=list)
    
    # Metadata
    exploit_module: Optional[str] = None
    payload_used: Optional[str] = None
    retry_count: int = 0
    
    # Evidence
    artifacts: List[str] = field(default_factory=list)  # Files, screenshots, etc.
    indicators: Dict[str, Any] = field(default_factory=dict)  # IOCs
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "exploit_id": self.exploit_id,
            "status": self.status,
            "target": {
                "target_id": self.target.target_id,
                "ip_address": self.target.ip_address,
                "port": self.target.port,
                "vulnerability_id": self.target.vulnerability_id
            },
            "started_at": self.started_at.isoformat(),
            "ended_at": self.ended_at.isoformat(),
            "duration_seconds": self.duration_seconds,
            "session_id": self.session_id,
            "session_type": self.session_type,
            "success": self.success,
            "output": self.output[:1000],  # Truncate for response
            "error": self.error,
            "warnings": self.warnings,
            "exploit_module": self.exploit_module,
            "payload_used": self.payload_used,
            "retry_count": self.retry_count,
            "artifacts_count": len(self.artifacts),
            "indicators": self.indicators
        }


class ExploitBase(ABC):
    """
    Abstract base class for all exploit implementations.
    
    Provides enterprise-grade features:
    - Structured exploit lifecycle
    - Comprehensive error handling
    - Resource management
    - Audit logging
    - Metrics collection
    - Health checking
    """
    
    def __init__(
        self,
        exploit_id: str,
        name: str,
        description: str,
        cve_ids: List[str],
        exploit_type: ExploitType,
        reliability: ExploitReliability,
        platforms: List[str],
        references: List[str]
    ):
        """
        Initialize exploit base
        
        Args:
            exploit_id: Unique exploit identifier
            name: Human-readable exploit name
            description: Detailed description
            cve_ids: List of CVE IDs this exploit targets
            exploit_type: Type classification
            reliability: Reliability rating
            platforms: Supported platforms
            references: List of reference URLs
        """
        self.exploit_id = exploit_id
        self.name = name
        self.description = description
        self.cve_ids = cve_ids
        self.exploit_type = exploit_type
        self.reliability = reliability
        self.platforms = platforms
        self.references = references
        
        # Runtime state
        self._is_healthy = True
        self._execution_count = 0
        self._success_count = 0
        self._failure_count = 0
        self._last_execution: Optional[datetime] = None
        
        # Configuration
        self.timeout = 300  # Default 5 minutes
        self.max_retries = 3
        self.retry_delay = 5
        
        # Audit log
        self._audit_log: List[Dict[str, Any]] = []
    
    @abstractmethod
    async def check_prerequisites(self, target: ExploitTarget) -> bool:
        """
        Check if all prerequisites are met for exploit
        
        Args:
            target: Target information
        
        Returns:
            True if ready to exploit
        """
        pass
    
    @abstractmethod
    async def prepare(self, target: ExploitTarget, payload: ExploitPayload) -> bool:
        """
        Prepare exploit for execution
        
        Args:
            target: Target information
            payload: Payload configuration
        
        Returns:
            True if preparation successful
        """
        pass
    
    @abstractmethod
    async def execute(
        self,
        target: ExploitTarget,
        payload: ExploitPayload
    ) -> ExploitResult:
        """
        Execute the exploit
        
        Args:
            target: Target information
            payload: Payload configuration
        
        Returns:
            ExploitResult with execution details
        """
        pass
    
    @abstractmethod
    async def cleanup(self, target: ExploitTarget):
        """
        Cleanup after exploit execution
        
        Args:
            target: Target information
        """
        pass
    
    async def run(
        self,
        target: ExploitTarget,
        payload: ExploitPayload
    ) -> ExploitResult:
        """
        Complete exploit lifecycle with error handling
        
        Args:
            target: Target information
            payload: Payload configuration
        
        Returns:
            ExploitResult
        """
        execution_id = str(uuid.uuid4())
        started_at = datetime.utcnow()
        
        # Audit log
        self._audit_log.append({
            "timestamp": started_at.isoformat(),
            "action": "exploit_start",
            "execution_id": execution_id,
            "target_ip": target.ip_address,
            "cve_ids": self.cve_ids
        })
        
        self._execution_count += 1
        self._last_execution = started_at
        
        try:
            # Check prerequisites
            logger.info(
                f"Checking prerequisites for {self.name} "
                f"against {target.ip_address}:{target.port}"
            )
            
            if not await self.check_prerequisites(target):
                ended_at = datetime.utcnow()
                result = ExploitResult(
                    exploit_id=execution_id,
                    status=ExploitStatus.FAILED,
                    target=target,
                    started_at=started_at,
                    ended_at=ended_at,
                    duration_seconds=(ended_at - started_at).total_seconds(),
                    error="Prerequisites not met",
                    exploit_module=self.exploit_id
                )
                self._failure_count += 1
                return result
            
            # Prepare
            logger.info(f"Preparing exploit {self.name}")
            if not await self.prepare(target, payload):
                ended_at = datetime.utcnow()
                result = ExploitResult(
                    exploit_id=execution_id,
                    status=ExploitStatus.FAILED,
                    target=target,
                    started_at=started_at,
                    ended_at=ended_at,
                    duration_seconds=(ended_at - started_at).total_seconds(),
                    error="Preparation failed",
                    exploit_module=self.exploit_id
                )
                self._failure_count += 1
                return result
            
            # Execute with timeout
            logger.info(f"Executing exploit {self.name}")
            result = await asyncio.wait_for(
                self.execute(target, payload),
                timeout=self.timeout
            )
            
            # Update statistics
            if result.success:
                self._success_count += 1
            else:
                self._failure_count += 1
            
            # Audit log
            self._audit_log.append({
                "timestamp": datetime.utcnow().isoformat(),
                "action": "exploit_complete",
                "execution_id": execution_id,
                "status": result.status,
                "success": result.success,
                "session_id": result.session_id
            })
            
            return result
            
        except asyncio.TimeoutError:
            ended_at = datetime.utcnow()
            logger.error(f"Exploit {self.name} timed out after {self.timeout}s")
            self._failure_count += 1
            
            return ExploitResult(
                exploit_id=execution_id,
                status=ExploitStatus.TIMEOUT,
                target=target,
                started_at=started_at,
                ended_at=ended_at,
                duration_seconds=(ended_at - started_at).total_seconds(),
                error=f"Timeout after {self.timeout} seconds",
                exploit_module=self.exploit_id
            )
            
        except Exception as e:
            ended_at = datetime.utcnow()
            logger.error(f"Exploit {self.name} failed: {str(e)}", exc_info=True)
            self._failure_count += 1
            
            return ExploitResult(
                exploit_id=execution_id,
                status=ExploitStatus.FAILED,
                target=target,
                started_at=started_at,
                ended_at=ended_at,
                duration_seconds=(ended_at - started_at).total_seconds(),
                error=str(e),
                exploit_module=self.exploit_id
            )
            
        finally:
            # Always cleanup
            try:
                await self.cleanup(target)
            except Exception as e:
                logger.error(f"Cleanup failed for {self.name}: {str(e)}")
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get exploit statistics"""
        success_rate = 0.0
        if self._execution_count > 0:
            success_rate = self._success_count / self._execution_count
        
        return {
            "exploit_id": self.exploit_id,
            "name": self.name,
            "execution_count": self._execution_count,
            "success_count": self._success_count,
            "failure_count": self._failure_count,
            "success_rate": success_rate,
            "reliability": self.reliability,
            "last_execution": self._last_execution.isoformat() if self._last_execution else None,
            "is_healthy": self._is_healthy
        }
    
    def get_audit_log(self, limit: int = 100) -> List[Dict[str, Any]]:
        """Get audit log"""
        return self._audit_log[-limit:]
    
    async def health_check(self) -> bool:
        """Check if exploit is healthy"""
        # Can be overridden by subclasses
        return self._is_healthy
    
    def get_info(self) -> Dict[str, Any]:
        """Get exploit information"""
        return {
            "exploit_id": self.exploit_id,
            "name": self.name,
            "description": self.description,
            "cve_ids": self.cve_ids,
            "exploit_type": self.exploit_type,
            "reliability": self.reliability,
            "platforms": self.platforms,
            "references": self.references,
            "timeout": self.timeout,
            "max_retries": self.max_retries
        }
