"""
End-to-End Tests: Vulnerability Discovery and Knowledge Base
===========================================================

Tests vulnerability discovery workflows and knowledge base integration.
"""

import pytest
import asyncio
import httpx
from typing import Dict, Any
from datetime import datetime

from tests.production.base import ProductionE2ETestBase
from tests.production.config import get_config


@pytest.mark.e2e
@pytest.mark.asyncio
class TestVulnerabilityDiscoveryE2E(ProductionE2ETestBase):
    """End-to-end tests for vulnerability discovery"""

    async def test_e2e_vulnerability_discovery_workflow(
        self,
        real_api_client: httpx.AsyncClient,
        auth_headers: Dict[str, str]
    ):
        """
        Test 1: Complete vulnerability discovery workflow
        
        Flow:
        1. Create mission targeting known vulnerable host
        2. Start mission
        3. Wait for scanning phase
        4. Check for discovered vulnerabilities
        5. Verify vulnerability details
        6. Stop mission
        """
        print("\n" + "="*80)
        print("ğŸš€ Starting E2E Test: Vulnerability Discovery Workflow")
        print("="*80)
        
        config = get_config()
        
        # Target DVWA (Damn Vulnerable Web Application)
        print(f"\nğŸ¯ Targeting vulnerable host: {config.test_target_dvwa}")
        
        mission_data = {
            "name": self.generate_mission_name("E2E Vuln Discovery"),
            "description": "Test vulnerability discovery against DVWA",
            "scope": {
                "ip_ranges": [config.test_target_dvwa]
            },
            "goals": ["reconnaissance", "enumeration", "vulnerability_assessment"],
            "constraints": {
                "stealth": False,
                "no_exploit": True
            }
        }
        
        response = await real_api_client.post(
            "/api/v1/missions",
            json=mission_data,
            headers=auth_headers
        )
        assert response.status_code in [200, 201]
        
        mission = response.json()
        mission_id = mission.get("id") or mission.get("mission_id")
        print(f"âœ… Mission created: {mission_id}")
        
        try:
            # Start mission
            print("\nâ–¶ï¸  Starting mission...")
            await real_api_client.post(
                f"/api/v1/missions/{mission_id}/start",
                json={},
                headers=auth_headers
            )
            
            await self.wait_for_mission_status(
                real_api_client,
                auth_headers,
                mission_id,
                "running",
                timeout=60
            )
            print("âœ… Mission started")
            
            # Wait for scanning to progress
            print("\nâ³ Waiting for vulnerability scanning (90 seconds)...")
            await asyncio.sleep(90)
            
            # Check for vulnerabilities
            print("\nğŸ” Checking for discovered vulnerabilities...")
            response = await real_api_client.get(
                f"/api/v1/missions/{mission_id}/vulnerabilities",
                headers=auth_headers
            )
            
            if response.status_code == 200:
                vulnerabilities = response.json()
                
                # Handle different response formats
                if isinstance(vulnerabilities, dict):
                    vuln_list = vulnerabilities.get("vulnerabilities") or vulnerabilities.get("items", [])
                else:
                    vuln_list = vulnerabilities
                
                print(f"âœ… Found {len(vuln_list)} vulnerability/vulnerabilities")
                
                # Display vulnerability details
                if len(vuln_list) > 0:
                    print("\nğŸ“‹ Discovered Vulnerabilities:")
                    for i, vuln in enumerate(vuln_list[:5]):  # Show first 5
                        severity = vuln.get("severity", "unknown")
                        name = vuln.get("name") or vuln.get("title", "N/A")
                        cve = vuln.get("cve", "N/A")
                        
                        print(f"   {i+1}. [{severity}] {name}")
                        if cve != "N/A":
                            print(f"      CVE: {cve}")
                    
                    # Verify vulnerability structure
                    first_vuln = vuln_list[0]
                    assert "severity" in first_vuln or "risk" in first_vuln, \
                        "Vulnerability missing severity field"
                    print("\nâœ… Vulnerability structure verified")
                else:
                    print("âš ï¸  No vulnerabilities discovered yet (might need more time)")
            else:
                print(f"âš ï¸  Could not retrieve vulnerabilities: {response.status_code}")
            
            # Stop mission
            print("\nâ¹ï¸  Stopping mission...")
            await real_api_client.post(
                f"/api/v1/missions/{mission_id}/stop",
                json={},
                headers=auth_headers
            )
            
            print("\nâœ… E2E Test PASSED: Vulnerability Discovery Workflow")
            
        except Exception as e:
            print(f"\nâŒ Test FAILED: {str(e)}")
            try:
                await real_api_client.post(
                    f"/api/v1/missions/{mission_id}/stop",
                    json={},
                    headers=auth_headers
                )
            except:
                pass
            raise

    async def test_e2e_vulnerability_severity_filtering(
        self,
        real_api_client: httpx.AsyncClient,
        auth_headers: Dict[str, str]
    ):
        """
        Test 2: Filter vulnerabilities by severity
        
        Verifies API can filter vulnerabilities by severity level.
        """
        print("\n" + "="*80)
        print("ğŸš€ Starting E2E Test: Vulnerability Severity Filtering")
        print("="*80)
        
        config = get_config()
        
        mission_data = {
            "name": self.generate_mission_name("E2E Vuln Filter"),
            "description": "Test vulnerability filtering",
            "scope": {
                "ip_ranges": [config.test_target_dvwa]
            },
            "goals": ["vulnerability_assessment"]
        }
        
        response = await real_api_client.post(
            "/api/v1/missions",
            json=mission_data,
            headers=auth_headers
        )
        mission = response.json()
        mission_id = mission.get("id") or mission.get("mission_id")
        
        try:
            await real_api_client.post(
                f"/api/v1/missions/{mission_id}/start",
                json={},
                headers=auth_headers
            )
            
            await self.wait_for_mission_status(
                real_api_client,
                auth_headers,
                mission_id,
                "running",
                timeout=60
            )
            
            print("\nâ³ Waiting for scanning (60 seconds)...")
            await asyncio.sleep(60)
            
            # Get all vulnerabilities
            print("\nğŸ” Fetching all vulnerabilities...")
            response = await real_api_client.get(
                f"/api/v1/missions/{mission_id}/vulnerabilities",
                headers=auth_headers
            )
            
            if response.status_code == 200:
                all_vulns = response.json()
                if isinstance(all_vulns, dict):
                    all_vulns = all_vulns.get("vulnerabilities") or all_vulns.get("items", [])
                
                print(f"   Total vulnerabilities: {len(all_vulns)}")
                
                # Try filtering by severity
                for severity in ["critical", "high", "medium", "low"]:
                    response = await real_api_client.get(
                        f"/api/v1/missions/{mission_id}/vulnerabilities?severity={severity}",
                        headers=auth_headers
                    )
                    
                    if response.status_code == 200:
                        filtered_vulns = response.json()
                        if isinstance(filtered_vulns, dict):
                            filtered_vulns = filtered_vulns.get("vulnerabilities") or filtered_vulns.get("items", [])
                        
                        print(f"   {severity.capitalize()}: {len(filtered_vulns)}")
            
            await real_api_client.post(
                f"/api/v1/missions/{mission_id}/stop",
                json={},
                headers=auth_headers
            )
            
            print("\nâœ… E2E Test PASSED: Vulnerability Severity Filtering")
            
        except Exception as e:
            print(f"\nâŒ Test FAILED: {str(e)}")
            try:
                await real_api_client.post(
                    f"/api/v1/missions/{mission_id}/stop",
                    json={},
                    headers=auth_headers
                )
            except:
                pass
            raise


@pytest.mark.e2e
@pytest.mark.asyncio
class TestKnowledgeBaseE2E(ProductionE2ETestBase):
    """End-to-end tests for knowledge base integration"""

    async def test_e2e_knowledge_base_document_upload(
        self,
        real_api_client: httpx.AsyncClient,
        auth_headers: Dict[str, str]
    ):
        """
        Test 3: Knowledge base document upload
        
        Flow:
        1. Upload document to knowledge base
        2. Verify document stored
        3. Query document
        4. Verify retrieval
        """
        print("\n" + "="*80)
        print("ğŸš€ Starting E2E Test: Knowledge Base Document Upload")
        print("="*80)
        
        # Create test document
        print("\nğŸ“„ Creating test document...")
        document_data = {
            "title": f"Test Document {datetime.utcnow().isoformat()}",
            "content": """
            This is a test document for E2E testing.
            
            It contains information about common vulnerabilities:
            - SQL Injection: Occurs when user input is not properly sanitized
            - XSS: Cross-site scripting vulnerability
            - CSRF: Cross-site request forgery
            
            Always validate and sanitize user input.
            """,
            "tags": ["testing", "vulnerabilities", "security"],
            "category": "testing"
        }
        
        response = await real_api_client.post(
            "/api/v1/knowledge",
            json=document_data,
            headers=auth_headers
        )
        
        assert response.status_code in [200, 201], \
            f"Failed to upload document: {response.status_code}"
        
        document = response.json()
        document_id = document.get("id") or document.get("document_id")
        print(f"âœ… Document uploaded: {document_id}")
        
        try:
            # Verify document can be retrieved
            print("\nğŸ” Retrieving document...")
            response = await real_api_client.get(
                f"/api/v1/knowledge/{document_id}",
                headers=auth_headers
            )
            
            assert response.status_code == 200, \
                f"Failed to retrieve document: {response.status_code}"
            
            retrieved_doc = response.json()
            assert retrieved_doc.get("title") == document_data["title"]
            print("âœ… Document retrieved successfully")
            
            # Search knowledge base
            print("\nğŸ” Searching knowledge base...")
            response = await real_api_client.get(
                "/api/v1/knowledge/search?q=SQL+Injection",
                headers=auth_headers
            )
            
            if response.status_code == 200:
                search_results = response.json()
                if isinstance(search_results, dict):
                    results = search_results.get("results") or search_results.get("items", [])
                else:
                    results = search_results
                
                print(f"âœ… Found {len(results)} result(s)")
                
                # Verify our document is in results
                found = any(r.get("id") == document_id for r in results)
                if found:
                    print("âœ… Uploaded document found in search results")
                else:
                    print("âš ï¸  Document not in search results (indexing might be delayed)")
            
            print("\nâœ… E2E Test PASSED: Knowledge Base Document Upload")
            
        except Exception as e:
            print(f"\nâŒ Test FAILED: {str(e)}")
            raise

    async def test_e2e_knowledge_base_mission_integration(
        self,
        real_api_client: httpx.AsyncClient,
        auth_headers: Dict[str, str]
    ):
        """
        Test 4: Knowledge base integration with mission
        
        Verifies that mission can access and utilize knowledge base.
        """
        print("\n" + "="*80)
        print("ğŸš€ Starting E2E Test: Knowledge Base Mission Integration")
        print("="*80)
        
        # Create mission
        print("\nğŸ“ Creating mission...")
        mission_data = {
            "name": self.generate_mission_name("E2E KB Integration"),
            "description": "Test knowledge base integration",
            "scope": {
                "ip_ranges": ["192.168.100.0/24"]
            },
            "goals": ["reconnaissance"]
        }
        
        response = await real_api_client.post(
            "/api/v1/missions",
            json=mission_data,
            headers=auth_headers
        )
        mission = response.json()
        mission_id = mission.get("id") or mission.get("mission_id")
        
        try:
            # Ask mission chat about knowledge from KB
            print("\nğŸ’¬ Asking mission about SQL injection...")
            response = await real_api_client.post(
                f"/api/v1/missions/{mission_id}/chat",
                json={
                    "content": "What is SQL injection and how can it be exploited?",
                    "role": "user"
                },
                headers=auth_headers
            )
            
            assert response.status_code == 200
            chat_response = response.json()
            content = chat_response.get("content", "")
            
            print(f"âœ… Chat response received")
            print(f"   Length: {len(content)} characters")
            print(f"   Preview: {content[:200]}...")
            
            # Verify response contains relevant information
            sql_keywords = ["sql", "injection", "query", "database"]
            has_relevant_info = any(keyword in content.lower() for keyword in sql_keywords)
            
            if has_relevant_info:
                print("âœ… Response contains relevant SQL injection information")
            else:
                print("âš ï¸  Response might not have accessed knowledge base")
            
            print("\nâœ… E2E Test PASSED: Knowledge Base Mission Integration")
            
        except Exception as e:
            print(f"\nâŒ Test FAILED: {str(e)}")
            raise


@pytest.mark.e2e
@pytest.mark.asyncio
class TestReportGenerationE2E(ProductionE2ETestBase):
    """End-to-end tests for report generation"""

    async def test_e2e_mission_report_generation(
        self,
        real_api_client: httpx.AsyncClient,
        auth_headers: Dict[str, str]
    ):
        """
        Test 5: Mission report generation
        
        Flow:
        1. Create and run mission
        2. Stop mission
        3. Request report generation
        4. Verify report created
        5. Download and verify report
        """
        print("\n" + "="*80)
        print("ğŸš€ Starting E2E Test: Mission Report Generation")
        print("="*80)
        
        # Create mission
        mission_data = {
            "name": self.generate_mission_name("E2E Report Test"),
            "description": "Test report generation",
            "scope": {
                "ip_ranges": ["192.168.100.0/24"]
            },
            "goals": ["reconnaissance"]
        }
        
        response = await real_api_client.post(
            "/api/v1/missions",
            json=mission_data,
            headers=auth_headers
        )
        mission = response.json()
        mission_id = mission.get("id") or mission.get("mission_id")
        
        try:
            # Start mission
            await real_api_client.post(
                f"/api/v1/missions/{mission_id}/start",
                json={},
                headers=auth_headers
            )
            
            await self.wait_for_mission_status(
                real_api_client,
                auth_headers,
                mission_id,
                "running",
                timeout=60
            )
            
            # Let it run briefly
            print("\nâ³ Letting mission run (30 seconds)...")
            await asyncio.sleep(30)
            
            # Stop mission
            await real_api_client.post(
                f"/api/v1/missions/{mission_id}/stop",
                json={},
                headers=auth_headers
            )
            
            await self.wait_for_mission_status(
                real_api_client,
                auth_headers,
                mission_id,
                "stopped",
                timeout=30
            )
            
            # Request report generation
            print("\nğŸ“„ Requesting report generation...")
            response = await real_api_client.post(
                f"/api/v1/missions/{mission_id}/report",
                json={"format": "pdf"},
                headers=auth_headers
            )
            
            if response.status_code in [200, 201, 202]:
                report_data = response.json()
                report_id = report_data.get("report_id") or report_data.get("id")
                
                print(f"âœ… Report generation initiated")
                if report_id:
                    print(f"   Report ID: {report_id}")
                
                # Try to get report status
                if report_id:
                    print("\nâ³ Checking report status...")
                    await asyncio.sleep(5)
                    
                    response = await real_api_client.get(
                        f"/api/v1/reports/{report_id}",
                        headers=auth_headers
                    )
                    
                    if response.status_code == 200:
                        report_status = response.json()
                        print(f"âœ… Report status: {report_status.get('status', 'N/A')}")
            else:
                print(f"âš ï¸  Report generation not supported or failed: {response.status_code}")
            
            print("\nâœ… E2E Test PASSED: Mission Report Generation")
            
        except Exception as e:
            print(f"\nâŒ Test FAILED: {str(e)}")
            try:
                await real_api_client.post(
                    f"/api/v1/missions/{mission_id}/stop",
                    json={},
                    headers=auth_headers
                )
            except:
                pass
            raise


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short", "-s"])
